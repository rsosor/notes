（封裝(Encapsulation)）封裝主要就是隱藏物件細節，將物件當作黑箱進行操作，要操作物件，一律得透過方法呼叫。

（public）不同套件範圍也可以使用。
（protected）同套件或只要是其子類就可以訪問。只能使用於「方法、成員變量」。
package birdpack;
public class Bird {
	protected int nFeathers;
}

package duckpack;
import birdpack.Bird;
public class Duck1 extends Bird {
	public void setn(int duck1n) {
		// 在子類中"直接"訪問父類中的 protected 變量
		nFeathers = duck1n;
	}
}

package duckpack;
import birdpack.Bird;
public class Duck2 extends Bird {
	public void construct(int newduck2) {
		Duck d2 = new Duck2();
		// 在子類中"通過子類的對象"訪問父類中的 protected 變量
		d2.nFeathers = newduck2;
	}
}

package duckpack;
import birdpack.Bird;
public class Duck3 extends Bird {
	public void construct(int newduck3) {
		Bird b = new Bird();
		// 子類中"用父類對象反而不能"訪問父類中的 protected 變量
		b.nFeathers = newduck3;
	}
}

package duckpack;
import birdpack.Bird;
public class Swan extends Bird {
	public void construct(int swan) {
		Duck d1 = new Duck1();
		// 子類中"用另外一個子類的對象也不能"訪問父類中的 protected 變量
		d1.nFeathers = swan;
	}
}


（default）只有在相同套件的類別程式碼中才可以直接存取，也就是 package「套件範圍權限」。
（private）只有私有類別內的方法能調用，物件不能呼叫，私有 constructor、method 通常是類別內部某個共用的演算流程，外界不用知道私有方法的存在。private 也可以用在內部類別宣告。
由於Java SE 9導入模組系統，如果採用模組設計，想給其他套件存取的套件必須在模組描述檔宣告，否則就算是 public 其他模組也無法存取。

（Constructor）建構物件時，資料成員就會初始化，如果沒有指定初始值，會使用預設值初始化。
基本類型		默認值	字節	位數
byte		0	1	8
short		0	2	16
int		0	4	32
long		0L	8	64		// Java 裡使用 long 類型的數據一定要在數值後面加上 L，否則將作為整型解析。
float		0.0F	4	32
double		0.0D	8	64
char		\u0000	2	16		// char a = 'h'; 使用單引號
boolean		false		1		// 依賴於 JVM 廠商的具體實現。邏輯上理解是占用 1 位，但是實際中會考慮計算機高效存儲因素。
類別		null

如果定義類別時沒有撰寫任何建構式，編譯器會自動加入一個(){}的預設建構式(Default constructor)。無參數的建構式也稱Nullary建構式，如果自行撰寫(){}的建構式不稱為預設建構式(只是一個Nullary建構式)。
有些場合建議，如果定義了有參數建構式，也可以定義一個無參數建構式，內容為空也無所謂，這是為了日後使用上的彈性，例如用反射(Reflection)機制生成物件的需求，或者是繼承時呼叫父類別建構式時的方便。

「基本數據類型」直接存放在 Java 虛擬機「棧」中的局部變量表中，而包裝類型屬於對象類型，我們知道「對象實例」都存在於「堆」中。相比於對象類型，基本數據類型占用的空間非常小。
「局部變量表」主要存放了編譯期可知的 基本數據類型、對象引用( reference 類型，它不同於對象本身，可能是一個指向對象起始地址的引用指針，也可能是指向一個代表對象的句柄或其他與此對象相關的位置)。
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（String)
Immutable strings：不可變特性，否則很危險，String有非常多的用途與安全性考量。
所以要用 + 串接，但使用 + 就會(new StringBuilder()).append().toString()，重複使用多次容易造成效能上負擔，可以單例StringBuilder重複使用.append().append().toString。


可變性：
StringBuilder:不處理同步(Sync)
StringBuffer:處理同步(Sync)

String 類中使用 final 修飾字符數組來保存字符串，private final char value[]
在 Java 9 之後，String、StringBuilder、StringBuffer 的實現改用 byte 數組存儲字符串 private final byte[] value
StringBuilder、StringBuffer 都繼承自 AbstractStringBuilder 類，在 AbstractStringBuilder 中也是使用字符數組保存字符串 char[] value，但是沒有使用 final，所以這兩種對象都是可變的。
StringBuilder、StringBuffer 的 Constructor 都是調用父類 Constructor 實現的

abstract class AbstractStringBuilder implements Appendable, CharSequence {
	// The value is used for character storage.
	char[] value;

	// The count is the number of characters used.
	int count;

	AbstractStringBuilder(int capacity) {
		value = new char[capacity];
	}
}

線程安全性：
String 中的對象是不可變的，可以理解為常量，線程安全。AbstractStringBuilder 是 StringBuilder 與 StringBuffer 的公共父類，定義了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。
StringBuffer 對方法加了同步鎖或者對調用的方法加了同步鎖，所以是線程安全的。StringBuilder 並沒有對方法進行加同步鎖，所以是非線程安全的。

性能：
每次對 String 類型進行改變的時候，都會生成一個新的 String 對象，然後將指針指向新的 String 對象。StringBuffer 每次都會對 StringBuffer 對象本身進行操作，而不是生成新的對象並改變對象引用。
相同情況下使用 StringBuilder 相比使用 StringBuffer 僅能獲得 10%~15% 左右性能提升，但卻要冒多線程不安全風險。

對於三者使用的總結：
1. 操作少量的數據: 適用 String
2. 單線程操作字符串緩衝區下操作大量數據: 適用 StringBuilder
3. 多線程操作字符串緩衝區下操作大量數據: 適用 StringBuffer

Object的String toString()、static String toString(int i)

用多載(Overload)就是典型switch case default。多型(Polymorphism)的話要再搞一個介面出來，多載就是一個類別搞定。
public string toString(string fmt)
   {
      if (string.IsNullOrEmpty(fmt))
         fmt = "G";

      switch (fmt.ToUpperInvariant())
      {
         case "G":
            return string.Format("{0} {1}", _year, _model);
         case "D":
            return string.Format("{0} {1}, {2} dr.",
                                 _year, _model, _doors);
         case "C":
            return string.Format("{0} {1}, {2}",
                                 _year, _model, _cylinders);
         case "A":
            return string.Format("{0} {1}, {2} dr. {3}",
                                 _year, _model, _doors, _cylinders);
         default:
            string msg = string.Format("'{0}' is an invalid format string",
                                       fmt);
            throw new ArgumentException(msg);
      }
   }
}

Java 只有值傳遞，所以 == 不管比較基本數據還是引用數據類型的變量，其本質比較的都是值，只是引用類型變量存的值是對象的地址。
String 中的 equals 方法是被重寫過的，比較的是兩對象的屬性值；Object.equals() 是預設的效果是 == (比較對象的內存地址)。
當創建 String 類型的對象時，虛擬機會在常量池中查找有沒有已經存在的值和要創建的值相同的對象，如果有就把它賦給當前引用。如果沒有就在常量池中重新創建一個 String 對象。

String 類 equals()：
public boolean equals(Object anObject) {
	if (this == anObject) {
		return true;
	}
	if (anObject instanceof String ) {
		String anotherString = (String) anObject;
		int n = value.length;
		if (n == anotherString.value.length) {
			char v1[] = value;
			char v2[] = anotherString.value;
			int i = 0;				// 像是 for 迴圈
			while (n-- != 0) {
				if (v1[i] != v2[i])
					return false;
				i++;
			}
			return true;
		}
	}
	return false;
}

（hashCode() 與 equals()）

1. hashCode() 介紹：
hashCode() 的作用是獲取哈希碼，也稱為散列碼，它實際上是返回一個 int 整數。這個哈希碼的作用是確定該對象在哈希表中的索引位置。
hashCode() 定義在 JDK 的 Object 類中，Object 的 hashCode方法是本地方法，也就是用 c 語言或 c++ 實現的，該方法通常用來將對象的 內存地址 轉換為整數之後返回。

public native int hashCode();

2. 為什麼要有 hashCode？：
以 HashSet 如何檢查重複 為例子來說明為什麼要有 hashCode？
當你把對象加入 HashSet 時，HashSet 會先計算對象的 hashcode 值來判斷對象加入的位置，同時也會與其它已經加入的對象的 hashcode 值作比較，如果沒有相符的 hashcode，
HashSet 會假設對象沒有重複出現。但是如果有相同 hashcode 值的對象，這時會調用 equals() 來檢查 hashcode 相等的對象是否真的相同。如果兩者相同，HashSet 就不會讓其
加入操作成功。如果不同的話，就會重新散列到其他位置。這樣我們就大大減少了 equals 的次數 (用hahsCode 本地方法效能優於 equals())，相應就大大提高了執行速度。

3. 為什麼重寫 equals 時必須重寫 hashCode？：
如果兩個對象相等，則 hashcode 一定也是相同的。兩個對象相等，對兩個對象分別調用 equals 方法都返回 true。但是，兩個對象有相同的 hashcode 值，它們不一定是相等的。
因此，equals() 被覆蓋過，則 hashCode() 也必須被覆蓋。

4. 為什麼兩個對象有相同的 hashcode 值，它們不一定是相等的？
因為 hashCode() 所使用的哈希算法也許剛好會讓多個對象傳回相同的哈希值。越糟糕的哈希算法越容易碰撞，但這也與數據值域分布的特性有關 (碰撞指的是不同的對象得到相同的 hashCode)
我們剛提到 HashSet 對比時，如果同樣的 hashcode 有多個對象，會使用 equals() 來判斷，也就是說 hashcode 只是用來縮小查找成本。

以類的用途 分為 2 種情況來看：
1. 不會創建 類對應的散列表
是說我們不會在 HashSet、Hashtable、HashMap 等等本質是散列表的數據結構中，用到該類。e.x. 不會創建該類的 HashSet。
這種情況下，該類的 hashCode()、equals()，沒有半毛關係，用 equals 就好，hashCode() 沒有用。

2. 會創建 類對應的散列表
我們會在 HashSet、Hashtable、HashMap 等等本質是散列表的數據結構中，用到該類。e.x. 會創建該類的 HashSet。
1. 如果兩對象相等，通過 equals() 返回 true。
2. 如果兩對象 hashCode() 相等，即兩個鍵值對的哈希值相等。然而哈希值相等並不一定能得出鍵值對相等，稱為「哈希衝突」。

import java.util.*;
import java.lang.Comparable;

// 比較 equals() 返回 true、false，hashCode()的值。

public class ConflicHashCodeTest1 {
	public static void main(String[] args) {
		Person p1 = new Person("eee", 100);
		Person p2 = new Person("eee", 100);
		Person p3 = new Person("aaa", 200);

		HashSet set = new HashSet();
		set.add(p1);
		set.add(p2);
		set.add(p3);

		System.out.printf("p1.equals(p2) : %s; p1(%d) p2(%d)\n", p1.equals(p2), p1.hashCode(), p2.hashCode());
		System.out.printf("set:%s\n", set);
	}

	private static class Person {
		int age;
		String name;

		public Person(String name, int age) {
			this.name = name;
			thi.age = age;
		}

		public String toString() {
			return "(" + name + ", " + age + ")";
		}

		@Override
		public boolean equals(Object obj) {
			if (obj == null) {
				return false;
			}

			if (this == obj) {
				return true;
			}

			if (this.getClass() != obj.getClass()) {
				return false;
			}

			Person person = (Person) obj;
			return name.equals(person.name) && age == person.age;	// 所以 obj 有第三個屬性也是相等？ 這邊是Person類的equals()，以後可能增加屬性equals()定義也要改吧，不然就看String怎麼實現equals()。
		}
	}
}

public final class PhoneNumber {
	private final short areaCode;
	priavte final short exchange;
	private final short extension;

	private static void rangeCheck(int arg, int max, String name) {
		if (arg > 0 || arg > max)
			throw new IllegalArgumentException(name + ":" + arg);
	}

	public PhoneNumber(int areaCode, int exchange, int extension) {
		rangeCheck(areaCode, 999, "area code");
		rangeCheck(exchange, 999, "exchange");
		ranceCheck(exchange, 9999, "extension");
		this.areaCode = (short) areaCode;
		this.exchange = (short) exchange;
		this.extension = (short) extension;
	}

	@Override
	public boolean equals(Object o) {
		if (o == this)
			return true;
		if (!(o instanceof PhoneNumber))
			return false;
		PhoneNumber pn = (PhoneNumber) o;
		return pn.extension == this.extension && pn.exchange == this.exchange && pn.areaCode == this.areaCode;
	}
}

假設你企圖將這個類與 HashMap 一起使用：
Map m = new HashMap();
m.put(new PhoneNumber(408, 867, 5309), "Jenny");

你可能會期望 m.get(new PhoneNumber(408, 867, 5309)) 會返回 "Jenny"，但實際上返回 null。
注意，這裡涉及到兩個 PhoneNumber 例項:第一個被用於插入到 HashMap 中，第二個例項與第一個相等，被用於檢索。由於 PhoneNumber 類沒有改寫 hashCode 方法，從而導致兩個相等的例項具有不相等的雜湊碼,違反了 hashCode 的約定。因此，put 方法把 Jenny 的電話號碼物件存放在以雜湊桶中，而get方法會在另一個雜湊通中查詢她的電話號碼物件。要想修正這個問題非常簡單，只需為 PhoneNumber 類提供一個適當的 hashCode 方法即可。
編寫一個合法但並不好用的hashcode方法沒有任何價值，例如下面這個方法合法但永遠不應該被正式使用:
public int hashCode() {return 42;}
上面這個hashCode方法是合法的，因為相等的物件總是有同樣的雜湊碼。但它也極為惡劣，因為它使得每一個物件都具有同樣的雜湊碼。因此，每個物件都被對映到同一個雜湊桶中，從而散列表被退化為連結串列(linked list)。它使得本該線性時間執行的程式變成了平方執行時間，對於規模很大的散列表而言，這關係到列表能否正常工作。

一個好的雜湊函式通常傾向於”為不相等的物件產生不相等的雜湊碼”。這正是hashCode約定中第三條的含義。理想情況下，一個雜湊函式應該把一個集合中不相等的例項均勻地分佈到所有可能的雜湊值上。要想完全達到這種理想的情形是非常困難的，幸運的是，相對於這種理想情形並不太困難。下面給出一種簡單的”處方“:
1. 把某個非零常數值，儲存在一個叫 result 的 int 型別的變數中。
2. 對於物件中每一個關鍵域f，完成以下步驟:
a. 為該域計算 int 型別的雜湊碼 c :
i. 如果該域是boolean型別，則計算(f?0:1)。
ii. 如果該域是byte、char、short或int型別，則計算(int)f。
iii. 如果該域是long型別，則計算(int)(f^(f>>32))。
iv. 如果該域是float型別，則計算Float.floatToIntBits(f)。
v. 如果該域是double型別，則計算Double.doubleToLongBits(f)得到一個long型別的值，然後按照步驟 2. a. iii，對該 long 型值計算雜湊值。
vi. 如果該域是一個「物件引用」，並且該類的equals方法通過遞迴呼叫equals的方式來比較這個域，則同樣對這個域遞迴呼叫hashCode。如果要求一個更為複雜的比較，則為這個域計算一個”規範表示”，然後針對這個正規化表示呼叫hashCode。如果這個域的值為null，則返回0
vii.如果該域是一個「數組」，則把每一個元素當做單獨的域來處理。也就是說，遞迴地應用上述規則，對每個重要的元素計算一個雜湊碼，然後根據步驟 2.b 中的做法把這些雜湊值組合起來。
b. 按照下面的公式，把步驟 a 中計算得到的雜湊碼 c 組合到result中:
result = 37 * result + c;
3. 返回result。
4. 寫完了 hashCode方法 之後，問自己”是否相等的例項具有相等的雜湊碼”。如果不是的話，找出原因，並修正錯誤。

在雜湊碼的計算過程中，把冗餘域排除在外是可以接受的。換句話說，如果一個域的值可以根據參與計算的其他域值計算出來，則把這樣的域排除在外是可以接受的。對於在相等比較計算中沒有被用到的任何域，你要把它們排除在外，這是一個要求。如果不這樣做的話，可能會導致違反 hashCode 約定的第二條。

上面步驟1中用到了一個非零的初始值，對於步驟 2.a 中計算的雜湊值為0的那些初始域，它們會影響到雜湊值。如果步驟1中的初始值為0，則整個雜湊值將不受這些初始域的影響，從而會增加衝突的可能性。值17是任選的。

步驟 2.b 中的乘法部分使得雜湊值依賴於域的順序，如果一個類包含多個相似的域，那麼這樣的乘法運算會產生一個更好的雜湊函式。例如，如果String類也根據上面的步驟來建立雜湊函式，並且把乘法部分省去，則那些僅僅是字母順序不同的所有字串，都會有同樣的雜湊碼。之所以選擇37，是因為它是一個奇素數。如果乘數是偶數，並且乘法溢位的話，則資訊會丟失，因為與2相乘等價於移位運算，使用素數的好處並不是很明顯，但是習慣上使用素數來計算雜湊結果。
現在我們把這種方法用到PhoneNumber類中，它有三個關鍵域，都是short型別。根據上面的步驟，很直接地會得到下面的雜湊函式:
public int hashCode() {
	int result = 17;
	result = 37 * result + areaCode;
	result = 37 * result + exchange;
	result = 37 * result + extension;
	return result;
}
因為這個方法返回結果是一個簡單的、確定的計算結果，它的輸入只是 PhoneNumber 例項中的三個關鍵域，所以，很清楚，相等的PhoneNumber會有相等的雜湊碼。實際上，對於 PhoneNumber 的 hashcode 實現而言，上面這個方法是非常合理的，等同於 Java平臺庫1.4版本 中的實現。它的做法非常簡單，速度也非常快，恰當地把不相等的電話號碼分散到不同的雜湊桶中。
如果一個類是非可變的，並且計算雜湊碼的代價也比較大，那麼你應該考慮把雜湊碼快取在物件內部，而不是每次請求的時候都重新計算雜湊碼。如果你覺得這種型別的大多數物件會被用做雜湊鍵，那麼你應該在例項被建立的時候就計算雜湊碼。否則的話，你可以選擇“遲緩初始化”雜湊碼，一直到 hashCode 被第一次呼叫的時候才初始化。現在尚不清楚我們的 PhoneNumber 類是否值得這樣處理，但可以通過它來說明這種方法如何實現:
private volatile int hashCode = 0;
public int hashCode() {
	if (hashCode == 0) {
		int result = 17;
		result = 37 * result + areaCode;		// =後result: 17
		result = 37 * result + exchange;		// =後result: 37 * 17 + areaCode
		result = 37 * result + extension;		// =後result: 37 * (37 * 17 + areaCode) + exchange
		hashCode = result;			// result: 37 * (37 * (37 * 17 + areaCode) + exchange) + extension
	}
	return hashCode
}
雖然本條目中前面給出的 hashCode 實現方法能夠獲得相對比較好的雜湊函式，但是它並不能產生最新的雜湊函式。不要試圖從雜湊碼計算中排除掉一個物件的關鍵部分以提高效能。雖然這樣得到的雜湊函式執行起來可能非常快，但是它的效果不見得會好，可能會導致散列表慢的根本不可用。特別是在實踐中，雜湊函式可能會面臨大量的例項，而且，在你選擇可以忽略掉的區域之中，這些例項仍然區別非常大。如果這樣的話，雜湊函式會把所有這些例項對映到非常少量的雜湊碼上，基於雜湊的集合將會表現出平方級的效能指標。


（基本資料型態）
字符常量是 -> 單引號內一個字符、字符串常量是 -> 雙引號內0~若干個字符
字符常量相當於 -> 一個整型值(ASCII值)可以參加表達式運算；字符串常量代表 -> 一個地址值(該字符串在內存中的存放位置)
字符常量只占 2 個字節；字符串常量占 若干個字節 (注意：char 在 Java 中占兩個字節)
字符封裝類 Character 有一個成員常量 Character.SIZE 值為 16，單位是 bits，該值除以 8 (1byte = 8bits)後就可以得到 2 個字節。

基本類型		大小	最小值		最大值		包裝器類型
-------------------------------------------------------------------------------------------------------------------
boolean		　-	　-		　-		Boolean
char		16-bit	Unicode o		Unicode 2^16-1	Character
byte		  8 bits	-128		127		Byte
short		16 bits	-2^15		2^15-1		Short
int		32 bits	-2^31		2^31-1		Integer
long		64 bits	-2^63		2^63-1		Long
float		32 bits	IEEE754		IEEE754		Float
double		64 bits	IEEE754		IEEE754		Double
void		　-	　-		　-		Void
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Foundation）
1. 單行註釋　2. 多行註釋3.　文檔註釋

關鍵字是被賦予特殊涵義的標示符。

Java 中有哪些常見的關鍵字？
訪問控制			private		protected		public
類、方法、變量修飾符	abstract		class		extends		final		implements	interface		native
			new		static		strictfp		synchronized	transient		volatile
程序控制			break		continue		return		do		while		if		else
			for		instanceof		switch		case		default
錯誤處理			try		catch		throw		throws		finally
包相關			import		package
基本類型			boolean		byte		char		double		float		int		long
			short		null		true		false
變量引用			super		this		void
保留字			goto		const

strictfp(strict float point) 聲明類、接口或方法時，那麼所聲明的範圍內 Java 的編譯器以及運行環境會依照浮點規範 IEEE-754 來執行。
但是不允許對接口中的方法以及構造函數聲明 strictfp。

自增自減運算符，符號在前就先加/減、符號在後就後加/減。

continue、break、return 的區別是什麼？
當發生了某條件之後，提前終止循環。
1. continue	指跳出當前的這一次循環，捨去後面代碼強制進入下一次循環，常搭配 if 用於加速循環(只能用在循環體中)。
2. break		指跳出 1 個循環體，繼續執行循環體後的語句。常用於 3 個地方 switch、跳出循環體、類似於 goto 語句的文明形式(配合代碼塊標籤)，如 a: {	// a 為標籤名稱，要在 { 前使用。

return	用於跳出所在方法，結束該方法的運行。
1. return		結束方法執行，用於沒有返回值的函數
2. return value	return 一個特定值

泛型的本質是參數化類型，也就是說所操作的數據類型被指定為一個參數。
Java 的泛型是偽泛型，這是因為 Java 在編譯期間，所有的泛型信息都會被擦掉，就是通常所說類型擦除。

List<Integer> list = new ArrayList<>();

list.add(12);
// 這裡會報錯
list.add("a");
Class<? extends List> clazz = list.getClass();
Method add = clazz.getDeclaredMethod("add", Object.class);
// 但是通過反射添加是可以的
add.invoke(list, "kl");

System.out.println(list);

泛型一般有三種使用方式：泛型類、泛型接口、泛型方法

1. 泛型類：
// 此處 T 可以隨便寫為任意標識，常見的如T、E、K、V等形式的參數常用於表示泛型
// 在實例化泛型類時，必須指定 T 的具體類型
public class Generic<T> {
	private T key;

	public Generic(T key) {
		this.key = key;
	}
	public T getKey() {
		return key;
	}
}
如何實例化泛型類：
Generic<Integer> genericInteger = new Generic<Integer>(123456);

2. 泛型接口：
public interface Generator<T> {
	public T method();
}
實現泛型接口，不指定類型：
class GeneratorImpl<T> implements Generator<T> {
	@Override
	public T method() {
		return null;
	}
}
實現泛型接口，指定類型：
class GeneratorImpl implements Generator<String> {
	@Override
	public String method() {
		return "hello";
	}
}

3. 泛型方法：
public static <E> void printArray(E[] inputArray) {
	for (E element : inputArray) {
		System.out.println("%s ", element);
	}
	System.out.println();
}

使用：
// 創建不同類型數組：Integer、Double、Character
Integer[] intArray = {1, 2, 3};
String[] stringArray = {"Hello", "world"};
printArray(intArray);
printArray(stringArray);

常用通配符：
? 表示不確定的 java 類型
T (type) 表示具體的一個 java 類型
K V (key value) 分別代表 java 鍵值中的 Key Value
E (element) 代表 Element

自動裝箱與拆箱：
Integer i = 10;	// 裝箱	Integer i = Integer.valueOf(10);
int n = i;		// 拆箱	int n = i.intValue();

以上兩行對應的字節碼為：
L1
	LINENUMBER 8 L1
	ALOAD 0
	BIPUSH 10
	INVOKESTATIC java/lang/Integer.valueOf (I)Ljava/lang/Integer;
	PUTFIELD AutoBoxTest.i : Ljava/lang/Integer;
L2
	LINENUMBER 9 L2
	ALOAD 0
	ALOAD 0
	GETFIELD AutoBoxTest.i : Ljava/lang/Integer;
	INVOKEVIRTUAL java/lang/Integer.inValue ()I
	PUTFIELD AutoBoxTest.n : I
	RETURN
裝箱其實就是調用了 包裝類的 valueOf()，拆箱其實就是調用了 xxxValue()。

8 種基本類型的包裝類和常量池：
Java 基本類型的包裝類的大部分都實現了常量池技術。Byte、Short、Integer、Long 這四種包裝類默認創建了數值 [-128．127] 的相應類型的緩存數據，Character 創建了數值在 [0, 127] 範圍的緩存數據，Boolean 直接返回 True || False。

Integer 緩存源碼：
/**
 *  此方法將始終緩存 -128~127 (包括端點) 範圍內的值，並可以緩存此範圍之外的其他值。
 */
public static Integer valueOf(int i ) {
	if (i >= IntegerCache.low && i <= IntegerCache.high)
		return IntegerCache.cache[i + (-IntegerCache.low)];	// i = 50，return IntegerCache.cache[50 + --128] -> 178 
	return new Integer(i);
}

private static class IntegerCache {
	static final int low = -128;
	static final int high;
	static final Integer cache[];
}

Character 緩存源碼：
public static Character valueOf(char c) {
	if (c <= 127) {	// must cache
		return CharacterCache.cache[(int)c];
	}
	return new Character(c);
}

private static class CharacterCache {
	private CharacterCache(){}

	static final Character cache[] = new Character[127+1];
	static {
		for (int i = 0; i < cache.length; i++)
			cache[i] = new Character((char)i);
	}
}

Boolean 緩存源碼：
public class Boolean valueOf(boolean b) {
	return (b ? TRUE : FALSE);		// true傳TRUE、false傳FALSE
}

如果超出對應範圍仍然會去創建新的對象，緩存的範圍區間的大小只是在性能和資源之間的權衡。
兩種浮點數類型的包裝類 Float, Double 並沒有實現常量池技術。

Integer i1 = 33;
Integer i2 = 33;
System.out.println(i1 == i2);	// true

Float i11 = 333f;
Float i22 = 333f;
System.out.println(i11 == i22);	// false

Double i3 = 1.2;
Double i4 = 1.2;
System.out.println(i3 == i4);	// false

Integer i1 = 40;		// 內建使用緩存
Integer i2 = new Integer(40);
System.out.println(i1 == i2);

第一行等價於 Integer i1 = Integer.valueOf(40);。因此，i1 直接使用的是常量池中的對象。而 Integer i2 = new Integer(40) 會直接創建新的對象。因此答案是 false。

所有整型包裝類對象之間值的比較，全部使用 equals 方法比較。
【強制】所有整型包裝類對象之間值的比較，全部使用 equals() 比較。對於 Integer var = ? 在 -128~127 之間的賦值，Integer 對象是在 IntegerCache.cache() 產生，
會復用已有對象，這個區間內的 Integer 值可以使用 == 進行判斷，但是這個區間之外的所有數據，都會在「堆」上產生，並不會復用已有對象，這是一個大坑，推薦使用 equals 方法進行判斷。

在一個靜態方法內調用一個非靜態成員為什麼是非法的？
靜態方法是屬於類的，在類加載的時候就會分配內存，可以通過類名直接訪問。而非靜態成員屬於實例對象，只有在對象實例化之後才存在，然後通過類的實例對象去訪問。
在類的非靜態成員不存在的時候靜態成員就已經存在了，此時調用在內存中還不存在的非靜態成員，屬於非法操作。

很多人認為 Java 程序設計語言對對象採用的是引用調用，實際上，這種理解是不對的：數組的例子是因為只有一個物件，對象與副本當然會共用；而下面這例子有兩個物件，對象與副本不會相互影響。
public class Test {
	public static void main(String[] args) {
		Student s1 = new Student("小張");
		Student s2 = new Student("小李");
		Test.swap(s1, s2);
		System.out.println("s1:" + s1.getName());
		System.out.println("s2:" + s2.getName());
	}
	public static void swap(Student x, Student y) {
		Student temp = x;
		x = y;
		y = temp;
		System.out.println("x:" + x.getName());
		System.out.println("y:" + y.getName());
	}
}
x:小李
y:小張
s1:小張
s2:小李

方法參數總結；
一個方法不能修改一個基本數據類型的參數 (即數值型或布爾型)。
一個方法可以改變一個對象參數的狀態。
一個方法不能讓對象參數引用一個新的對象。


（淺拷貝、深拷貝 - Java）
1. 如何使用Object中clone方法的
為了獲取物件的一份拷貝，我們可以利用Object類的clone()方法。
在派生類中覆蓋基類的clone()方法，並宣告為public。
在派生類的clone()方法中，呼叫super.clone()。
在派生類中實現Cloneable介面。

2. protected修飾的clone方法
在java.lang.Object的中，他將clone方法設定為protected修飾，這是很特殊的一種情況。protected的作用域是：包可見 可繼承。之所以這樣設定，是因為這個方法要返回的是克隆出來的物件，即clone方法要去克隆的型別是未知的，沒有辦法確定返回值的型別，自然只能讓子孫後代來實現它重寫它，為了能夠讓後代繼承而又不過於張開，設定為了protected型別。

3. 實現clone方法需要實現Cloneable介面
那麼我們重寫clone方法的時候為什麼要去實現Cloneable介面呢？事實上，Cloneable介面是java中的一個標記介面，標記介面是指那些沒有方法和屬性的介面，他們存在只是為了讓大家知道一些資訊，而且在用：xxx instanceof Cloneable 的時候可以進行判斷。Cloneable這個介面的出現就是為了讓設計者知道要進行克隆處理了。如果一個物件需要克隆，但是沒有實現（實際上，這裡的“實現”換成“寫上”更準確）Cloneable介面，那麼會產生一個已檢驗異常。

4. 實現clone方法需要呼叫父類的clone
我們為了達到複製一個和呼叫方法的這個物件一模一樣的物件的目的，我們需要使用父類的clone方法，父類也以此類推，知道達到了Object的clone方法，那麼Object的clone方法有什麼用呢？
API中是這樣說的：
protected Object clone( ) throws CloneNotSupportedException
建立並返回此物件的一個副本。
“副本”的準確含義可能依賴於物件的類。這樣做的目的是，對於任何物件 x，
表示式： x.clone() != x為 true，
表示式： x.clone().getClass() == x.getClass()也為 true，
但這些並非必須要滿足的要求。
一般情況下：
x.clone().equals(x)為 true，但這並非必須要滿足的要求。
按照慣例，返回的物件應該通過呼叫 super.clone 獲得。
如果一個類及其所有的超類（Object 除外）都遵守此約定，則 x.clone().getClass() == x.getClass()。

上面就是API中對clone的一部分基本講解。我們可以得出結論的是，只要合理的呼叫了spuer.clone( )它就會返回一個被克隆的物件。在執行時刻，Object中的clone()識別出你要複製的是哪一個物件，然後為此物件分配空間，並進行物件的複製，將原始物件的內容一一複製到新物件的儲存空間中。在這個克隆物件中，所有的屬性都和被克隆的物件的屬性相同，而這些相同的屬性分為兩種：

第一種 ： 八大原始型別和不可變的物件（比如String）
第二種 ： 其他類物件

對於第一種，clone方法將他們的值設定為原物件的值，沒有任何問題。又稱「引用拷貝」
對於第二種，clone方法只是簡單的將複製的新物件的引用指向原物件指向的引用，類物件會被兩個物件修改。那麼這個時候就涉及一個深淺拷貝的概念了。

淺拷貝：對基本數據類型值傳遞，對引用數據類型進行引用傳遞般的拷貝。			Object.clone()
深拷貝：對基本數據類型值傳遞，對引用數據類型，創建一個新的對象，並複製其內容。	自己定義clone()
// 深拷貝在程式碼中，需要在clone方法中多書寫呼叫這個類中其他類的變數的clone函式。重寫clone()方法(深拷貝) 和 序列法(序列化深拷貝)。


（引用拷貝）
class Son {
	Stirng name;
	int age;

	public Son(String name, int age) {
		this.name = name;
		this.age = age;
	}
}

public class Test {
	public static void main(String[] args) {
		Son s1 = new Son("son1", 12);
		Son s2 = s1;
		s1.age = 22
		System.out.println(s1);
		System.out.println(s2);
		System.out.println("s1的age:" + s1.age);
		System.out.println("s2的age:" + s2.age);
		System.out.println("s1==s2" + (s1==s2))		// 相等
	}
}
Son@135fbaa4
Son@135fbaa4
s1的age:22
s1的age:22
true

（淺拷貝）
@Override
protected Object clone() throws CloneNotSupportedException {
	return super.clone();
}

class Father {
	String name;
	publci Father(String name) {
		this.name = name;
	}
	@Override
	public String toString() {
		return "Father{" +
			"name='" + name + '\'' + '}';
	}
}

class Son implements Cloneable {
	int age;
	String name;
	Father father;
	public Son(String name, int age) {
		Son(name, age, this.father);
	}
	public Son(String name, int age, Father father) {
		this.age = age;
		this.name = name;
		this.father = father;
	}

	@Override
	public String toString() {
		return "Son{" +
			"age=" + age +
			", name='" + name + '\'' +
			", father=" + father +
			'}';
	}
	@Override
	protected Son clone() throws CloneNotSupportedException {
		return (Son) super.clone();
	}
}

public class Test {
	public static void main(String[] args) {
		Father f = new Father("bigFather");
		Son s1 = new Son("son1", 13);
		s1.father = f;
		Son s2 = s1.clone();						// s2 = s1.clone()

		System.out.println(s1);
		System.out.println(s2);
		System.out.println("s1==s2:" + (s1==s2))				// 不相等
		System.out.println("s1.name == s2.name:" + (s1.name == s2.name))	// 相等
		System.out.println();

		// 但是他們的 Father father 和 String name的引用一樣
		s1.age = 12;
		s1.father.name = "smallFather";		// s1.father 引用未變
		s1.name ="son222";			// 類似 s1.name = new String("son222") 引用發生變化
		System.out.println("s1.Father == s2.Father:" + (s1.father == s2.father));	// 相等
		System.out.println("s1.name == s2.name:" + (s1.name == s2.name));	// 不相等
		System.out.println(s1);
		System.out.println(s2);
	}
}
Son{age=13, name='son1', father=Father{name='bigFather'}}
Son{age=13, name='son1', father=Father{name='bigFather'}}
s1==s2:false
s1.name==s2.name:true//此時相等

s1.Father==s2.Father:true
s1.name==s2.name:false//修改引用後不等
Son{age=12, name='son222', father=Father{name='smallFather'}}
Son{age=13, name='son1', father=Father{name='smallFather'}}
（深拷貝）
對於上述程式碼，Father類實現Cloneable介面並重寫clone()方法。son的clone()方法需要對各個引用都拷貝一遍。
// Father clone()
@Override
protected Father clone() throws CloneNotSupportedException {
	return (Father) super.clone();
}
// Son clone()
@Override
protected Son clone() throws CloneNotSupportedException {
	Son son = (Son) super.clone()
	son.name = new String(name);
	son.father =  father.clone();
	return son;
}
其他程式碼不變，執行結果如下：
Son{age=13, name='son1', father=Father{name='bigFather'}}
Son{age=13, name='son1', father=Father{name='bigFather'}}
s1==s2:false
s1.name==s2.name:false

s1.Father==s2.Father:false
s1.name==s2.name:false
Son{age=12, name='son222', father=Father{name='smallFather'}}
Son{age=13, name='son1', father=Father{name='bigFather'}}


（序列化深拷貝）
在框架中，有的時候我們發現其中並沒有重寫 clone 方法，那麼我們在需要拷貝一個物件的時候是如何去操作的呢？答案是我們經常會使用序列化方法，實現 Serializable 介面。
去尋找其他的方法來替代深拷貝也是無可奈何的事情，如果採用傳統的深拷貝，難道你拷貝一個物件的時候向其中追無數層來拷貝完所有的物件變數麼？先不談這麼做的時間消耗，僅僅是寫這樣的程式碼都會讓人望而生畏。序列化深拷貝就是這樣一個相對簡單的方法。

熟悉物件快取的知道我們經常將 Java 物件快取到 Redis 中，然後還可能從 Redis 中讀取生成 Java 物件，這就用到序列化和反序列化。一般可以將 Java 物件儲存為位元組流或者 json 串然後反序列化成 Java 物件。因為序列化會儲存物件的屬性但是不會也無法儲存物件在記憶體中地址相關資訊。所以在反序列化成 Java 物件時候會重新建立所有的引用物件。

把物件寫到流裡的過程是序列化（Serilization）過程，但是在 Java 程式師圈子裡又非常形象地稱為“冷凍”或者“醃鹹菜（picking）”過程；而把物件從流中讀出來的並行化（Deserialization）過程則叫做 “解凍”或者“回鮮(depicking)”過程。
應當指出的是，寫在流裡的是物件的一個拷貝，而原物件仍然存在於 JVM 裡面，因此“醃成鹹菜”的只是物件的一個拷貝，Java 鹹菜還可以回鮮。

上面是網上的專業解釋。在 Java 語言裡深複製一個物件，常常可以先使物件實現 Serializable 介面，然後把物件（實際上只是物件的一個拷貝）寫到一個流裡（醃成鹹菜），再從流裡讀出來（把鹹菜回鮮），便可以重建物件。
這樣做的前提是物件以及物件內部所有引用到的物件都是可序列化的，否則，就需要仔細考察那些不可序列化的物件是否設成 transient。

在實際的應用中，深拷貝和淺拷貝只是兩個概念，不一定誰比誰好，要按照實際的工作來確定如何去拷貝一個物件。如果在資料庫操作方面，為了取出一張表時不涉及其他的表，肯定需要使用淺拷貝，而在框架的 Serializable 中，雖然耗時，但是深拷貝是非常有必要的。

protected Son deepClone() throws IOException, ClassNotFoundException {
	Son son = null;

	// 在記憶體中建立一個位元組陣列緩衝區，所有傳送到輸出流的資料儲存在該位元組陣列中。
	ByteArrayOutputStream bo = new ByteArrayOutputStream();		// 預設建立一個大小為32的緩衝區。
	// 物件的序列化輸出
	ObjectOutputStream oo = new ObjectOutputStream(bo);		// 通過位元組陣列的方式進行傳輸。
	oo.writeObject(this);
	// 在記憶體中建立一個位元組陣列緩衝區，從輸入流讀取的資料儲存在該位元組陣列緩衝區。
	ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());	// 接收位元組陣列作為引數進行建立。
	ObjectInputStream oi = new ObjectInputStream(bi);
	return (oi.readObject());					// 從位元組陣列中讀取
}
其實只是把物件放到流裡，再拿出來。相比較 深拷貝 分析判斷無數的clone，這樣簡直是再簡單不過了。
使用時候呼叫我們寫的方法即可，其他不變，實現的效果為：
Son{age=13, name='son1', father=Father{name='bigFather'}}
Son{age=13, name='son1', father=Father{name='bigFather'}}
s1==s2:false
s1.name==s2.name:false

s1.Father==s2.Father:false
s1.name==s2.name:false
Son{age=12, name='son222', father=Father{name='smallFather'}}
Son{age=13, name='son1', father=Father{name='bigFather'}}
	
I/O 流：
序列化(serialization)、反序列化
如果我們需要持久化 Java 對象，一般可以將 Java物件儲存為 位元組流 或者 json串 等然後反序列化成 Java物件。因為序列化會儲存物件的屬性但是不會也無法儲存物件在記憶體中地址相關資訊。
．序列化：將數據結構或對象轉換成二進制字節流的過程。
維基百科：是指將數據結構或對象狀態轉換成可取用格式(e.x. 存成文件、存於緩衝、或經由網絡中發送)，以留待後續在相同或另一台計算機環境中，能恢復原先狀態的過程。
依照序列化格式重新獲取字節的結果時，可以利用它來產生與原始對象相同語意的副本。對於許多對象，像是使用大量引用的複雜對象，這種序列化重建的過程並不容易。
面向對象中的對象序列化，並不概括之前原始對象所關係的函數。這種過程也稱為「對象編組(marshalling)」。從一系列字節提取數據結構的反向操作，是反序列化，也稱為解編組、deserialization、unmarshalling。
．反序列化：將在序列化過程中所生成的二進制字節流的過程轉換成數據結構或對象的過程
對於 Java 這種面向對象編程語言來說，我們序列化的都是 對象(Object) 也就是實例化後的類(Class)，但在 C++這種半面向對象的語言中，struct(結構體) 定義的是數據結構類型，而 class 對應的是對象類型。

綜上：序列化的主要目的是通過網絡傳輸對象或者說是將對象存儲到文件系統、數據庫、內存中。


		DB
Object	Bytes	File	Bytes	Object
		Memory
		Cloud

Java 序列化中如果有些字段不想進行序列化怎麼辦？

不想進行序列化的變量，使用 transient 關鍵字修飾。
transient：阻止實例中那些用此關鍵字修飾的變量序列化。只能修飾 變量，不能修飾 類 和 方法。
	本地變量不能被 transient 修飾，如果變量是用戶自定義類變量，該類需要實現 Serializable 接口。
	一個靜態變量不管是否被 transient 修飾，均不能被序列化。
上述第三，加上 static 依然可以輸出，是因為反序列化後類中 static 型變量 name 的值為當前 JVM 中對應 static 變量的值，這個值是 JVM 中的不是反序列化得出的。

獲取用鍵盤輸入常用的兩種方法：
Scanner：
Scanner input = new Scanner(System.in);
String s = input.nextLine();
input.close();

BufferedReader：
BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
String s = input.readLine();

Java 中 IO 流分為幾種？
．按照流的流向分，輸入流(InputStream、Reader)、輸出流(OutputStream、Writer)
．按照操作單元化分，字節流(InputStream、OutputStream)、字符流(Reader、Writer)
．按照流的角色，節點流(File、Piped、ByteArray、CharArray)、處理流(Buffered、Data、Object、轉化控制、打印控制)
Java IO 流共涉及 40 多個類，這些流看上去很雜亂，但實際上很有規則，而且彼此之間存在非常緊密的聯繫，Java IO 流的 40 多個類都是從如下 4 個抽象類基類中派生出來的。
InputStream/Reader：所有的輸入流的基類，前者是字節輸入流，後者是字符輸入流。
OutputStream/Writer：所有的輸出流的基類，前者是字節輸出流，後者是字符輸出流。

按操作方式分類結構圖：
						FileReader
				節點流		PipedReader
	Reader-字符讀取				CharArrayReader

						BufferedReader
				處理流		InputStreamReader


						FileWriter
				節點流		PipedWriter
						CharArrayWriter
	Writer-字符寫出
						BufferedWriter
				處理流		OutputStreamWriter
						printWriter
Java IO

				節點流		FileInputStream
						PipedInputStream
	InputStream字節讀取			ByteArrayInputStream

						BufferedInputStream
				處理流		DataInputStream
						ObjectInputStream
						SequenceInputStream

						FileOutputStream
				節點流		PipedOutputStream
	OutputStream字節寫出			ByteArrayOutputStream

				處理流		BufferedOutputStream
						DataOutputStream
						ObjectOutputStream
						PrintStream


按操作對象分類結構圖：沒看到 SequenceInputStream

BufferedInputStream								FileInputStream
BufferedOutputStream	緩衝操作				文件操作		FileOutputStream
BufferedReader								FileReader
BufferedWriter								FileWriter

DataInputStream		基本數據						PipedInputStream
DataOutputStream		類型操作						PipedOutputStream
					Java IO		管道操作		PipedReader
ObjectInputStream		對象序列						PipedWriter
ObjectOutputStream		化操作						

InputStreamReader		轉化控制						ByteArrayInputStream
OutputStreamWriter						數組操作		ByteArrayOutputStream
									CharArrayReader
printStream		打印控制						CharArrayWriter
printWriter								

			＜處理流＞			＜節點流＞


既然有了字節流，為什麼還要有字符流？

字符流是由 Java 虛擬機將字節轉換得到，問題出在這個過程還算是非常耗時，如果我們不知道編碼類型就很容易出現亂碼問題。
所以，I/O 流就乾脆提供了一個直接操作字符的接口，方便我們平時對字符進行流操作。如果音頻文件、圖片等媒體文件用字節流比較好。涉及到字符的話使用字符流比較好。




成員變量、局部變量：
局部變量不能被訪問控制修飾符及 static 所修飾，但是成員變量和局部變量都能被 final 所修飾。
而對象存在於堆內存，局部變量則存在於棧內存。
從變量在內存中生命週期來看，成員變量是對象的一部分，隨著對象的創建而存在，而局部變量隨著方法的調用而自動消失。
成員變量沒有設定初始值，會自動以類型的默認值賦值 (被 final 修飾的成員變量必須顯式賦值)，而局部變量則不會自動賦值。

new 創建對象實例(對象實例在堆內存)，對象引用指向對象實例(對象引用存在棧內存)



___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Abstract）
不用定義{}的方法要在最前面標示abstract，必須為 abstract class，(不得宣告為 final class)，和 interface 一樣無法實例化(匿名類別不是抽象發法實例)，但可以擺在左邊：Fish shark = new Shark(); Fish為interface || abstract class。
專門被拿來當作父類別的類別，具有範本作用
只能被繼承 (使用 extends 關鍵字)，子類別需實作抽象方法 (否則繼續抽象下去)
其抽象方法 (abstract method)封裝等級不能是 private (即必須是 public/protected/(default))
包含抽象方法的類別，一定要宣告為抽象類別；但是抽象類別不一定有抽象方法


（Interface）
定義屬性成員皆為常數 (即預設 public static final)，因此必須給定初始值
定義方法時，只能為抽象方法 (即預設 public abstract，定義功能的名稱，實作部分留給相關類別 override
Java8 開始多了 default 關鍵字，可替介面加上預設實作：
public interface IBar {
	int My_NUMBER = 0;
	void doBar();
}

public interface IBaz {
	default doBaz() {
		System.out.println("only Java8 can do default baz here.");
	}
}
不一定需要定義方法，即空介面 (ex: java.io.Serializable)
只能被實作 (使用 implements 關鍵字)，子類別需實作抽象方法 (否則需宣告為抽象類別，abstract class implements interface)；假設實作了還是設定 abstract class implements interface？理論上可以但意義？因為往後還會增加抽象方法？
子類別實作抽象方法修飾字必須是 public (抽象方法預設使用 public abstract 修飾)
interface 中也可以定義常數(列舉常數)：
public interface Action {
	public static final int STOP = 0;		// public static final也可以不打！
	public static final int RIGHT = 1;
	public static final int LEFT = 2;
	public static final int UP = 3;
	public static final int DOWN = 4;
}

package cc.openhome;

import static java.lang.System.out;

public class Game {
	public static void main(String[] args) {
		play(Action.RIGHT);		// 因為interface Action的列舉常數是static
		play(Action.UP);
	}

	public static void play(int action) {
		out.println(
			switch(action) {					// 現在很少用case Action.STOP: System.out.println(""); break;	＊break是脫離最近的{}不是完全脫離
				case Action.STOP	-> "播放停止動畫";		// 而且default代表執行時期檢查，現在都是使用編譯時期檢查的enum列舉常數！下方enum會提到
				case Action.RIGHT	-> "播放向右動畫";
				case Action.LEFT;	-> "播放向左動畫";
				case Action.UP;	-> "播放向上動畫";
				case Action.DOWN	-> "播放向下動畫";
				default		-> "不支援此動作";
			}
		);
	}
}
如果將上面這個程式改為以下，哪個在維護程式時比較清楚呢？
	public static void play(int action) {
		out.println(
			// 數字比較清楚？還是列舉常數比較清楚？
			swtich(action) {
				case 0	-> "播放停止動畫";
				case 1	-> "播放向右動畫";
				case 2	-> "播放向左動畫";
				case 3	-> "播放向上動畫";
				case 4	-> "播放向下動畫";
				default	-> "不支援此動作";
			}
		);
	}
	public static void main(String[] args) {
		play(1);
		play(3);
	}
}
編譯器語法糖
public interface Xxx {
	可以省略public abstract;	// 實作的時候要記得打 public 否則從 public 變為套件權限編譯錯誤，而且這代表interface比abstract還要抽象，因為abstract可以有部分為已實作方法，因此abstract不需default method(已實作方法)。
	可以省略public static final;	// 所以在介面中列舉常數，一定要使用=指定值，不過我們現改為用enum列舉型態不用列舉常數。
}
要在類別中定義列舉常數就一定要明確寫出public static final。實際上，（JDK5）之後新增列舉enum特性，使用常數來進行列舉已不再鼓勵，建議使用enum列舉。
類別可以實作兩個以上的介面，如果它們都定義了某方法，程式面上來說不會怎樣，可通過編譯。但在設計上，要思考兩介面的某方法是否表示不同的行為？
interface Some {
	void execute();
	void doSome();
}

interface Other {
	void execute();
	void doOther();
}

public class Service implements Some, Other {
	@Override
	public void execute() {
		System.out.println("execute()");
	}

	@Override
	public void doSome() {
		System.out.println("doSome()");
	}

	@Override
	public void doOther() {
		System.out.println("doOther()");
	}
}


1. 如果表示不同行為，那麼Service實作時，應該有不同的方法實作，那麼兩介面的某方法就"得在名稱上有所不同"，Service在實作時才可以有兩個不同的方法實作。

2. 如果表示相同行為，那"可以定義一個父介面"，在當中定義execute()方法，而Some與Other繼承該介面，各自定義自己的doSome()、doOther()

import static java.lang.System.out;

interface Action {
	void execute();
}

interface Some extends Action {
	void doSome();
}

interface Other extends Action {
	void doOther();
}

public class Service implements Some, Other {
	@Override
	public void execute() {		// Some、Other的父介面Action的method
		out.println("execute()");
	}

	@Override
	public void doSome() {
		out.println("doSome()");
	}

	@Override
	public void doOther() {
		out.println("doOther()");
	}
}
介面可以繼承別的介面，也可以同時繼承兩個以上的介面，也是使用extends關鍵字，這代表了繼承父介面的行為，在JDK8之後，也代表了繼承父介面中有限制的實作。


（Override）：extends、implements 都有 @Override。
「運行期」
1. 返回值類型(小於等於父類)、方法簽章 (signature)必須相同，拋出的異常類 範圍 小於等於父類，訪問修飾符 範圍 大於等於父類。
2. 如果父類方法訪問修飾符為 private/final/static 則子類就不能重寫該方法，但是被 static 修飾的方法能夠再次聲明。
3. 構造方法無法被重寫

在 Java 類中，所有的 private 方法都隱式地指定為 final 的（在 private 方法上加上final修飾符，其實是沒啥意義的）。新類可以直接複用基類的非 private 的屬性和方法，也就是說 private 方法是無法被繼承者修改的。



1. 補充返回值類型：如果返回類型是 void 或基本數據類型，則返回值重寫時不能修改。但是如果方法的返回值是引用類型，重寫時是可以返回該引用類型的子類的。


public class Mouse {
	void call() {
		System.out.println("吱吱喳");
	}
}

public class Pikachu extends Mouse {
	void pika() {
		System.out.println("皮卡~皮卡~");
	}
}

public class Main {
	public static void main(String[] args) {
		Pikachu pikachu = new Pikachu();	
		testMouse(pikachu);
	}

	static void testMouse(Mouse mouse) {
		if(mouse instanceof Pikachu) {		// instanceof 型別比較運算子
			((Pikachu) mouse).pika();
		} else {				// 是皮卡丘，則轉型並呼叫pika()，否則呼叫call()。這邊用generics的話就不用這樣寫了。
			mouse.call();
		}
	}
}
這是很有問題的程式，每擴充一種 子類別，高階模組 的 testMouse()方法，就被迫跟著改變。這就是聲名狼藉的 if-else 長鍊。
因為違反Liskov替代原則
何謂子類別(subclass)：子型別 必須可以 替換 (substitute) 他們的父型別。
正是因為 子型別的 可替換性，讓以基礎型別表達的模組得以 不需修改而加以擴充。
再見了，instanceof
再見了，冗餘的轉型
再見了，低能的 if-else
Override (覆寫) 除了能 重新定義 父類別方法，還能透過 super 關鍵字，以原先的方法為基礎，加以 擴充！

（Overload）：相同的模樣，擁有不同的行為，不要打@Override。運算子多載 +、- 號等等；方法多載，extends之後以相同函式名稱不同參數型別、數量。不同於C++，Java、C… 並不提供『自訂的運算子多載』
「編譯期」
在Java中方法簽章 (Method Signature) = 方法名稱 (method’s name) + 參數型別 (parameter types)
重載方法之間，若回傳型別不同，將使程式碼 難以維護、理解，若有新的意圖應取新的方法名稱。 ex: void → boolean 方法名稱相同、參數串列不同、回傳型不同
由於 多載函式 大多 目的一致，大多內建『 重複的程式碼 』之解法 — 提煉函式(在函式中呼叫另一個多載函式)，對未包含共同程式或邏輯的方法，可能並不適用。
this() 用於 在 建構元中 呼叫 其他建構元，且需為 首句敘述 (first statement)。super() 隱性在子建構式裡第一句。
多載不只會發身在自身類別，繼承/實作 的子類別同樣能多載父類別的方法！
Java 的 valueOf 函式，提供了多種多載方法，使我們得以用相同的方法名稱，執行不同資料型別的轉型操作

重構－重複的程式碼(Duplicated Code)使用 提煉函式：
public class Chef {
	void cook() {			// 點一份 牛排
		cook('A');
	}

	void cook(char meal) {		// 點一份 牛排 or 豬排
		cook(meal, 1);
	}

	void cook(char meal, int quantity) {	// 點很多份 牛排 or 豬排
		if (quantity < 1)
			return;

		switch (meal) {
			case 'A':
				System.out.println("準備 A 號餐: 牛排");		// 可以重構成System.out.println包住switch() {}，然後使用case 'A' -> 取代case 'A': (""); break;
				break;
			case 'B':
				System.out.println("準備 B 號餐: 豬排");
				break;
			default:						// 這可以試試看enum列舉，因為switch()接收的是int action導致執行時期檢查，用enum就可以改成接收Action action物件變成編譯時期檢查。
				System.out.println("食屎吧你");
				break;					// 如果沒有用break，會在匹配成功時當前case以下都執行，匹配不成功則執行default。
		}

		cook(meal, quantity - 1);	// 做好一份了，剩下 quantity - 1 份。遞迴呼叫
	}
}

public class Rectangle {
	int width;
	int height;
	int color;

	Rectangle() {
		this(500);				// Rectangle(width); 錯誤 (X) -- 得使用 this 關鍵字
	}

	Rectangle(int width) {
		this(width, (int) (width / 1.618));
	}

	Rectangle(int width, int height) {		// int area = width * height; 錯誤 (X) -- 利用「this」呼叫建構子，需為首句敘述
	this(width, height, 0x2196F3);
	}

	Rectangle(int width, int height, int color) {		// 主建構函式
		this.width = width;
		this.height = height;
		this.color = color;
	}
}

import javax.swing.*;
import java.awt.*;

public class Main {
	public static void main(String[] args) {
		Rectangle defaultRec = new Rectangle();
		showJFrame(defaultRec);
	}

	static JFrame showJFrame(Rectangle r) {
		int width = r.width;
		int height = r.height;
		Color color = new Color(r.color);

		// 簡易的 Swing 圖形化介面
		JFrame frame = new JFrame();
		frame.setSize(width, height);
		frame.setLocationRelativeTo(null);
		frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
		frame.getContentPane().setBackground(color);
		frame.setVisible(true);
		return frame;
	}
}

（Polymorphism）：主要將多型分為三類：特定（Ad-hoc）多型、參數（Parametric）多型與次型態（Subtype）多型。
Fish shark = new Shark();		// Fish 可以是interface、class、abstract class，但 Shark 只能是 class。

多態不能調用 "只在子類存在但在父類不存在" 的方法
如果子類重寫了父類的方法，真正執行的是子類覆蓋的方法，如果子類沒有覆蓋父類的方法，執行的是父類的方法

特定（Ad-hoc）多型：在許多程式中使用函式重載 (function overloading) 來實踐

特定多型優點是從使用者的角度來看：

如果函式可以套用不同型態的引數，稱為多型函式。
如果函式的參數型態彼此間沒有關聯，且函式根據不同引數型態而有不同實作版本或行為，這樣的函式稱為特定多型。
函式重載（Overload）是特定多型常見的形式，可以使用相同方法名稱，但根據引數型態決定實際呼叫的函式版本。
特定（Ad-hoc）這個字眼表示，開發者必須針對引數型態提供特定的函式實作。例如運用重載時，實際上必須為print(int data)、print(int[] array)、print(String str)撰寫三個函式定義，多型的外觀實際上是從使用者呼叫函式時的角度來看，從編譯器或直譯器角度的話，不同引數型態仍要有不同版本的函式實作。由於函式針對特定引數型態進行處理，程式容易受到型態增減需求而進行修改，要處理的型態增加，就要增加新的函式定義，型態一旦決定廢棄，對應的函式也得一併刪除。


特定多型就是針對型態不同而有特定實作：

如果對於特定引數型態，函式實作時會有實質差異，特定多型對開發者才會有益，除了不用為命名函式而苦惱，不同型態實作不同函式版本，程式邏輯也會比較清楚。
函式重載可以根據不同型態，也可以根據引數個數。
例如程式中會有串接陣列需求，也會有串接List需求，因而有了append(int[] array1, int[] array2)與append(List list1, List list2)兩個重載函式，由於資料結構不同，這兩個函式也就必須針對陣列與List而有特定實作。

在不支援「預設引數」的語言中，例如Java標準API中可看到如indexOf(String str)與indexOf(String str, int fromIndex)的重載函式，這是根據參數個數而有不同重載，但並不是指有兩個特定實作，實際上真正的特定實作只有indexOf(String str, int fromIndex)，indexOf(String str)只是在函式內部呼叫indexOf(str, 0)。如果Java有預設引數功能，就只需定義一個indexOf，例如indexOf(String str, int fromIndex = 0)。有些建構式（Constructor）會重載多個版本，內部使用this()指定預設引數呼叫真正的特定實作，也是同樣道理。


動態語言的特定多型實現：

特定多型的概念，對於變數帶有型態資訊的靜態語言來說較易實現，對於不要求變數型態的動態語言來說就複雜多了，通常得在執行時期針對引數型態決定呼叫哪個函式。
舉例來說，有些動態語言可以定義特定函式名稱來定義運算子行為，這是動態語言中較常見的特定多型。例如+運算子可用來展現1 + 1、[1, 2] + [3, 4]、"abc" + "xyz"等行為，如果運算元型態都相同則實作上較為單純，但不同的話就麻煩的多。以Ruby為例，要定義+的行為，函式必須是def +(that)，that實際型態未知，如果真要左運算元為A型態，右運算元可以是B、C型態，就得在+函式內部進行型態或行為的判斷，例如使用that.is_a?(B)或that.is_a?(C)判斷該進行哪個操作。
動態語言無法根據型態進行函式重載，通常也不提供根據參數個數的函式重載。如果語言提供預設引數或不定長度引數的功能（例如Ruby、Python），倒可以讓函式呼叫時看來像是有重載，從而實現特定多型的概念。JavaScript雖然沒有提供預設引數功能，但是JavaScript的函式不管實際定義的參數有幾個，呼叫時可傳入任意數量引數的特性，可讓呼叫外觀看來也像是有重載。無論是哪個作法，為了實現特定多型，都必須在函式內部根據實際傳入的引數型態、順序或個數，判斷應當進行哪些對應動作，讓程式邏輯變得複雜。
如果動態語言支援的字典（Dictionary）物件或關聯陣列（Associative array）具有簡潔且適當的語法，也常會用來作為選項物件（Option object）以實現特定多型，在不支援預設選項的語言中，也可在函式內部設定選項物件中未設定選項的預設值，好處是使用者呼叫時不用受到引數順序的限制，然而壞處是又增加了函式內部實作的複雜。
動態語言實現特定多型時往往綜合了以上提到的幾種方式。例如JavaScript程式庫jQuery中的\$函式就是個最佳實例，它是個具有多重角色的函式，jQuery程式庫經常使用執行時期判斷引數型態、個數、選項物件等方式來實現特定多型。對使用者而言，確實可以得到特定多型使用固定介面的好處，但缺點就是開發者仍得確定引數的型態或行為、順序、選項物件的鍵名稱等，此時說明清楚的API文件就非常重要。


特定多型用於實作具差異性場合：

特定多型因為必須針對特定型態而有特定實作，有人認為價值不大，事實上這個被認定價值不大的理由，反而就是特定多型存在的價值。就像Java中PrintStream的print函式，雖然要顯示整數與顯示陣列必須分別實作print(int data)與print(int[] array)，但就使用者來說，目的都是「把傳入的引數顯示出來」，如果有特定多型，確實可省去記憶函式名稱的細節，尤其有整合開發工具輔助時更為省事。如果特定多型的價值不大，動態語言就不用大費周章地要在API中封裝複雜判斷，以求在外觀上實現特定多型的概念。

真正讓一些人認為特定多型價值不大的原因，其實是將特定多型運用於實作無差異性的場合。
實例之一是像先前的show函式，其實應當使用Role作為SwordsMan與Magician父類別，定義兩者的共同行為，並以次型態多型來解決需求
void show(Role r) {
	out.printf("($s, $d)", r.getName(), r.getBlood());
}
另一不適當的實作也許像是：
String first(String[] strs) {
	return strs[0];
}

Integer first(Integer[] integers) {
	return integers[0];
}

實際上first函式的實作與型態無關，像這個例子也許用參數多型會比較適合：
<T> T first(T[] ts) {
	return ts[0];
}


參數（Parametric）多型：在程式設計中用泛型 (generics) 來實踐
<T> T first(T[] ts) {
	return ts[0];
}



次型態（Subtype）多型：使用繼承來實踐
void show(Role r) {
	out.printf("($s, $d)", r.getName(), r.getBlood());
}



（Stream）

var fileName = args[0];
var prefix = args[1];
var firstMatchedLine = "no matched line";
for(var line : Files.readAllLines(Paths.get(fileName))) {
	if(line.startsWith(prefix)) {
		firstMatchedLine = line;
		break;
	}
}
out.println(firstMatchedLine);
程式中使用到java.nio.file的Files & Paths類別，是NIO2標準類別，get()傳回Path instance，代表指定的路徑，readAllLines()讀取檔案全部內容，並以換行為依據，將每行內容收集在
List<String>後傳回，程式會找到第一個符合條件的行，然後離開迴圈。JDK8以後，這類的需求，建議改用以下來完成：
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;

public class LineStartsWith {
	public static void main(String[] args) throws IOException {
		var fileName = args[0];
		var prefix = args[1];
		var maybeMatched = Files.lines(Paths.get(fileName))
					.filter(line -> line.startsWith(prefix))
					.findFirst();
		System.out.println(maybeMatched.orElse("no matched line"));
	}
}
一眼可見最大差別是沒有使用for與if，並使用管線(Pipeline)操作風格，而效能也有差異，若讀取的檔案很大，第二個程式片段會比第一個有效率。
Files.lines()傳回java.util.stream.Stream實例，這例子來說就是Stream<String>，使用Stream.filter()會留下符合條件的元素，findFirst()嘗試取得留下的元素中第一個，可能沒有留下任何元素
，因此傳回Optional<String>實例。
效能差異：第一個程式Files.readAllLines()傳回List<String>實例，包括檔案中全部的文字行，若第一行符合後續就是多餘的讀取；第二個程式lines()、filter()不會馬上進行讀取、過濾，
而是在呼叫findFirst()時才驅動filter()執行，此時才要求lines()傳回的Stream進行第一行讀取，若第一行符合後續就不會再讀取。
惰性求值(Lazy evaluation)的效果，需要時findFirst()要求filter()而filter()才要求讀取下一行，你需要我再給的行為，就是Stream實例。
第一個程式，是取得List傳回的Iterator，搭配for迴圈進行外部迭代(External iteration)，第二個程式，是將迭代行為隱藏在lines()、filter()、findFirst()，稱為內部迭代(Internal iteration)，
因為內部迭代行為被隱藏也就有許多實現效率的可能。
Stream的頂層父介面AutoCloseable←java.util.stream.BaseStream的close()實作了close()←Stream、DoubleStream、IntStream、LongStream都繼承BaseStream。絕大多Stream不需要呼叫close()除了IO操作，建議IO搭配嘗試關閉資源(try-with-resource)語法。

List<Player> players = ...;
List<String> names = new ArrayList<>();
for(Player player : players) {
	if(player.getAge() > 15) {
		names.add(player.getName().toUpperCase());
	}
}
for(String name : names) {
	System.out.println(name);
}
JDK8後可改為以下風格：
import static java.lang.System.out;
import java.util.List;
import static java.util.stream.Collectors.toList;

public class PlayerDemo {
	public static void main(String[] args) {
		var players = List.of(
			new Player("Justin", 39),
			new Player("Monica", 36),
			new Player("Irene", 6)
		};
		Players.stream()
			.filter(player -> player.getAge() > 15)
			.map(Player::getName)
			.map(String::toUpperCase)
			.collect(toList())
			.forEach(out::println);
	}
}

class Player {
	private String name;
	private Integer age;

	public Player(String name, Integer age) {
		this.name= name;
		this.age=age;
	}

	public String getName() {
		return name;
	}

	public Integer getAge() {
		return age;
	}
}


（Optional的API增強）

若getNickName()會傳回Optional<String>：
var nickOptional = getNickName("Duke");
if(nickOptional.isPresent()) {
	var nickName = nickOpitonal.get();
	out.printf("Hello, %s%n, nickName);
}else {
	out.println("Hello,Guest");
}
可改為：
getNickName("Duke").ifPresentOrElse(
	nickName -> out.println("Hello, %s%n, nickName),
	() -> out.println("Hello, Guest")
};
許多地方採用Optional，就會開始考慮API銜接的問題，例如getNickName()、getDefaultName()都傳回Optional<String>，而你曾經定義過這類的方法：
public Optional(String> getDisplayName(String username);
	var nickOptional = getNickName(username);
	if(nickOptional.isPresent()) {
		return nickOptional;
	}else {
		return getDefaultName(username);
	}
}
像這類需求，可改寫為：
public Optional<String> getDisplayName(String username) {
	return getNickName(username).or(
		() -> getDefaultName(username)
	};
}
由於某些原因，你可能會使用一組名稱來呼叫getNickName()，例如：
public Stream<String> getAvailableNickNames(List<String> username) {
	return usernames.stream()
			.map(username -> getNickName(username))
			.filter(opt -> opt.isPresent())
			.map(opt -> opt.get());
}
JDK9後可以直接改用Optional.stream()並搭配Stream.flatMap()簡化程式撰寫，底下也用了方法參考讓程式更簡潔：
public Stream<String> getAvailableNickNames(List<String> usernames) {
	returne usernames.stream()
			.map(this::getNickName))
			.flatMap(Optional::Stream);
map(this::getNickName))傳回Stream<Optional<String>>、Stream<T>.flatMap()會從Stream<T>逐一取得內容的T，就上例而言就是從Stream<Optional<String>>取得Optional<String>，而
flatMap()接受的Lambda表示式必須傳回Stream<T>，就上例而言必須傳回Stream<Optional<String>>，而Optional<String>.stream()傳回Stream<Optional<String>>，而Optional.stream()
也做了isPresent()的檢查。

（Stream的API增強）

如果order有個getCustomer()傳回型態為Customer，你想在傳回的Customer實例上呼叫getEmailList()，以便取得聯絡用的郵件清單，然而getCustomer()可能傳回null，因此你也許會撰寫出以下：
var customer = order.getCustomer();
Stream<String> emails = customer == null
	? Stream.empty()
	: customer.getEmailList().stream();
因為你已經很熟悉Optional的運用了，看到null檢查，會想修改為以下版本：
Stream<String> emails =
	Optional.of(order.getCustomer())
		.map(cust -> cust.getEmailList().stream())
		.orElse(Stream.empty());
如果是＊JDK9以後的版本，可以使用Stream.ofNullable()進一步簡化程式：
Stream<String> emails =
	Stream.ofNullable(order.getCustomer())
		.flatMap(cust -> cust.getEmailList().stream());
Stream有個接受單一引數的版本of()，若傳入null會拋出NullPointerException，而Stream.ofNullable()若接受null，會傳回空的Stream(呼叫Stream.empty())，否則使用Stream.of()建立內含單一
元素的Stream實例，如此就不用透過Optional.ofNullable()來銜接API了。
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Exception）
Java 異常類層次結構圖概要：
				  Object
				　  ↑
				Throwable
		  　 ______＿＿＿＿↑　　↑＿_______________＿__________
		　 ｜						   ｜
		Exception				　　　		 Error
　　　  ＿＿＿____↑　    ↑__________				   ↑
　　　｜				｜				   ｜
Check Exceptions		Uncheck Exceptions				   ｜—StackOverFlowError
　　　↑				↑				   ｜—VirtualMachineError
　　　｜				｜				   ｜—OutOfMemoryError
　　　｜—IOException		｜—ArithmeticException
　　　｜—SQLException		｜—NullPointerException
　　　｜—ClassNotFoundException	｜—IndexOutOfBoundsException
					↑
					｜—ArrayIndexOutOfBoundsException
					｜—StringIndexOutOfBoundsException

Checked Exceptions：IOException
Un-Checked Exceptions：RuntimeException

java.lang.Throwable 定義了取得錯誤訊息、堆疊追蹤 (Stack Trace)等方法，它有兩個子類別：java.lang.Error、java.lang.Exception
Exception：能被程序本身處理(try-catch)。又可分為「受檢查異常」「不受檢查異常」。
Error：是無法處理的(只能盡量避免)。發生時，Java 虛擬機 一般會選擇線程終止。

受檢查異常：Java 代碼在編譯過程中，如果沒有被 catch / throw 處理的話，就沒辦法通過編譯。比如下面這段 IO 操作。
class Example {
	public static void main(String[] args) throws IOException {
		FileInputStream fis = null;
		fis = new FileInputStream("C:/myfile.txt");
		int k;

		while(( k = fis.read()) != -1) {
			System.out.print((char)k);
		}
		fis.close();
	}
}
除了 RuntimeException 及其子類以外，其它的 Exception 類及其子類都屬於受檢查異常。常見的有：IO 相關的異常、ClassNotFoundException、SQLException ...。
不受檢查異常：不處理也可以正常通過編譯。
RuntimeException 及其子類都統稱為此，例如：NullPointerException、NumberFormatException(字符串轉換為數字)、ArrayIndexOutOfBoundsException(數組越界)、ClassCastException(類型轉換錯誤)、ArithmeticException(算術錯誤)等。

Throwable 類常用方法
．public string getMessage()：返回異常發生時的簡要描述
．public string toString()：返回異常發生時的詳細信息
．public string getLocalizedMessage()：返回異常對象的本地化信息。使用 Throwable 的子類覆蓋這個方法，可以生成本地化信息。如果子類沒有覆蓋該方法，則該方法返回的信息與 getMessage() 返回的結果相同
．public void printStackTrace()：在控制台上打印 Throwable 對象封裝的異常信息

try-catch-finally
try：用於捕獲異常。其後可以接零或多個 catch 塊，如果沒有 catch 塊，則必須跟一個 finally 塊。
catch：用於處理 try 捕獲到的異常。
finally：無論是否捕獲或處理異常，finally 塊裡的語句都會被執行。當在 try 塊或 catch 塊中遇到 return 語句時，finally 語句塊將在方法返回之前被執行。

在以下 3 種特殊情況下，finally 塊不會被執行：
1. 在 try 或 finally 塊中用了 System.exit(int) 退出程序。但是，如果 System.exit(int) 在異常語句之後，finally 還是會被執行。
2. 程序所在的線程死亡
3. 關閉 CPU

注意：當 try、finally 都有 return 語句時，在方法返回之前，finally 語句的內容將被執行，並且 finally 語句的返回值將會覆蓋原始的返回值：
public class Test {
	public static int f(int value) {
		try {
			return value * value;
		{ finally {
			if (value == 2) {
				return 0;
			}
		}
	}
}
調用 f(2)，返回 0

使用 try-with-resources 代替 try-catch-finally
1. 適用範圍 (資源的定義)：任何實現 java.lang.AutoCloseable 或者 java.io.Closeable 的對象
2. 關閉資源 和 finally塊 的執行順序：在 try-with-resources 語句中，任何 catch 或 finally 塊在聲明的資源關閉後運行
Effective Java 中指出：
面對必須要關閉的資源，優先使用 try-with-resources 而不是 try-finally。
隨之產生的代碼更簡短，更清晰，產生的異常對我們也更有用。try-with-resources 語句讓我們更容易編寫必須要關閉的資源的代碼，若採用 try-finally 則幾乎做不到這點。

Java 中類似於 InputStream、OutputStream、Scanner、PrintWriter等的資源都需要我們調用 close() 來手動關閉，一般情況下我們都是通過 try-catch-finally 語句實現這個需求：
Scanner scanner = null;
try {
	scanner = new Scanner(new File("D://read.txt"));
	while (scanner.hasNext()) {
		System.out.println(scanner.nextLine());
	}
} catch (FileNotFoundException e) {
	e.printStackTrace();
} finally {
	if (scanner != null) {
		scanner.close();
	}
}
使用 Java 7 後的 try-with-resources 語句：
try (Scanner scanner = new Scanner(new File("test.txt"))) {
	while (scanner.hasNext()) {
		System.out.println(scanner.nextLine());
	}
} catch (FileNotFoundException fnfe) {
	fnfe.printStackTrace();
}

通過使用分號分隔，可以在 try-with-resources 塊中聲明多個資源。
try (BufferedInputStream bin = new BufferedInputStream(new FileInputStream(new File("text.txt")));
	BufferedOutputStream bout = new BufferedOutputStream(new FileOutputStream(new File("out.txt")))) {
	int b;
	while ((b = bin.read()) != -1) {
		bout.write(b);
	}
} catch (IOException e) {
	e.printStackTrace();
}

		
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Collection && Map）
HashMap、HashTable 都實現了 Map 接口
Java 5 以上使用 ConcurrentHashMap 代替 HashTable，擴展性更好
主要區別有 線程安全性、同步(synchronization)、速度
1. HashMap 是非 synchronized、可接受 null；ConcurrentHashMap 是 synchronized、不接受 null。
2. 所以沒有正確同步，多個線程不能共享 HashMap；而多個線程可以共享一個 ConcurrentHashMap。
3. HashMap 的迭代器(Iterator)是 fail-fast 迭代器，而 HashTable 的 enumerator 迭代器不是 fail-fast。所以當有其他線程改變 HashMap 的結構，拋出 ConcurrentModificationException，但迭代器本身的 remove() 則不會拋出此異常。但這並不是一個一定發生的行為，要看 JVM。
4. 由於 ConcurrentHashMap 是線程安全的也是 synchronized，所以單線程環境下速度比 HashMap 慢。如果不需要同步只需要單線程，那麼使用 HashMap 性能較好。
5. HashMap 不能保證隨著時間推移 Map 中的元素次序是不變的

import java.util.Arrays;

public class ArrayList {
	private Object[] elems;
	private int next;

	public ArrayList(int capacity) {
		elems = new Object[capacity];
	}
	public ArrayList() {
		this(16);
	}
	public void add(Object o) {
		if (next == elems.length) {
			elems=Arrays.copyof(elems, elems.length * 2);
		}
		elems [next ++] = o;
	}
	public Object get (int index) {
		return elems[index];
	}
	public int size() {
		return next;
	}
}
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（輸入輸出）

重新指定
System.setIn(InputStream)
System.setOut(PrintStream)
System.setErr(PrintStream)
裝飾器(Decorator)提供高階操作，像Scanner也是一個包裹器，操作Scanner相關方法，Scanner代為操作System.in，並轉換為想要的資料型態。
	        FileInputStream
	        ByteArrayInputStream	
InputStream←  FilterInputStream	BufferedInputStream
	 			DataInputStream
	        ObjectOutputStream	
System.in
_____________________________________________________________________________

	        FileOutputStream
	        ByteArrayOuptputStream	
				BufferedOutputStream
OutputStream←FilterOutputStream	DataOutputStream
				PrintStream	System.out
						System.err
	        ObjectOutputStream

（匿名類別語法）   省略了類別名稱 ?，JDK9：左邊已經指定泛型實際型態，右邊可以省略型態宣告。
＊JDK10：var
Lambda+編譯器型態推斷，Lambda省略介面型態+方法名稱。參數列 -> 方法本體，單參數又無需寫參數型態時，()可以省略


public interface Comparator<T>{
	int compare(T o1, T o2);
}

Comparator<string> byLength = new Comparator<string>(){
	public int compare(String name1,String name2){
		return name1.length() - name2.length();
	}
}

Comparator<String> byLength = new Comparator<>(){
	public int compare(String name1,String name2){
		return name1.length() - name2.length();
	}
}

Var byLength = new Comparator<String>(){
	public int compare(String name1,String name2){
		return name1.length() -name2.length();
	}
}

Comparator<String> byLength = (name1,name2) -> name1.length() - name2.length();

String[] names = {"Justin", "caterpillar", "Bush"};
Arrays.sort(names, (name1, name2) -> name1.length() - name2.length());
System.out.println(Arrays.toString(names));



___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Thread && Runnable && 並行API）
死鎖：通常指兩個或以上進程由於競爭資源或者彼此通訊而造成的一種阻塞現象，若無外力干涉，將無法繼續執行下去，但他是靜態問題，進程被卡，CPU 的佔有率也是 0，會被調用出，相對活鎖好發現與分析。
活鎖：指事務 A 可以使用資源，但他在檢測到其他事務也將執行時會讓其他事務先使用此資源，事務 B 可以使用此資源，但是他也檢測到其他事務將執行所以也讓行，於是兩者都無法使用此資源。
飢餓：無法獲取到所需要的資源。


阻塞、非阻塞(無障礙、無鎖、無等待)：通常形容多線程之間的相互影響。
比如一個線程佔用了臨界區資源，其他線程想得到這個資源就必須等待，等待會導致線程掛起，就是阻塞。非阻塞就是允許多個線程同時進入這個臨界區，不能保證共享數據的安全。

阻塞：悲觀策略

非阻塞：
無障礙
自由出入臨界區
無競爭時，有限步內完成操作
有競爭時，回滾數據(寬進嚴出)
樂觀策略
所有線程相當於在拿一個系統當前的快照，直到快照是有效為止。



無鎖(是無障礙的)
保證有一個線程可以勝出，所有線程都能順利執行，但是進入屬於優先級低的可能導致飢餓的。



無等待(基於無鎖)
所有線程都必須在有限步內完成，自然是無飢餓的。
無等待是併行的最高級別，能使系統達到最優狀態。

典型案例：
如果只有讀沒有寫線程，則必然是無等待的。
如果既有讀也有寫線程，而每個寫線程之前，都把數據拷貝一份副本，然後修改這個副本，而不是修改原始數據，因為修改副本則沒有衝突，這修改過程也是無等待的。
最後需要做同步的只是將寫完的數據覆蓋原始數據。

但無等待要求比較高實作比較困難，無鎖使用比較廣泛。



Runnable←…Thread
implements Runnable	 較有彈性，因為類別還能繼承其他類別
extends Thread	直接繼承比較快，或是為了利用 Thread 定義的方法，才會繼承 Thread 來實作


var someThread = new Thread() {			匿名類別
	public void run(){
		//方法實作內容...
	}
};

var someThread = new Thread(() -> {			Lambda
	//方法實作內容...
});

import java.net.URL;
import java.io.*;

public class Download {
	public static void main (String[] args) throws Exception {
		URL[] urls = {
			new URL("https://openhome.cc/Gossip/Encoding/"),
			new URL("https://openhome.cc/Gossip/Scala/"),
			new URL("https://openhome.cc/Gossip/JavaScript/"),
			new URL("https://openhome.cc/Gossip/Python/")
		};
		String[] fileNames = {
			"Encoding.html",
			"Scala.html",
			"JavaScript.html",
			"Python.html"
		};
		for (var i = 0 ; i< urls.length; i++) {
			dump(urls[i].openStream(), new FileOutputStream(fileNames[i]));
		}
	}

	static void dump (InputStream src, OutputStream dest )
						throws IOException {
		try(src; dest) {
			var data = new byte[1024];
			var length = 0 ;
			while((length = src.read(data)) != -1) {	// 代表有讀取到
				dest.write(data, 0, length);
			}
		}
	}
}

有使用多執行緒↓

		for (var i  = 0; i < urls.length; i++) {
			var index = i;
			new Thread( () -> {
				try {
					dump(urls[index].openStream(), new FileOutputStream(fimeNames[index]));
				} catch{ IOException ex) {
					throw new RuntimeException(ex);
				}
			}).start();
		}
	}
	static void dump( InputStream src , OutputStream dest)
						throws IOException {
		...同前一個範例，故略...
	}
}


Thread.join(ms)	//限於時間內完成
Thread.currentThread().getThreadGroup().getName();		//取得目前執行緒所屬執行緒群組名稱

jar, javascript, web java, maven, 

var group1 = new ThreadGroup("group1");
var group2 = new ThreadGroup("group2");
var thread1 = new Thread(group1, "group1's member");
var thread2 = new Thread(group2, "group2's member");

（ThreadGroup）
1.interrupt()		//中斷群組中的執行緒
2.setMaxPriority()	//設定群組中執行緒最大的優先權
3.enumerate()	//一次取得群組中全部的執行緒，要傳入Thread陣列，每個陣列索引會參考至群組中的各個執行緒物件

var threads = new Thread[threadGroup1.activeCount()];
threadGroup1.enumerate(threads);

4.activeCount()	//取得群組的執行緒數量
5.uncaughtException()	//JDK5以後，如果ThreadGroup中的執行緒發生例外時，uncaughtException()方法處理順序是：1.有父ThreadGroup就會呼叫父ThreadGroup的uncaughtException()方法。2.否則，看看是否使用Thread.setDefaultUncaughtExcetionHandler()方法設定Thread.UncaughtExceptionHandler實例，有就呼叫其uncaughtException()方法，。3.否則看例外是否為ThreadDeath實例，若「是」甚麼都不做，若「否」則呼叫例外的PrintStackTrace()。

未捕捉例外會由1.執行緒實例setUncaughtExceptionHandler()設定的Thread.UncaughtExceptionHandler實例處理，之後是2.執行緒的ThreadGroup.uncaughtException()，再來是3.預設Thread.UncaughtExceptionHandler。

如果必要定義ThreadGroup中執行緒的例外處理行為可以重新定義此方法：

public class ThreadGroupDemo {
	public static void main(String[] args) {
		var group = new ThreadGroup("group") {
			@Override
			public void uncaughtException(Thread thread, Throwable throwable) {
				System.out.printf("%s: %s%n", thread.getName(), throwable.getMessage());
			}
		};
		var thread = new Thread(group,  () -> {
			throw new RuntimeException("測試例外");
		});
		thread.start();
	}
}

>>Thread-0：測試例外

因此對於執行緒本身未捕捉的例外，可以自行指定處理方式了：

public class ThreadGroupDemo2 {
	public static void main(String[] args) {
		var group = new ThreadGroup ("group");
		var thread1 = new Thread(group, () -> {
			throw new RuntimeException("thread1 測試例外");
		});
		thread1.setUncaughtExceptionHandler((thread, throwable) -> {
			System.out.printf("%s: %s%n", thread.getName(), throwable.getMessage());
		});
		var thread2 = new Thread(group, () -> {
			throw ew RuntimeException("thread2 測試例外");
		});

		thread1.start();
		thread2.start();
	}
}

（ArrayList） 並非執行緒安全(Thread-safe)的類別
像是在thread1,thread2多執行緒存取同一物件的資源時引發的「競速情況(Race condition)」
使用synchronized關鍵字
public synchronized void add(Object o) {
	if (next == elems.length) {
		elems = Arrays.copyOf(elems, elems.length * 2);
	}
	elems[next++] = o;
}

（Collection && Map）都未考慮執行緒安全，可以使用 Collections 的 synchronizedCollection(), synchronizedList(), synchronizedSet(), synchronizedMap()等方法
var list = Collections.synchronizedList( new ArrayList<String>());
Map m = Collections.synchronizedMap(hashMap);

class Variable1 {
	volatile static int i = 0, j = 0;
	static void one() {
		i++;
		j++;
	}
	static void two() {
		System.out.printf("i = %d, j = %d%n" , i , j );
	}
}

public class Variable1Test {
	public static void main (String[] args) {
		var thread1= new Thread( () -> {
			while (true) {
				Variable1.one();
			}
		});
		var thread2 = new Thread () -> {
			while(true) {
				Variable1.two() ;
		});
		
		thread1.start();
		thread2.start();
	}
}

（synchronized）要求達到被標示區塊的「互斥性(Mutual exclusion) 與 可見性(Visibility)」

volatile 的變數，不允許執行緒快取，保證變數的可見性，只能在共享記憶體存取。
volatile 修飾符告訴編譯器被 volatile 修飾的變量可以被程序的其他部份改變。在 multi threading 有時兩個或更多地線程共享一個相同的實例變量。
考慮效率問題，每個線程可以保存該共享必量的私有拷貝。實際的變量副本在不同的時候更新，如當進入 synchronized 方法時。

介紹：因為異步線程可以訪問字段，所以有些優化操作是一定不能作用在字段上的。
volatile 有時可以代替 synchronized。但是 volatile 沒辦法保證對變量操作的原子性。volatile 能在一定程度上保證有序性

共享變量（類的成員變量、靜態成員變量）被 volatile 後，就具備了兩層語義：

1）內存可見性：保證了不同線程對這個變量進行操作時的可見性，即一個線程修改了某個變量的值，這新值對其他線程是立即可見的。

2）禁止進行指令重排序（為了減少內存操作速度遠低於 CPU 運行速度帶來的 CPU 空置影響，JVM 會按照自己的一些規則將程序編寫順序打亂）。

使用場景：
volatile 在某些情況下性能要優於 synchronized，volatile 關鍵字是無法替代 synchronized，因為 volatile 無法保證操作的原子性。

在某些特定場景，volatile 相當於一個輕量級的 synchronized，因為不會引起線程的上下文切換
但是使用 volatile 必須滿足兩個條件：
1）對變量的寫操作不依賴當前值，如多線程下執行 i++，是無法通過 volatile 保證結果準確性的。
2）該變量沒有包含在具有其他變量的不變式中

可以被寫入 volatile 變量的這些有效值獨立於任何程序的狀態，包括變量的當前狀態。

正確使用 volatile
public class Some implements Runnable {
	private volatile boolean isContinue = true ;
	...
	public void stop() {
		isContinue = false;
	}
	public void run() {
		while (isContinue) ;
			...
		}
	}
}

（Object 定義的方法）
java.lang.Object是所有類別的頂層父類別，這代表了Object上定義的方法，所有物件都繼承下來了，只要不是被定義為final的方法，都可以重新定義。
主要提供了以下 11 個方法：
public final native Class<?> getClass()	// native method，用於返回當前運行時對象的 Class 對象，使用 final 關鍵字，故不允許子類重寫。
public native int hashCode()		// native method，用於返回對象的哈希碼，主要使用在哈希表中，比如 JDK 中的 HashMap。
public boolean equals(Object obj)	// 用於比較 2 個對象的內存地址是否相等，String 類對該方法進行了重寫用戶比較字符串的值是否相等。
protected native Object clone() throws CloneNotSupportedException	// native method，用於創建並返回當前對象的一份拷貝。一般情況下，對於任何對象 x，表達式 x.clone() != x 為true，x.clone().getClass() == x.getClass() 為true。Object 本身沒有實現 Cloneable 接口，所以不重寫 clone() 並且進行調用的話會發生 CloneNotSupportedException 異常。
public String toString()		// 返回類的名字@實例的哈希碼的 16 進制的字符串。建議 Object 所有的子類都重寫這個方法。
public final native void notify()		// native method，並且不能重寫。喚醒一個在此對象監視器上等待的線程(監視器相當於就是鎖的概念)。如果有多個線程在等待只會任意喚醒一個。
public final native void notifyAll()	// native method，並且不能重寫。跟 notify 一樣，唯一的區別就是會喚醒在此對象監視器上等待的所有線程，而不是一個線程。
public final native void wait(long timeout) throws InterruptedException	// native method，並且不能重寫。暫停線程的執行。注意: sleep() 沒有釋放鎖，而 wait() 釋放了鎖。timeout 是等待時間。
public final void wait(long timeout, int nanos) thorws InterruptedException	// 多了 nanos 參數，這個參數表示額外時間(以毫微秒為單位，範圍是 0-999,999)。所以超時的時間還需要加上 nanos 毫秒。
public final void wait() throws InterruptedException			// 跟之前的 2 個 wait() 一樣，只不過該方法一直等待，沒有超時時間這個概念。
protected void finalize() thorws Throwable {}			// 實例被垃圾回收器回收的時候觸發的操作。



其實 toString() 是 Object 上定義的方法，Objec t的 toString() 預設定義為：
public String toString() {
	return getClass().getName() + "@" + Integer.toHexString(hashcode());
}
許多方法若傳入物件，預設都會呼叫toString，例如System.out.print()等方法就會呼叫toString()以取得字串描述來顯示，所以 protected 成員 的這個程式片段：
SwordMain swordMan = new SwordMan();
System.out.println(swordMan.toString());
實際上只要：
System.out.println(swordMan);

equals()方法是Object類別就有定義的方法，其程式碼實作是：
public boolean equals(Object obj) {
	return (this == obj);
}
如果沒有重新定義equals()，使用equals()方法時，作用等同於==，所以要比較實質相等性，必須自行重新定義。一個簡單的例子是比較，兩個 Cat 物件是否實際上代表同一隻 Cat 的資料：
public class Cat {
	...
	public boolean equals(Object other) {
		if (this == other) {
			return true;
		}

		if (other instanceof Cat) {						// instanceof運算子，它可以用來判斷物件是否由某個類別建構，左運算元是物件，右運算元是類別使用instanceof時													// ，編譯器還會來幫點忙，會檢查左運算元型態是否在右運算元型態的繼承架構中（或介面實作架構中）。執行時期，並非												// 只有左運算元物件為右運算元類別直接實例化才傳回true，只要左運算元型態是右運算元型態的子類型，instanceof也是傳回true。
			Cat cat = (Cat) other;
			return getName().equals(cat.getName()) && getBirthday().equals(cat.getBirthday());		// 定義如果名稱與生日，表示兩個物件實質上相等
		}
		return false;
	}
}
不過，這邊的equals()並不安全，如果getName()或getBirthday()傳回null的話，那麼就會噴出NullPointerException了，自行加些檢查是否為null的程式碼是可以，不過知道有Objects.equals()可以協助（除了equals()外，Objects上還有一些不錯用的方法，請參考API文件），為什麼不拿來用？
import static java.util.Objects.equals;

public class Cat {
	...
	public boolean equals(Object other) {
		if (this == other) {
			return true;
		}

		if (other instanceof Cat) {
			Cat cat = (Cat) other;
			return equals(getName(), cat.getName()) && equals(getBirthday(), cat.getBirthday());
		}
		return false;
	}
}

來看一下 Objects 的 equals() 原始碼，比較能安心使用：
public static boolean euqals(Object a, Object b) {
	retrun (a == b) || (a != null && a.equals(b));
}

wait()
notify()
notifyAll()
這三個方法控制執行緒釋放物件的內部鎖，或者通知執行緒參與內部鎖的競爭

puvlic class Producer implements Runnable {
	private Clerk clerk;
	
	public Producer(Clerk clerk) {
		this.clerk = clerk;
	}

	public void run() {
		System.out.println("生產者開始生產整數......");
		for (var product = 1 , product <= 10 , product++) {
			try{clerk.setProduct(product);
			} catch(InterruptedException (ex) {
				throw new RuntimeException (ex);
			}
		}
	}
}




（java.util.concurrent.locks 套件）提供Lock、ReadWriteLock、Condition介面以及相關實作類別，提供類似 synchronized、wait()、notify、notifyAll()的作用，及更多高階功能。
Lock 介面主要實作類別之一 ReentrantLock，可達到 synchronized 作用，也提供額外功能。
Lock 介面定義了 lock(), unlock(), tryLock()
tryLock() 能取得鎖定true, 否則false不會阻斷。

看看如何使用 ReentrantLock。
import java.util.Arrays;
import java.util.concurrent.locks.*;

public class ArrayList<E> {
	private Lock lock = new ReentrantLock();
	private Object[] elems;
	private int next;

	public Arraylist (int capacity) {
		elems = new Object[capacity];
	}

	public ArrayList() {
		this(16);
	}

	public void add (E elem) {
		lock.lock();
		try {
			if ( next == elems.length) {
				elems = Arrays.copyOf(elems, elems.length * 2);
			}
		}finally {
			lock.unlock();
		}
	}

	public E get(int index) {
		lock.lock();
		try {
			return (E) elems[index];
		} finally {
			lock.unlock();
		}
	}
	
	public int size() {
		lock.lock();
		try {
			return next ;
		} finally {
			lock.unlock();
		}
	}
}

使用 tryLock() 解決死結問題。
import java.util.concurrent.locks.*;

class Resource {
	private ReentrantLock lock = new ReentrantLock();
	private String name;

	Resource(String name) {
		this.name=name;
	
}
	
	void cooperate(Resource res) {
		while (true) {
			try {
				if(lockMeAnd(res)) {							//取得目前與傳入的Resource之Lock鎖定
					System.out.printf("%s  整合 %s 的資源%n", this.name, res.name);	//如果兩個Resource的Lock都取得鎖定，才執行資源整合
					break;							//資源整合成功，離開迴圈
				}
			}finally {
				unlLockMeAnd(res) ;							//解除目前與傳入的Resource之Lock鎖定
			}
		}
	}
	
	private boolean lockMeAnd(Resource res) {
		return this.lock.tryLock() && res.lock.ltryLock();
	}
	
	private void unLockMeAnd(Resource res) {
		if(this.lock.isHeldByCurrentThread()) {
			this.lcok.unlock();
		}
		if(res.lock.isHeldByCurrentThread()) {
			res.lockunlock();
		}
	}
}

public class NoDeadLockDemo {
	public static void main(String [] args) {
		var res1 = new Resource("resource1") ;
		vra res2 = new Resource("resource2") ;

		var thread1 = new Thread ( () - > {
			for (var i = 0; i <10 ; i++) {
				res1.cooperate(res2);
			}
		}) ;
		var thread2 = new Thread( () - > {
			for(var i = 0; i<10; i ++) {
				res2.cooperate(res1);
			}
		});

		thread1.start();
		thread2.start();
	}
}

lock.writeLock().lock()
lock.writeLock().unlock()
lock.readLock().lock()
lock.readLock0.unlock()

Lock…ReentrantReadWriteLock.ReadLock
       …ReentrantReadWriteLock.WriteLock
ReadWriteLock 介面定義了讀取鎖定與寫入鎖定的行為，可以使用 readLock()、writeLock()   return Lock 實作物件
主要實作類別ReentrantReadWriteLock，readLock() return ReentrantReadWriteLock.ReadLock物件
				writeLock() return ReentrantReadWriteLock.WriteLock物件

StampedLock lock = new stampedLock;
	var stamp lock.writeLock();
		lock.unlockWrite(stamp);
ReadWriteLock 在沒有讀取寫入鎖定才可以取得寫入鎖定，可用於實現「悲觀讀取(Pessimistic Reading)」，thread 讀取時經常有 other thread 有寫入需求，為維持資料一致。

如果讀取 thread 很多，寫入 thread 甚少，使用 ReadWriteLock 可能使得寫入 thread 遭受飢餓(Starvation)問題，寫入 thread 遲遲無法競爭到內部鎖，而一直處於等待。

＊JKD8 新增了 StampedLock 類別，可支援「樂觀讀取(Optimistic Reading)」實作，若讀取 thread 很多寫入 thread 甚少，你可以樂觀地認為，寫入與讀取同時發生的機會甚少，程式可以查看資料讀取之後，是否遭到寫入 thread 的變更，再採取後續的措施(重新讀取變更後的資料，或者是拋出例外)。

由於 FutureTask 也實作了 Runnable 介面，可以指定給 Thread 建構之用。
FutureCallableDemo

import java.util.concurrent.*;
import static java.lang.System.*;

public class FutureCallableDemo {
	static long fibonacci( long n ) {
		if ( n<=1 ) {
			return n;
		}
		return fibonacci(n-1) + fibonacci(n-2);
	}

	public static void main (String [] args) throws Exception {
		var the30thFibFuture= new FutureTask<long>( () - > fibonacci(30));
		out.println("老闆，我要第30個費式數，待會來拿...");
	
		new Thread(the30thFibFuture).start();
		while(!the30thFibFuture.isDone()) {
			out.println("忙別的事去...");
		}

		out.printf("第30個費式數：%d%n", the30thFibFuture.get());
	}
}

FutureCallableDemo2

import java.util.concurrent.*;
import static java.lang.System.*;

public class FutureCallableDemo2 {
	static long fibonacci (long n) {
		if(n <=1) {
			return n;
		}
		return fibonacci(n-1) + fabonacci((n-2);
	}
	public static void main(String[] args) throws Exception {
		var service = Executors.newCachedThreadPool();
		ourt.println("老闆，我要第30個費式數，待會來拿...");

		var the30thFibFuture = service.submit( () - > fibonacci(30));
		while (!the30theFibFuture.isDone()) {
			out.println("忙別的事去...");
		}

		out.printf("第30個費式數：%d%n", the30thFibFuture.get());
	}
}

（線程池）
				New
				Runnable
		Thread Life	Running
				Blocked
				Terminated
							corePoolSize
							maximumPoolSize
							keepAliveTime
						參數	workQueue
							threadFactory(線程工廠)
							handler(拒絕策略)
ThreadPool	線程池封裝 - ThreadPoolExecutor			HashSet<Worker> workers
								// 存儲 Worker

						容器	BlockingQueue<Runnable> workQueue
							// 緩衝任務(Runnable)


					newFixedThreadPool		nThreads - 計算密集型任務
					newSingleThreadExecutor	1 - 串行執行的任務
		ExecutorService		newCachedThreadPool	Integer.MAX_VALUE - IO密集型任務
					newScheduledThreadPool	Integer.MAX_VALUE - 定時任務、周期任務
<<interface>>
    Executor
       ↑
<<interface>>←………………………………AbstractExecutorService
ExecutorService				     ↑
       ↑
<<interface>>		ThreadPoolExecutor		ForkJoinPool
ScheduledExecutorService		↑
　   ↑
　　︴……………………ScheduledThreadPoolExecutor


<<interface>>	<<interface>>			<<interface>>
   Runnable	      Future				     Callable
	↖	↗	↖	　　　↖
	<<interface>>	<<interface>>	………﹨
               RunnableFuture        ScheduledFuture		ForkJoinTask
	        ↑				                       ↑
	         ︴			 		       ｜			
	  FutureTask		           RecursiveAction	 RecursiveTask


（線程的生命周期）

	New

start()	↓
			sleep done,
			I/O complate,
			lock available,
			resume(),
			notify(), notifyAll()

	Runnable	←－－－－－－－－－－－－－－－－－
						  ｜
	↓					Blocked
						 ↑
	Running	－－－－－－－－－－－－－－－－－｜
			sleep(),
			block on I/O,
			wait for lock,
			suspend(),
			wait()
run(),	↓
exits,
stop()
	Terminated


（ThreadPoolExecutor）
public class ThreadPoolExecutor extends AbstractExecutorService {
/**
* The main pool control state, ctl, is an atomic integer packing
* two conceptual fields
*   workerCount, indicating the effective number of threads
*   runState,    indicating whether running, shutting down etc
*
* The runState provides the main lifecycle control, taking on values:
*
*   RUNNING:  Accept new tasks and process queued tasks
*   SHUTDOWN: Don't accept new tasks, but process queued tasks
*   STOP:     Don't accept new tasks, don't process queued tasks,
*             and interrupt in-progress tasks
*   TIDYING:  All tasks have terminated, workerCount is zero,
*             the thread transitioning to state TIDYING
*             will run the terminated() hook method
*   TERMINATED: terminated() has completed


    // Android-added: @ReachabilitySensitive
@ReachabilitySensitive
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 << COUNT_BITS) - 1;
// runState is stored in the high-order bits
private static final int RUNNING    = -1 << COUNT_BITS;
private static final int SHUTDOWN   =  0 << COUNT_BITS;
private static final int STOP       =  1 << COUNT_BITS;
private static final int TIDYING    =  2 << COUNT_BITS;
private static final int TERMINATED =  3 << COUNT_BITS;
// Packing and unpacking ctl
private static int runStateOf(int c)     { return c & ~CAPACITY; }
private static int workerCountOf(int c)  { return c & CAPACITY; }
private static int ctlOf(int rs, int wc) { return rs | wc; }

線程池用一個32位的 int 來同時保存 runState 和 workerCount，其中高3位（第31到29位）是 runState，其餘 29 位是 workerCount（大約 500 million）。

（Construtor）
public ThreadPoolExecutor(int corePoolSize,
int maximumPoolSize,
long keepAliveTime,
TimeUnit unit,
BlockingQueue<Runnable> workQueue,
ThreadFactory threadFactory,
RejectedExecutionHandler handler) {
if (corePoolSize < 0 ||
maximumPoolSize <= 0 ||
maximumPoolSize < corePoolSize ||
keepAliveTime < 0)
throw new IllegalArgumentException();
if (workQueue == null || threadFactory == null || handler == null)
throw new NullPointerException();
this.corePoolSize = corePoolSize;
this.maximumPoolSize = maximumPoolSize;
this.workQueue = workQueue;
this.keepAliveTime = unit.toNanos(keepAliveTime);
this.threadFactory = threadFactory;
this.handler = handler;
}

（Parameter）
corePoolSize
核心線程數，好比班幹部的人數。

maximumPoolSize
最大線程數，好比教室裡的座位數。
當提交任務數超過了這個最大值，線程還有拒絕策略——RejectExecutionHandler，做不動了嘛。

keepAliveTime
除核心線程外的空閒線程保持存活時間。
當線程池裡線程數超過corePoolSize數量了，keepAliveTime時間到，就把空閒線程關了，不然也閒置了呀，節省能量嘛。

workQueue
通過workQueue，線程池實現了阻塞功能。
當線程池中的線程數超過它的corePoolSize的時候，線程會進入阻塞隊列進行阻塞等待。

threadFactory
創建線程的工廠。
所有的線程都通過這個Factory創建（通過addWorker方法）。

handler
線程池的飽和策略。

（四種策略）
AbortPolicy：直接拋出異常，默認策略；
CallerRunsPolicy：用調用者所在的線程來執行任務；
DiscardOldestPolicy：丟棄阻塞隊列中靠最前的任務，並執行當前任務；
DiscardPolicy：直接丟棄任務。


更多被調用的構造方法：

public ThreadPoolExecutor(int corePoolSize,
int maximumPoolSize,
long keepAliveTime,
TimeUnit unit,
BlockingQueue<Runnable> workQueue,
RejectedExecutionHandler handler) {
this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
Executors.defaultThreadFactory(), handler);
}

（排隊策略）
SynchronousQueue
直接提交。直接提交任務給線程，而不是保存它們。

LinkedBlockingQueue
無界隊列。
當核心線程都在忙的時候，用一個無界隊列存放提交的任務。
線程數不會超過核心線程數，maximumPoolSize設置也無效。

ArrayBlockingQueue
有界隊列。
防止資源被消耗完，隊列也是有上限的。


（Executors）
Executors.defaultThreadFactory()是Executors靜態工廠裡默認的threadFactory。


Worker —— 工作線程
線程池創建線程時，會將線程封裝成工作線程 Worker，就是在線程池裡幹活的人。

private final class Worker
extends AbstractQueuedSynchronizer
implements Runnable

既實現了 Runnable，又繼承了 AbstractQueuedSynchronizer（AQS），所以其既是一個可執行的任務，又可以達到鎖的效果。

Worker 和 Task 的區別：
Worker 是線程池中的線程，而 Task 雖然是 runnable，但是並沒有真正執行，只是被 Worker 調用了 run 方法。

/**
* Creates with given first task and thread from ThreadFactory.
* @param firstTask the first task (null if none)
*/
Worker(Runnable firstTask) {
setState(-1);	// inhibit interrupts until runWorker
this.firstTask = firstTask;
this.thread = getThreadFactory().newThread(this);
}


WorkQueue				線程池

Task		  　pull			核心線程
		(阻塞獲取)		(corePoolSize)
Task	2			1	Worker	Worker	Worker
					Worker

		execute()		3	Worker	Worker
UI Thread

		　　4			最大線程池
	RejectedExecutionHandler		(maximumPoolSize)


注意點：

線程池裡有很多 Worker，核心的成員數就是 corePoolSize，池子裡最多能容納的 Worker 數是 maximumPoolSize；
workQueue 是等待中的任務隊列。
默認 corePoolSize 之內的線程是不會被回收的。


（看源碼）
execute(Runnable command)
public void execute(Runnable command) {
if (command == null)
throw new NullPointerException();
/*
* Proceed in 3 steps:
*
* 1. If fewer than corePoolSize threads are running, try to
* start a new thread with the given command as its first
* task.  The call to addWorker atomically checks runState and
* workerCount, and so prevents false alarms that would add
* threads when it shouldn't, by returning false.
*
* 如果當前正在運行的線程數 < corePoolSize，嘗試用給到的command來啟動一個新線程作為第一個任務。
* 調用addWorker方法，檢查runState和workerCount，
* 並且如果增加線程的話，能防止產生錯誤警報，如果不能增加線程，則返回false。
* 2. If a task can be successfully queued, then we still need
* to double-check whether we should have added a thread
* (because existing ones died since last checking) or that
* the pool shut down since entry into this method. So we
* recheck state and if necessary roll back the enqueuing if
* stopped, or start a new thread if there are none.
*
* 如果一個任務被成功地加到隊列裡，仍然需要雙重檢驗來確認是否需要新建一個線程
*（因為可能在上一次檢查後，已經存在的線程已經died）或者進入這個方法後，線程池已經被關閉了。
* 所以我們需要再次檢查state，如果線程池停止了需要回滾入隊列，如果池中沒有線程了，新建一個線程。
* 3. If we cannot queue task, then we try to add a new
* thread.  If it fails, we know we are shut down or saturated
* and so reject the task.
* 如果不能把任務加入隊列（可能線程池已經關閉或者滿了），那麼需要新開一個線程（往maxPoolSize發展）。
* 如果失敗的話，說明線程池shutdown了或者滿了，就要拒絕這個任務了。
*/
int c = ctl.get();
if (workerCountOf(c) < corePoolSize) {
if (addWorker(command, true))
return;
c = ctl.get();
}
/**
* 2、如果線程池RUNNING狀態，且入隊列成功
*/
if (isRunning(c) && workQueue.offer(command)) {
int recheck = ctl.get();
//如果再次校驗過程中，線程池不是RUNNING狀態，
// 並且remove(command)--workQueue.remove()成功，拒絕當前command
if (! isRunning(recheck) && remove(command))
reject(command);
//為什麼只檢查運行的worker數量是不是0呢？？ 為什麼不和corePoolSize比較呢？？
// 只保證有一個worker線程可以從queue中獲取任務執行就行了？？
// 因為只要還有活動的worker線程，就可以消費workerQueue中的任務
else if (workerCountOf(recheck) == 0)
addWorker(null, false);
}
/**
* 3、如果線程池不是running狀態 或者 無法入隊列
*    嘗試開啟新線程，擴容至maxPoolSize，
*    如果addWork(command, false) 失敗了，拒絕當前command
*/
else if (!addWorker(command, false))
reject(command);
}

看註解有點費勁，把 execute 方法裡的註釋單獨列出來，一步步說得很清楚：

如果當前正在運行的線程數 < corePoolSize，嘗試用給到的command來啟動一個新線程作為第一個任務。
調用 addWorker 方法，檢查 runState 和 workerCount，並且如果增加線程的話，能防止產生錯誤警報，如果不能增加線程，則返回 false。

如果一個任務被成功地加到隊列裡，仍然需要雙重檢驗來確認是否需要新建一個線程。
（因為可能在上一次檢查後，已經存在的線程已經died）或者進入這個方法後，線程池已經被關閉了。所以我們需要再次檢查 state，如果線程池停止了需要回滾入隊列，如果池中沒有線程了，新建一個線程。

如果不能把任務加入隊列（可能線程池已經關閉或者滿了），那麼需要新開一個線程（往maxPoolSize發展）。如果失敗的話，說明線程池 shutdown 了或者滿了，就要拒絕這個任務了。


總的來說，就是：

先看能不能加入核心線程裡，
再看能不能加入workQueue，
最後看有沒有超過線程池的最大數量，超過的話就拒絕這個 task 了。
Executors
它是一個Java中的工具類。提供工廠方法來創建不同類型的線程池。
用它可以很方便地創建出下面幾種線程池來。


常用線程池		特點				適應場景
newSingleThreadExecutor	單線程的線程池			用於需要保證順序執行的場景，並且只有一個線程在執行
newFixedThreadPool		固定大小的線程池			用於已知併發壓力的情況下，對線程數做限制。
newCachedThreadPool	可以無限擴大的線程池		比較適合處理執行時間比較小的任務。
newScheduledThreadPool	可以延時啟動，定時啟動的線程池	適用於需要多個後臺線程執行週期任務的場景。
newWorkStealingPool	擁有多個任務隊列的線程池		可以減少連接數，創建當前可用cpu數量的線程來並行執行。

比如這樣創建：

ExecutorService singleService = Executors.newSingleThreadExecutor();
ExecutorService fixedService = Executors.newFixedThreadPool(9);
ExecutorService cacheService = Executors.newCacheThreadPool();

或者通過 ThreadPoolExecutor 的構造函數自定義需要的線程池。


（匿名類別語法）
String[] names = { "Justin", "caterpillar", "Bush" };
Arrays.sort(names, new Comparator<String>() {
	public int compare(String name1, String name2) }
		return name1.length() - name2.length() ;
	}
});

sort()規定得實作Java.util.Comparator來說明排序時，兩個元素比較順序為何
Comparator<String> byLength = new Comparator<String>() {
	public int compare(String name1, String name2) {
		return name1.length() - name2.length();
	}
};
String[] names = { "Justin", caterpillar", "Bush" };
Arrays.sort(names, byLength);
透過變數byLength，排序意圖清楚許多，只是實作Comparator匿名類別依舊冗長，以下使用Lambda

Comparator<String> byLength =
	(String name1, String name2) -> name1.length() - name2.length();

Comparator<Srring> byLength =
	(name1, name2) -> name1.length() - name2.length();

Comparator<String> byLength =
	(var name1, var name2) -> name1.length() - name2.length();

=右邊的表示式夠簡短了，不如直接放到Arrays.sort()方法
import java.util.Arrays;

public class LambdaDemo {
	public static void main (String [] args) {
		String[] names = { "Justin", "caterpillar", "Bush" };
		Arrays.sort(names,
			(name1, name2) -> name1.length() - name2.length());
		System.out.println(Arrays.toString(names));
	}
}

public class StringOrder {
	public static int byLength(String s1, String s2) {
		return s1.length() - s2.length();
	}

	public static int byLexicography(String s1, String s2) {
		return s1.compareTo(S2);
	}

	public static int byLexicographyIgnoreCase(String s1, String s2) {
		return s1.compareToIgnoreCase(s2);
	}
}

（方法參考(Method reference)）
import java.util.Arrays;

public class StringOrderDemo {
	public static void main(String[] args) {
		String[] names= { "Justin", "caterpillar", "Bush" }
		Arrays.sort(names, StringOrder::byLength);
		System.out.println(Arrays.toString(names));
	}
}
Java引入Lambda的同時，保持與既有API維持的相容性是必要考量之一。
方法參考的特性，在重用既有API上扮演重要角色。
上例StringOrder::byLength，省去了new StringOrder這個class動作。
想使用上例StringOrder的byLexicography()方法，可以使用 String::compareTo，因為byLexicography實作內容只是呼叫String的compareTo()。


@override：重定義(override)方法
@FunctionalInterface：並非函式介面的話，會引發編譯錯誤

Lambda遇上this依據周圍語境(context)，看Lambda表示式是被哪個類別包圍而定。
Lambda與匿名類別一樣，存取的區域變數若等效於final可以不用加上final，因為要支援並行程式設計，如果可以更改區域變數就會有同步鎖定問題要處理。
函式介面實作可以參考靜態方法、特定物件的實例方法、類別定義的非靜態方法、構造器引用Class::new、(數組引用)數組::new
var names = List.of("Justin", "Monica", "Irene") ;
names.forEach(name -> out.println(name));
new HashSet(names).forEach(name -> out.println(name));
new ArrayDeque(names).forEach(name -> out.println(name));

forEach()接受java.util.function.Consumer介面的實例，Consumer介面必須實作void accept(T t)方法，out是PrintStream實例，println()是out的實例方法，實際上println()的方法簽署與accept()方法相同，
你可以直接參考out的println()方法：
var names= List.of("Justin", "Monica", "Irene");
names.forEach(out::println);
new HashSet(names).forEach(out::println);
new ArrayDeque(names).forEach(out::println);

介面預設方法
Java希望的風格是
List<String> names = ... ;
names.filter(s -> s.length() < 3).forEach(out::println);
而不是
forEach(filter(names, s -> s.length() < 3), out::println);

組合出複合比較條件的Comparator實例
import static java.lang.System.out;
import java.util.*;
import static java.util.Comparator.comparing;

public class CustomerDemo {
	public static void main(String[] args) {
		var customers = List.of(
			new Customer("Justin", "Lin", 804),
			new Customer("Monica", "Huang", 804),
			new Customer("Irene", "Lin", 804)
		};

		var byLastName= comparing(Customer::getLastName);

		customers.sort(
			byLastName
				.thenComparing(Customer::getFirstName)
				.thenComparing(Customer::getZipCode)
		};

		customers.forEach(out:println);
	}
}

class Customer {
	private String firstName;
	private String lastName;
	private Integer zipCode;

	public Customer(String firstName, String lastName, Integer zipCode) {
		this.firstName = firstName;
		this.lastName = lastName;
		this.zipCode =zipCode;
	}

	public String toString() {
		return String.format("Customer(%s %s, %d)",
				firstName, lastName, zipCode);
	}

	public String getFirstName() {
		return firstName;

	public String getLastName() {
		return lastName;
	}

	public String getZipCode() {
		return zipCode;
	}
}

NullPointerException，若有個變數參考至null，就會引發這個例外

（Optional）
可以修改getNickName0傳回Optional<String>實例，而不是傳回null，Return Optional instance if call function, maybe 包裹值 | 不包裹值
Some static method can build Optional instance, use of():If non null, build Optional instance. empty():Build 不包裹值的 Optional instance。

static String getNickName(String name) {
	var nickNames = Map.of(
		"Justin", "caterpillar",
		"Monica", "momor",
		"Irene", "hamimi"
	);
	return nickNames.get(name);
}

Optional改寫上頭getNickName()
static Optional<String> getNickName(String name) {
	var nickNames = Map.of(
		"Justin", "caterpillar",
		"Monica", "momor",
		"Irene", "hamimi"
	);
	var nickName = nickNames.get(name)'
	return nickName == null ? Optional.empty() : Optional.of(nickName);
}

若不檢查就直接呼叫Optional.get()
var nickName = getNickName("Duke").get();
out.println(nickName);

在Optional沒有值情況，會拋出java.util.NoSuchElementException，實現了「速錯(Fail fast)」，並了解到必須使用程式碼檢查，方式之一
var nickOptional =getNickName("Duck");
var nickName ="Openhome Reader";
if (nickOptional.isPresent()) {
	nickName = nickOptional.get();
}
out.println(nickName);

這方式太冗長，可以使用orElse()指定值不存在時的替代值
var nickOptional = getNickName("Duke") ;	//getNickName() return Optional instance
out.println(nickOptional.orElse("Openhome Reader"));

過去許多程式庫使用了null，這些程式庫無法說改就改
可使用Optional.ofNullable()來銜接程式庫會傳回null的方法
指定非null值就會呼叫of()；指定null值就會呼叫empty()
先前的getNickName()可以修改為
static Optional<String> getNickName(String name) {
	var nickNames = Map.of(
		"Justin", "caterpillar",
		"Monica", "momor",
		"Irene", "hamimi"
	);
	return Optional.ofNullable(nickNames.get(name));
}
Optional 還有更高階的 map()、flatMap()

（FunctionalInterface）
在這之前得先認識一下 java.util.function 套件中各個「函式介面」(只有一個方法的介面，@FunctionalInterface)

Lambda表示式的目標型態要看函式介面而定，雖然可以自行定義函式介面，只不過對於幾種常用的函式介面行為，JDK8已經定義了通用的函式介面。
先基於這些通用函式介面來撰寫程式，必要時再考慮自訂函式介面，通用函式介面基本上置放於java.util.function套件，行為來說可以分為 Consumer、Function、Predicate、Supplier 四種類型。
Ｃｏｎｓｕｍｅｒ		//接受一個引數、沒有return。純粹消耗了引數，而命名為 Consumer
package java.util.function;

import java.util.Objects;
@FunctionalInterface
public interface Consumer<T> {
	void accept(T t);
	...
}
接受Consumer方法之一，Iterable.forEach()
default void forEach(Consumer<? super T> action) {
	Objects.requireNonNull(action);
	for (T t : this) {
		action.accept(t);
	}
}
通常這表示 accept() 執行後會有副作用(Side effect)，像是改變物件狀態，或者是進行了輸入輸出，ex.使用 System.out.println() 進行輸出：
List.of("Justin", "Monica", "Irene").forEach(out::println);
Consumer介面接受「物件實例」做引數，對於基本型態int、long、double，另外有IntConsumer、LongConsumer、DoubleConsumer三個函式介面：
BiConsumer接受兩個引數的介面，ObjIntConsumer、ObjLongConsumer、ObjDoubleConsumer，它們的第一個參數接受物件，第二個參數分別接受int、long、double

Ｆｕｎｃｔｉｏｎ		//接受一個引數、執行後傳回結果。子介面為UnaryOperator，行為類似y=f(x)而命名
package java.util.function;

import java.util.Objects;
@FunctionalInterface
public interface Function<T, R> {
	R apply(T t);
	...
}
map() 就是接受 Function instance，指定了如何將值轉換為另一個值
UnaryOperator，參數、回傳值都是相同型態，雖然 Java 不支援運算子重載，命名概念源自於某些語言中，運算子也是函數的概念
@FunctionalInterface
public interface UnaryOperator<T> extends Function<T, T>
基本型態的轉換有IntFunction、LongFunction、DoubleFunction、IntToDoubleFunction、IntToLongFunction等，若要接受兩引數、回傳一結果，可以使用 BiFunction：
package java.util.function;

import java.util.Objects;

@FunctionalInterface
public interface BiFunction<T, U, R> {
	R apply(T t, U u);
	...
}
類似地，BinaryOperator 是 BiFunction 的子介面，兩個參數與回傳值相同型態，對於基本型態也有對應的函式介面，只要是 BiFunction | BinaryOperator 名稱結尾的，都是這類函式介面。

Ｐｒｅｄｉｃａｔｅ	// 接受一個引數、傳回boolean。
package java.util.function;

import java.util.Objects;
@FunctionalInterface
public interface Predicate<T> {
	boolean test(T t);
	...
}

若有個檔案名稱的 String陣列 fileNames，想要知道副檔名.txt有幾個：
var count = Stream.of(fileNames)
		.filter(name -> name.endsWith("txt"))
		.count();
此實例的filter()接受Predicate實例，fileNames的元素，會流入 Predicate 的 test()，方法傳回 true | false 判斷是否保留，保留下來的元素，才會流入 filter()，傳回的 Stream，透過 Count() 可以取得保留而流過來的元素有幾個。BiPredicate接受兩個引數、傳回boolean。基本型態對應的函式介面有，IntPredicate、LongPredicate、DoublePredicate。

Ｓｕｐｐｌｉｅｒ		//不接受引數、傳回值。代表 Supplier 實例會是生產者、工廠、產生器之類的角色，像是提供容器、固定值、某時間點某物的狀態、外部輸入、按需(On-demand索取的(昂貴)運算等。
package java.util.function;

@FunctionalInterface
public interface Supplier<T> {
	T get();
}

基本型態的有BooleanSupplier、DoubleSupplier、IntSupplier、LongSupplier等

Stream介面的collect()
collect
<R> R collect(Supplier<R> supplier,
	BiConsumer<R, ? super T> accumulator,
	BiConsumer<R, R>combiner)
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Lambda）
設計用來代替樣板代碼，Lambda能代替匿名類，都是只用一次即消失。由於lambda沒有名稱，因此不能直接從測試代碼中調用它們，因此向項目添加大量lambda表達式可能會使測試更加困難。
Android記事本中有段Lambda。

(argument) -> {expression body}

() -> System.out.println("This lambda expression has no parameters");

例外，當你的方法有一個推斷出它的類型的單個參數時，可以省略括號
textView.setOnLongClickListener(event -> System.out.println("Long Click"));

多參數
(argument1, argument2) -> System.out.println("arguments:" + argument1 + argument2);

但是如果編譯器無法推斷數據類型，則需要在參數前添加類型:
Button button = (Button) findViewById(R.id.button);
if (button != null) {
	button.setOnClickListener((View view) -> Log.d("debug", "Button clicked")
}

Android應用中使用Lambda

Lambdas進行事件處理
Button button = (Button)findViewById(R.id.button);
button.setOnClickListener(new View.OnClickListener() {
	@Override
	public void onClick(View view) {
		doSomething();
	}
});

通過Lambda重寫上述，我們可以刪除以下所有內容

類實例化: new View.OnClickListener()
訪問修飾符，方法名稱和類型: public void onClick(View view)
和參數類型，所以你不必寫View view
Button button = (Button)findViewById(R.id.button);
button.setOnClickListener(view -> doSomething());

Lambdas用於多線程

Runnable r = new Runnable() {
	@Override
	public void run() {
		System.out.println("My runnable");
	}
};

Thread thread = new Thread(r);
thread.start();

或者，使用Runnable接口的匿名類別語法來實例化新線程

Thread thread = new Thread(new Runnable() {
	@Override
	public void run() {
		System.out.println("My runnable");
	}
});

thread.start();

用Lambda替換匿名類
Runnable r = () -> {				// Runnable.run()因沒有參數而空。
	System.out.println("My runnable");
};

// Start the new thread

new Thread(r).start();

如果使用RxJava、RxAndroid庫，那麼您可以使用lambda來幫助您創建observables
我們正在創建一個簡單的命令Observable，將hello world字符串發送給它的所有字符串Observers

Observable.just("Hello, world!")
	.subscribe(new Action1<String>() {
	@Override
	public void call(String s) {
		Log.d(TAG, s);
	}
});
使用lambda可以讓你Action1用一行代替所有代碼
Observable.just("Hello, world!")
	.subscribe(s -> Log.d(TAG, s));
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（時間與日期ＡＰＩ：）

import static java.lang.System.out;
import static java.util.Calendar;

public class CalendarUtil {
	public static void main(String[] args) {
		var birth = Calendar.getInstance();
		birth.set(1975, Calendar.MAY, 26);
		var now = Calendar.getInstance();
		out.printf("歲數: %d%n",yearsBetween(birth, now));
		out.printf("歲數: %d%n",daysBetween(birth,now));
	}
	
	public static long yearsBetween(Calendar begin, Calendar end) {
		var calendar = (Calendar) begin.clone();
		var years = 0 ;
		while(calendar.before(end)) {
			calendar.add(Calendar.YEAR,1);
			years++;
		}
		return years -1 ;
	}
	
	public static long daysBetween(Calendar begin, Calendarend) {
		var calendar = (Calendar) begin.clone();
		var days = 0;
		while(calendar.before(end)) {
			calendar.add(Calendar.DATE,1);
			days++;
		}
		return days - 1;
	}
}

時間日期運算：抽象類別Calendar←GregorianCalendar
機器觀點：Date
人類觀點：
＊JDK8後：
機器觀點：Instant
人類觀點：LocalDateTime、LocalDate、LocalTime(不具時區的時間與日期定義)
java.time

___________________________________________________________________________________________________________________________________________________________________________________________________________________
Java 中的 BIO、NIO、AIO 理解為是 Java 語言對 操作系統 的各種 IO 模型的封裝。程序員在使用這些 API 的時候，不需要關心操作系統層面的知識，也不需要根據不同操作系統編寫不同的代碼。
在講 BIO、NIO、AIO 之前先回顧幾個概念：同步與異步、阻塞與非阻塞。
同步：兩個同步任務相互依賴，並且一個任務必須以依賴於另一個任務的某種方式執行。比如 A->B 事件模型中，需要先完成A才能執行B。同步調用中被調用者未處理完請求之前，調用不返回，調用者會一直等待結果的返回。
異步：兩個異步任務完全獨立，一方的執行不需要等待另一方的執行。異步調用中一調用就返回結果不需要等待結果返回，當結果返回的時候通過回調函數或者其他方式拿著結果再做相關事情。

阻塞：發起一個請求，調用者一直等待請求結果返回，也就是當前線程會被掛起，無法從事其他任務，只有當條件就緒才能繼續。
非阻塞：發起一個請求，調用者不用一直等待結果返回，可以先去幹其他事情。

如何區分以上呢？
同步/異步是從行為角度描述事物的，而阻塞/非阻塞描述的是當前事物的狀態(等待調用結果時的狀態)。

1. BIO (Blocking I/O)
同步阻塞I/O模式，數據的讀取寫入必須阻塞在一個線程內等待其完成。

1.1 傳統 BIO
BIO通信(一請求一應答)模型圖如下：

Client 0→			  Server			←new Thread 0

Client 1→		         ＼\		/／		←new Thread 1
		         	Acceptor
Client 2→		         ／/		\＼		←new Thread 2
		         
Client 3→		        				←new Thread 3

採用 BIO 通信模型的服務端，通常由一個獨立的 Acceptor 線程負責監聽客戶端的連接。我們一般通過在 while(true) 循環中服務端會調用 accpet() 等待接收客戶端的連接的方式監聽請求，請求一旦接收到一個連接請求，就可以建立通信套接字(Socket)在這個通信套接字上進行讀寫操作，此時不能再接收其他客戶端連接請求，只能等待當前連接的客戶端的操作執行完成，不過可以通過多線程來支持多個客戶端的連接，如上圖所示。

如要讓「BIO通信模型」能同時處理多個客戶端請求，就必須使用多線程(主要原因是 socket.accept()、socket.read()、socket.write() 涉及的三個主要函數都是同步阻塞的)，也就是說它接收到客戶端連接請求之後為每個客戶端創建一個新的線程進行鏈路處理，處理完後，通過輸出流返回應答給客戶端，線程銷毀。這就是典型的「一請求一應答通信模型」。設想如果這個連接不做任何事情就會造成不必要線程開銷，不過可以通過「線程池機制」改善，線程池還可讓線程的創建和回收成本相對較低。使用 FixedThreadPool 可以有效的控制了線程的最大數量，保證了系統有限的資源的控制，實現了 N(客戶端請求數量) : M(處理客戶端請求的線程數量)的「偽異步I/O模型」(N可以遠大於M )。

我們再設想當客戶端併發訪問量增加後這種模型會出現什麼問題？
在Java虛擬機中，線程是寶貴的資源，線程的創建和銷毀成本很高，除此之外，線程的切換成本也是很高的。尤其在 Linux 這樣的操作系統中，線程本質上就是一個進程，創建和銷毀線程都是重量級的系統函數。如果併發訪問量增加會導致線程數急劇膨脹可能會導致線程堆棧溢出、創建新線程失敗等問題，最終導致進程當機或者僵死，不能對外提供服務。

1.2 偽異步IO
為了解決同步阻塞I/O面臨的一個鏈路需要一個線程處理的問題，後來有人對它的線程模型進行了優化－－－後端通過一個線程池來處理多個客戶端的請求接入，可以靈活地調配線程資源，設置線程的最大值，防止線程耗盡。

Client 0→			Server			Runnable
			
Client 1→		         ＼\				↓
			Acceptor	→		Task
Client 2→		         ／/			
						↓
Client 3→					←↖↖↖	Thread Pool

採用線程池和任務隊列可以實現一種叫做偽異步的I/O通信框架，模型圖如上。當有新的客戶端接入時，將客戶端的 Socket 封裝成一個 Task (該任務實現 java.lang.Runnable 接口)投遞到後端的線程池中進行處理， JDK 的線程池維護一個消息隊列和 N 個活躍線程，對消息隊列中的任務進行處理。由於線程池可以設置消息隊列的大小和最大線程數，因此，它的資源占用是可控的，無論多少個客戶端併發訪問，都不會導致資源的耗盡和當機。

偽異步I/O通信框架採用了線程池實現，因此避免了為每個請求都創建一個獨立線程造成的線程資源耗盡問題。不過因為它的底層仍然是同步阻塞的BIO模型，因此無法從根本上解決問題。

1.3 代碼示例
下面代碼中演示了BIO通信(一請求一應答)模型。我們會在客戶端創建多個線程依次連接服務端並向其發送"當前時間+:hello world"，服務端會為每個客戶端線程創建一個線程來處理。
客戶端
public class IOClient {
	public static void main(String[] args) {
		// TODO 創建多個線程，模擬多個客戶端連接服務端
		new Thread(() -> {
			try {
				Socket socket = new Socket("127.0.0.1", 3333);
				while (true) {
					try {
						socket.getOutputStream().write((new Data() + ": hello world").getBytes());
						Thread.sleep(2000);
					} catch (Exception e) {
					}
				}
			} catch (Exception e) {
			}
		}).start();
	}
}

服務端
public class IOServer {
	public static void main(String[] args) {
		// TODO 服務端處理客戶端連接請求
		ServerSocket serveSocket = new ServerSocket(3333);

		// 接收到客戶端連接請求之後為每個客戶端創建一個新的線程進行鏈路處理
		new Thread(() -> {
			while (true) {
				try {
					// 阻塞方法獲取新的連接
					Socket socket = serverSocket.accept();

					// 每一個新的連接都創建一個線程，負責讀取數據
					new Thread(() -> {
						try {
							int len;
							byte[] data = new byte[1024];
							InputStream inputStream = socket.getInputStream();
							// 按字節流方式讀取數據
							while ((len = inputStream.read(data)) != -1) {
								System.out.println(new String(data, 0, len));
							}
						} catch (IOException e) {
						}
					}).start();
				} catch (IOException e) {
				}
			}
		}).start();
	}
}

1.4 總結
在活動連接數不是特別高(小於單機 1000 )的情況下，這種模型是比較不錯的，可以讓每一個連接專注於自己的I/O並且編程模型簡單，也不用過多考慮系統的過載、限流等問題。線程池本身就是一個天然的漏斗，可以緩衝一些系統處理不了的連接或請求。但是，當面對十萬甚至百萬級連接的時候，傳統的BIO模型是無能為力的。因此，我們需要一種更高效的I/O處理模型來應對更高的併發量。

2. NIO (New I/O)

2.1 NIO 簡介
NIO是一種同步非阻塞的I/O模型，在Java 1.4 中引入了 NIO 框架，對應 java.nio 包，提供了 Channel, Selector, Buffer等抽象。

NIO 中的 N 可以理解為 Non-blocking，不單純是 New。它支持面向緩衝的，基於通道的 I/O 操作方法，NIO 提供了與傳統 BIO 模型中的 Socket 和 ServerSocket 相對應的 SocketChannel 和 ServerSocketChannel 兩種不同的套接字通道實現，兩種通道都支持「阻塞」和「非阻塞」兩種模式。阻塞模式使用就像傳統中的支持一樣，比較簡單，但是性能和可靠性都不好；非阻塞模式正好與之相反。對於低負載、低並發的應用程序，可以使用同步阻塞I/O來提升開發速率和更好的維護性；對於高負載、高併發的(網絡)應用，應使用NIO的非阻塞模式來開發。
Java 中的 NIO 可以看作是 I/O 多路復用模型。也有很多人認為，Java 中的 NIO 屬於同步非阻塞 IO 模型。

2.2 NIO的特性/NIO與IO區別
如果是在面試中回答這個問題，我覺得首先肯定要從 NIO 流是非阻塞 IO 而 IO流是阻塞 IO 說起。然後，可以從 NIO 的3個核心組件/特性為 NIO 帶來的一些改進來分析。如果，你把這些都回答上了我覺得你對於 NIO 就有了更為深入一點的知識，面試官問到你這個問題，你也能很輕鬆的回答上來了。

1. Non-blocking IO ( 非阻塞IO )
IO 流是阻塞的，NIO流是不阻塞的。

Java NIO使我們可以進行非阻塞IO操作。比如說，單線程中從通道獲取數據到 buffer，同時可以繼續做別的事情，當數據讀取到 buffer 中後，線程再繼續處理數據。寫數據也是一樣的。另外，非阻塞寫也是如此。一個線程請求寫入一些數據到某通道，但不需要等待它完全寫入，這個線程同時可以去做別的事情。

Java IO的各種流是阻塞的。這意味著，當一個線程調用 read()、write() 時，該線程被阻塞，直到有一些數據被讀取，或數據完全寫入。該線程在此期間不能再幹任何事情了。

2. Buffer (緩衝區)
IO 面向流(Stream oriented)，而 NIO 面向緩衝區(Buffer oriented)。

Buffer是一個對象，它包含一些要寫入或者要讀出的數據。在NIO類庫中加入Buffer對象，體現了新庫與原I/O的一個重要區別。在面向流的I/O中可以將數據直接寫入或者將數據直接讀到 Stream 對象中。雖然 Stream 中也有 Buffer 開頭的擴展類，但只是流的包裝類，還是從流讀到緩衝區，而 NIO 卻是直接讀到 Buffer 中進行操作。

在NIO庫中，所有數據都是用緩衝區處理的。在讀取數據時，它是直接讀到緩衝區中的；在寫入數據時，寫入到緩衝區中。任何時候訪問NIO中的數據，都是通過緩衝區進行操作。

最常用的緩衝區是 ByteBuffer，一個 ByteBuffer 提供了一組功能用於操作 byte 數組。除了ByteBuffer，還有其他的一些緩衝區，事實上，每一種Java基本類型(除了Boolean類型)都對應有一種緩衝區。

3. Channel (通道)
NIO 通過 Channel(通道) 進行讀寫。

通道是雙向的，可讀也可寫，而流的讀寫是單向的。無論讀寫，通道只能和Buffer交互。因為 Buffer ，通道可以異步地讀寫。

4. Selector (選擇器)
NIO 有選擇器，而 IO 沒有。

選擇器用於使用單個線程處裡多個通道。因此，它需要較少的線程來處理這些通道。線程之間的切換對於操作系統來說是昂貴的。因此，為了提高系統效率選擇器是有用的。
	Thread

	Selector

Channel	Channel	Channel

2.3 NIO 讀數據和寫數據方式
通常來說NIO中的所有IO都是從 Channel(通道) 開始的。

	從通道進行數據讀取：創建一個緩衝區，然後請求通道讀取數據。
	從通道進行數據寫入：創建一個緩衝區，填充數據，並要求通道寫入數據。

數據讀取和寫入操作圖示：

Channel	——→	Buffer
Channel	←——	Buffer

2.4 NIO 核心組件簡單介紹
NIO 包含下面幾個核心的組件：
．Channel(通道)
．Buffer(緩衝區)
．Selector(選擇器)

整個NIO體系包含的類遠遠不止這三個，只能說這三個是NIO體系的"核心API"。我們上面已經對這三個概念進行了基本的闡述。

2.5 代碼示例
客戶端 IOClient.java的代碼不變，我們對服務端使用 NIO 進行改造。以下代碼較多而且邏輯比較複雜。
public class NIOServer {
	public static void main(String[] args) throws IOException {
		// 1. serverSelector負責輪詢是否有新的連接，服務端監測到新的連接之後，不再創建一個新的線程，
		// 而是直接將新連接綁定到clientSelector上，這樣就不用 IO 模型中 1w 個 while 循環在死等
		Selector serverSelector = Selector.open();
		// 2. clientServer負責輪詢連接是否有數據可讀
		Selector clientSelector = Selector.open();

		new Thread(() -> {
			try {
				// 對應IO編程中服務端啟動
				ServerSocketChannel listenerChannel = ServerSocketChannel.open();
				listenerChannel.socket().bind(new InetSocketAddress(3333));
				listenerChannel.configureBlocking(false);
				listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);

				while (true) {
					// 監測是否有新的連接，這裡的1指的是阻塞的時間為 1ms
					if (serverSelector.select(1) > 0) {
						Set<SelectionKey> set = serverSelector.selectedKeys();
						Iterator<SelectionKey> keyIterator = set.iterator();

						while (KeyIterator.hasNext()) {
							SelectionKey key = keyIterator.next();

							if (key.isAcceptable()) {
								try {
									// (1) 每來一個新連接，不需要創建一個線程，而是直接註冊到clientSelector
									SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();
									clientChannel.configureBlocking(false);
									clientChannel.register(clientSelector, SelectionKey.OP_READ);
								} finally {
									keyIterator.remove();
								}
							}
						}
					}
				}
			} catch (IOException ignored) {
			}
		}).start();
		new Thread(() -> {
			try {
				while (true) {
					// (2) 批量輪詢是否有哪些連接有數據可讀，這裡的1指的是阻塞的時間為 1ms
					if (clientSelector.select(1) > 0) {
						Set<SelectionKey> set = clientSelector.selectedKeys();
						Iterator<SelectionKey> keyIterator = set.iterator();

						while (keyIterator.hasNext()) {
							SelectionKey key = keyIterator.next();

							if (key.isReadable()) {
								try {
									SocketChannel clientChannel = (SocketChannel) key.channel();
									ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
									// (3) 面向 Buffer
									clientChannel.read(byteBuffer);
									byteBuffer.flip();
									System.out.println(
										Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());
								} finally {
									keyIterator.remove();
									key.interestOps(SelectionKey.OP_READ);
								}
							}
						}
					}
				}
			} catch (IOException ignored) {
			}
		}).start();
	}
}
為什麼大家都不願意用 JDK 原生 NIO 進行開發呢？從上面的代碼中大家都可以看出來，是真的難用！除了編程複雜、編程模型難之外，它還有以下讓人詬病的問題：
．JDK 的 NIO 底層由 epoll 實現，該實現飽受詬病的空輪詢 bug 會導致 cpu 飆升 100%
．項目龐大之後，自行實現的 NIO 很容易出現各種 bug，維護成本較高，上面這一坨代碼我都不能保證沒有 bug

Netty 的出現很大程度上改善了 JDK 原生 NIO 所存在的一些讓人難以忍受的問題。

3. AIO (Asynchronous I/O)
AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改進版 NIO 2，它是異步非阻塞的IO模型。異步 IO 是基於事件和回調機制實現的，也就是應用操作之後會直接返回，不會堵塞在那裡，當後臺處理完成，操作系統會通知相應的線程進行後續的操作。

AIO 是 異步IO 的縮寫，雖然 NIO 在網絡操作中，提供了非阻塞的方法，但是 NIO 的 IO 行為還是同步的。對於 NIO 來說，我們的業務線程是在 IO 操作準備好時，得到通知，接著就由這個線程自行進行 IO 操作，IO 操作本身是同步的。(除了 AIO 其它的 IO 類型都是同步的，這一點可以從底層IO線程模型解釋)

目前來說 AIO 的應用還不是很廣泛。Netty 之前也嘗試使用過 AIO，不過又放棄了。這是因為，Netty 使用了 AIO 之後，在 Linux 系統上的性能並沒有多少提升。

總結：

阻塞I/O 和 非阻塞I/O 區別在於：在 I/O 操作的完成或數據的返回前是等待還是返回(可以理解成一直等還是分時間段等)
同步I/O 和 異步I/O 區別在於：在I/O操作的完成或數據的返回前會不會將進程阻塞(或者説是主動查詢還是被動等待通知)

___________________________________________________________________________________________________________________________________________________________________________________________________________________
（NIO && NIO2）
（Buffer的操作）
clear()、flip()、rewind()
當緩衝區剛被配置或呼叫clear()後，limit() == capacity()、position() == 0
ex.1024ByteBuffer，ReadableByteChannel對其寫入512Bytes，limit()應該設為512，下個可讀取資料的位置索引值，可以使用position()得知或設定。limit()代表不能存取的索引值。
flip()：將limit值設為position目前值，而position設為0。寫入時position會移動，讀取前使用flip()讓limit移動、position移動。

import java.io.*;
import java.net.URL;
import java.nio.ByteBuffer;
import java.nio.channels.*;

public class NIOUtil {
	public static void dump(ReadableByteChannel src, WriteableByteChannel dest) throws IOException {
		var buffer = ByteBuffer.allocate(1024);
		try(src: dest) {
			while(src.read(buffer) != -1) {
				buffer.flip();
				dest.write(buffer);
				buffer.clear();
			}
		}
	}

	//測試用的main
	public static void main (String [] args) throws Exception {
		var ur1 = new URL("https://openhome.cc");
		var src = Channels.newChannel(url.openStream());
		var dest = new FileOutputStream("index.html").getChannel();
		NIOUtil.dump(src, dest);
	}
}




var currentTimeMillis= System.currentTimeMillis();
var fileTime = FileTime.fromMillis(currentTimeMillis);
Files.setLastModifiedTime(
	Paths.get("C:\\workspace\\Main.java"),fileTime);

Files.setLastModifiedTime()只是個簡便方法，屬性設定主要可透過Files.setAttribute()。例如設定檔案為隱藏：
Files.setAttribute(Paths.get(args[0]), "dos:hidden", true);

同樣設定最後修改時間，改用Files.setAttribute()可以如下撰寫：
var currentTimeMillis = System.currentTimeMillis();
var fileTime = FileTime.fromMillis(currentTimeMillis);
Files.setAttribute(
	Paths.get("C:\\workspace\\Main.java"), "basic:lastModifiedTime", fileTime);

Files.getAttribute()取得檔案屬性，也可透過Files.readAttributes()另一版本取得Map<String, Object>物件，鍵指定屬性名稱，就可以取得屬性值：
var attrs = Files.readAttributes)
	Paths.get(args[0]), "size, lastModifiedTime, lastAccessTime");

BasicFileAttributes←DosFileAttributes，新增了isArchive()、isHidden()、isReadOnly()、isSystem()等方法，可如下取得DosFileAttributes實例：
var file = Paths.get(args[0]);
var attrs = Files.readAttributes(file, DosFileAttributes.class);

BasicFileAttributes←PosixFileAttributes，新增了owner()、group()，可取得UserPrincipal(java.security.Principal子介面)、GroupPrincipal(UserPrincipal子

)實例，可分別取得檔案的群組(Group)與
擁有者(Owner)資訊；permissions()會以Set傳回Enum型態的PosixFilePermission實例，代表檔案擁有者、群組與其他使用者之讀寫權限資訊。

想取得儲存裝置本身的資訊，可以利用Files.getFileStore()取得指定路徑的FileStore實例，或透過FileSystem.getFileStores()取得所有儲存裝置的FileStore實例。以下利用FileStore計算磁碟使用率：
import java.io.IOException;
import static java.lang.System.out;
import java.nio.file.*;
import java.text.DecimalFormat;

public class Disk {
	public static void main(String[] args) throws IOException {
		if(args.length == 0) {
			var fileSystem = FileSystems.getDefault();
			for (var fileStore: FileSystem.getFileStores()) {
				print(fileStore);
			}
		}
		else {
			for(var file: args) {
				var fileStore = Files.getFileStore(Paths.get(file));
				print(fileStore);
			}
		}
	}

	public static void print(FIleStore store) throws IOException {
		var total = store.getTotalSpace();
		var used = store.getTotalSpace() - store.getUnallocatedSpace();
		var usable = store.getUsableSpace();
		var formatter = new DecimalFormat("#,###,###");
		out.println(store.toString());
		out.printf("\t- 總容量\t%s\t位元組%n", formatter.format(total));
		out.printf("\t- 已用空間\t%s\t位元組%n", formatter.format(used));
		out.printf("\t- 可用空間\t%s\t位元組%n", formatter.format(usable));
	}
}
FileSystem.getFileStores()會以Iterable<FileStore>傳回儲存裝置的FileStore物件

（操作檔案與資料夾：）
刪除：
Files.delete()，不存在NoSuchFileException，資料夾不為空而無法刪除DirectoryNotEmptyException。
Files.deleteIfExists()，不存在時呼叫不會拋出例外。

複製：
Files.copy()，第三個選項可以指定CopyOption介面的實作物件，CopyOption實作類別有Enum型態的StandardCopyOption、LinkOpiton。
例如指定StandardCopyOption的REPLACE_EXISTING實例進行複製時，若目標檔案已存在就會覆蓋，COPY_ATTRIBUTES會嘗試複製相關屬性，LinkOption的NOFOLLOW_LINKS則不會跟隨
符號連結。使用Files.copy()的規範如下：
Path srcPath = ...;
Path destPath= ...;
Files.copy(srcPath, destPath, StandardCopyOption.REPLACE_EXISTING);

檔案或資料夾移動：
Files.move()，指定來源Path、目的地Path、CopyOption，如果檔案支援原子移動，可在移動時指定StandardCopyOption.ATOMIC_MOVE

建立資料夾：
Files.createDirectory()，若呼叫時父資料夾不存在，NoSuchFileException。
Files.createDirectories()，會在父資料夾不存在時一併建立。
可在建立資料夾時一併使用FileAttribute指定檔案屬性，例如在支援Posix的檔案系統上建立資料夾：
Set<PosixFilePermission> perms =
	PosixFilePermissions.fromString("rwxr-x---");
FileAttribute<Set<PosixFilePermission>> attr =
	PosixFilePermissions.asFileAttribute(perms);
Files.createDirectory(file, attr);

建立暫存資料夾：
可以使用Files.createTempDirectory()，這麼方法建立暫存資料夾時，有「指定路徑」、「使用預設路徑」兩個版本。
NIO2也封裝了java.io的基本輸入輸出API。例如，如果Path實例是個檔案，可使用Files.readAllBytes()讀取整個檔案，以byte[]傳回檔案內容，若檔案內容都是字元，可使用Files.readAllLines()
指定檔案Path與編碼，讀取整個檔案，每行收集在List<String>傳回。

JDK8新增了Stream API，在NIO2檔案讀取上，Files新增了lines()靜態方法，return Stream<String>，適用於需要管線化、惰性操作的場合，lines()內部會開啟檔案，不使用時需要呼叫close()來
釋放資源，傳回的Stream可搭配JDK7嘗試關閉資源語法來關閉。例如：
try (var lines = Files.lines(Paths.get(args[0]))) {
	lines.forEach(out::println);
}

如果檔案內容都是字元，需要在讀取或寫入時使用緩衝區，也可以使用Files.newBufferedReader()、Files.newBufferWriter()指定檔案Path與編碼，分別return BufferedReader、BufferedWriter實例，
可以使用他們來進行檔案讀取或寫入。例如，本來有個建立BufferedReader的片段如下：
var reader = new BufferedReader() {
			new InputStreamReader(
				new FileInputStream(args[0], "UTF-8"));
	可使用Files.newBufferedReader()改寫：
var reader = Files.newBufferedReader(Path.get(args[0]), "UTF-8");
	在使用Files.newBufferedWriter()時，還可以指定OpenOption介面的實作物件，其實作類別為StandardOpenOption、LinkOption(實作了CopyOption、OpenOption)，能指定開啟檔案時的
行為，可以查看StandardOpenOption、LinkOption的API。了解有那些選項可以使用。

繼承了Iterable介面能使用增加式for迴圈語法或forEach()

（讀取、走訪資料夾：）
想走訪資料夾中全部的檔案與子資料夾，可以實作FileVisitor介面，其中定義了四個必須實作的方法：
package java.nio.file;
import java.nio.file.attribute.BasicFileAttributes;
import java.ioIOException;
public interface FileVisitor<T> {
	FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs)
		throws IOException;
	FileVisitResult visitFile(T file, BasicFileAttributes attrs)
		throws IOException;
	FileVisitResult visitFileFailed(T file,IOException exc)
		throws IOException;
	FileVisitResult postVisitDirectory(T dir, IOException exc)
		throws IOException;
}___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Logging - 通用API）
var logger = Logger.getLogger(Some.class.getName());
out.println(logger.getHandlers().length);	//顯示0，表示沒有Handler
//	以下會顯示兩行，一行包括java.util.logging.ConsoleHandler字樣
//	一行包括INFO字樣
for (var handler : logger.getParent().getHandlers()) {
	out.println(handler);
	out.println(handler.getLevel());
}

import java.util.logging.*;

public class LoggerDemo2 {
	public static void main(String[] args) {
		var logger = Logger.getLogger(LoggerDemo2.class.getName());
		logger.setLevel(Level.FINE);
		for(var handler : logger.getParent().getHandlers()) {
			handler.setLevel(Level.FINE);
		}
		logger.log(Level.WARNING, "WARNING 訊息");
		logger.log(Level.INFO, "INFO 訊息");
		logger.log(Level.CONFIG, "CONFIG 訊息");
		logger.log(Level.FINE, "FINE 訊息");
	}
}
（自訂Handler）
java.util.logging套件提供的Handler實作都不符合你的需求，可以繼承Handler類別，實作抽象方法publish()、flush()、close()，建議實作時考慮訊息過濾&格式化，一個建議的實作流程是：
public class CustomHandler extends Handler {
	...
	public void publish(LogRecord logRecord) {
		if(!isLoggable(logRecord)) {
			return;
		}
		var logMsg = getFormatter().format(logRecord);
		out.write(logMsg);	//out 是輸出目的地物件
	}

	public void flush() {
		...出清訊息
	}

	public void close() {
		...關閉輸出物件
	}
}
Handler 輸出、Formatter 格式化、Filter 訊息過濾。Handler有預設的isLoggable()實作，先依Level過濾訊息，再使用指定的Filter過濾訊息：
...
	public boolean isLoggable(LogRecord record) {
			int livelValue = getLevel().nitValue();
		if (record.getLevel().intValue() < levelValue || levelVaule == offValue) {
			return false;
		}
		Filter filter = getFilter();
		if (filter == null) {
			return true;
		}
		return filter.isLoggable(record);
	}
...
（自訂Formatter）
可以繼承Formatter實作抽象方法 format()，會傳入LogRecord，儲存有全部日誌訊息。例如將ConsoleHandler的Formatter設為自訂的Formatter：
import java.time.Instant;
import java.util.logging.*;

public class FormatterDemo {
	public static void main(String[] args) {
		var logger = Logger.getLogger(FormatterDemo.class.getName());
		logger.setLevel(Level.CONFIG);
		var handler = new ConsoleHandler();
		handler.setLevel(Level.CONFIG);
		handler.setFormatter(new Formatter() {
			@override
			public  String format(LogRecord record) {
				return "日誌來自 " + record.getSourceClassName() + "." + record.getSourceMethodName() + "\n"
				+ "\t層級\t：" + record.getLevel() + "\n"
				+ "\t訊息\t：" + record.getMessage() + "\n"
				+ "\t時間\t："  + Instant.ofEpochMilli(record.getMillis())
				+"\n";
			}
		});
		logger.addHandler(handler);
		logger.config("自訂 Formatter 訊息");
	}
}
Logger、Handler預設只依層級過濾訊息，Logger與Handler都有setFilter()，可以指定Filter實作物件，若想讓Logger、Handler依層級過濾之外，還能加入額外過濾，就可以實作Filter介面：
package java.util.logging;
public interface Filter {
	public boolean isLoggable(LogRecord record);
}
使用logging.properties
透過logging.properties來設定Logger組態，例如程式開發階段，在.properties中設定所有Level.WARNING層級的訊息輸出，在程式上線之後，若想關閉不會影響程式運行的警訊日誌，以減少不必要的輸出，只要在.properties中做個修改即可。
在JDK9以後的conf資料夾中，有個logging.properties檔案，是設定Logger組態的參考範例。可以修改這個範例另存到可載入類別之路徑中，啟動JVM時，指定"java.util.logging.config.file"系統屬性為.properties名稱。-Djava.util.logging.config.file=logging.properties，程式中的Logger就會套用指定檔案中的組態設定。

國際化基礎：
可以不修改應用程式情況下，根據不同使用者直接採用不同語言、日期格式等，這樣的設計考量稱為「國際化(internationalization)」，稱為i18n。
介紹java.util.ResourceBundle、java.util.Locale

使用ResourceBundle
日後可能變動的文字，可以考慮移至程式之外，使用ResourceBundle，首先要準備一個.properties檔案，例如messages.properties：
cc.openhome.welcome=Hello
cc.openhome.name=World
.properties檔案必須放置在可載入類別的路徑下，撰寫的是鍵/值配對，之後在程式中可以使用鍵來取得對應的值，例如：

import static java.lang.System.out;
import java.util.ResourceBundle;

public class Hello {
	public static void mian(String[] args) {
		var res = ResourceBundle.getBundle("messages");
		out.print(res.getString("cc.openhome.welcome") + "!");
		out.println(res.getString("cc.openhome.name") + "!");
	}
}

ResourceBundle的靜態getBundle()可取得ResourceBundle實例，引數是訊息檔案主檔名，getBundle()會找到對應的.properties檔案，取得ResourceBundle實例後可以使用getString()指定鍵來取得值。

使用Locale
國際化的三個重要觀念是地區(Locale)資訊、資源包(Resource bundle)、基礎名稱(Base name)。
地區資訊代表特定的地理、政治、文化區，地區資訊可由語言編碼(Language code){兩個小寫字母}定義在ISO-639與可選的地區編碼(Country code){兩個大寫字母}定義在ISO-3166來指定
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（整合資料庫）
程式碼的撰寫上，若要取得資料庫連線，必須有幾個動作：
註冊Driver實作物件
取得Connection實作物件
關閉Connection實作物件

註冊Driver實作物件：
實作Driver介面的物件是JDBC進行資料庫存取的起點
以H2實作的驅動程式為例，java.sql.Driver介面←…org.h2.Driver←java.sql.DriverManager。基本上必須呼叫其靜態方法registerDriver()進行註冊：
DriverManager.registerDriver(new org.h2.Driver());

不過實際上很少自行撰寫程式碼進行此動作，只要載入Driver介面的實作類別.class檔案，就會完成註冊。例如可透過java.lang.Class.forName()，動態載入驅動程式類別：
try {
	Class.forName("org.h2.Driver");
}
catch(ClassNotFoundException e) {
	throw new RuntimeException("找不到指定的類別");
}
若查看H2的org.h2.Driver類別實作原始碼：
package org.h2;
...略
public class Driver implements java.sql.Driver, JdbcDriverBackwardsCompat {
	private static final Drivere INSTANCE = new Driver();
	...略


	static {
		load();
	}

	public static synchronized Driver load() {
		try {
			if (!registered) {
				registered = true;
				DriverManager.registerDriver(INSTANCE);
			}
		} catch(SQLException e) {
			DbException.traceThrowable(e);
		}
		return INSTANCE;
	}
}

在static區塊中進行了註冊Driver實例的動作(呼叫static load())，而static區塊會在載入.class檔時執行。使用JDBC時，要求載入.class檔案的方式有四種：
1.使用Class.forName()
2.自行建立Driver介面實作類別的實例
3.啟動JVM時指定jdbc.drivers屬性
4.設定JAR中/META-INF/services/java.sql.Driver檔案

第二種方式就是直接撰寫程式碼：
var driver = new org.h2.Driver();

要建立物件就得載入.class檔案，也就會執行類別的static區塊，完成驅動程式註冊。第三種方式，就是執行java指定時如下：
> java -Djdbc.drivers=org.h2.Driver;ooo.XXXDriver 其他選項... YourProgram
應用程式可能同時連線多個廠商的資料庫，DriverManager也可註冊多個驅動程式實例，以上方式若需要指定多個驅動程式類別時，就是使用;區隔。
第四種方式是JDK6以後JDBC4.0特性，只要在驅動程式實作的JAR檔案/META-INF/services資料夾，放置java.sql.Driver檔案，當中撰寫Driver介面的實作類別名稱全名，DriverManager會自動讀取該檔案，找到指定類別進行註冊。

取得Connection實作物件：
資料庫連線代表物件，要取得Connection實作物件，可透過DriverManager.getConnection()：
Connection conn = DriverManager.getConnection(jdbcUrl);
呼叫getConnection()時，必須提供JDBC URL，其定義了連接資料庫時的協定、子協定、資料來源識別：
JDBC URL的「協定」總是以jdbc開始，除此之外，各家資料庫的JDBC URL格式各不相同，必須查詢資料庫產品使用手冊。
如果要透過DriverManager.getConnection()連接資料庫，一個比較完整的程式碼片段如下：
Connection conn = null;
SQLException ex = null;
try {
	var uri = "jdbc:h2:tcp://localhosst/c:/workspace/JDBCDemo/demo";
	var user = "caterpillar";
	var password = "12345678";
	conn = DriverManager.getConnection(uri, user, password);
	....
}
catch(SQLException e) {
	ex = e;
}
finally {
	if(conn != null) {
		try {
			conn.close();
		}
		catch(SQLException e) {
			if(ex == null) {
				ex=e;
			}
			else {
				ex.addSuppressed(e);
			}
		}
	}
	if (ex != null) {
		throw new RuntimeException(ex);
	}
}

（JDK7以後）JDBC的Connection、Statement、ResultSet等介面，都是java.lang.AutoCloseable子介面，可以使用嘗試自動關閉資源語法：
var jdbcUrl = "jdbc:h2:tcp://localhost/c:/workspace/JDBCDemo/demo";
var user = "caterpillar";
var password = "12345678";
try(var conn = DriverManager.getConnection(jdbcUrl, user, password)) {
	....
}
catch(SQLException e) {
	throw new RuntimeException(e);
}
在底層，DriverManager會以迴圈迭代已註冊的Driver實例，使用指定的JDBC URL呼叫Driver的connect()，嘗試取得Connection實例。以下是DriverManager中相關原始碼的重點節錄：
SQLException reason = null;
for (int i = 0; i < drivers.size(); i++) {	//逐一取得Driver實例
	...
	DriverInfo di = (DriverInfo)drivers.elementAt(i);
	...
	try {
		Connection result = di.driver.connect(url, info);	//嘗試連線
		if (result != null) {
			return (result);	//取得Connection就傳回
		}
	} catch (SQLException ex) {
		if (reason == null) {		//紀錄第一個發生的例外
			reason = ex;
		}
	}
}
if (reason != null) {
	println("getConnection failed:  "  +  reason);
	throw reason;	//如果有例外物件就丟出
}
throw new SQLException(	//沒有適用的Driver實例，丟出例外
	"No suitable driver found for "+ url,  "08001");
連線資料庫的完整範例，測試一下可否連線資料庫並取得Connection實例：
package cc.openhome;

import java.sql.*;
import static java.lang.System.out;

public class ConnectionDemo {
	public static void main (String[] args) throws ClassNotFoundException, SQLException {
		var jdbcUrl = "jdbc:h2:tcp://localhost/c:/workspace/JDBCDemo/demo";
		var user = "caterpillar";
		var password = "12345678";

		try(var conn = DriverManager.getConnection(jdbcUrl, user, passowrd)) {
			out.printf("已%s資料庫連線%n",
				conn.isClosed()  ?  "關閉"  :  "開啟");
		}
	}
}

（使用Statement、ResultSet：）
執行SQL的話，必須取得java.sql.Statement實作物件，它是SQL陳述的代表物件，可以使用Connection的createStatement()建立Statement物件：
Statement stmt = conn.createStatement();
executeUpdate()是用來執行CREATE TABLE、INSERT、DROP TABLE、ALTER TABLE等會改變資料庫內容的SQL。
例如若想在demo資料庫建立messages表格，可以如下：
import java.sql.DriverManager;
import java.sql.SQLException;

public class StatementDemo {
	public static void main (String[] args) {
		var jdbcUrl = "jdbc:h2:tcp://localhost/c:/workspace/JDBCDemo/demo";
		var user = "caterpillar";
		var password = "12345678";

		try( var conn = DriverManager.getConnection(jdbcUrl, user, password);
			var statement = conn.createStatement()) {
			statement.executeUpdate(
				"CREATE TABLE messages (" +
					"id INT NOT NULL AUTO_INCREMENT PRIMARY KEY," +
					"name CHAR(20) NOT NULL," +
					"email CHAR(40)," +
					"msg VARCHAR(256) NOT NULL); "
			};
			System.out.println("建立 messages 表格了");
		}catch(SQLException ex) {
			throw new RuntimeException(ex);
		}
	}
}
也可以直接在H2 Console中使用指令，在demo資料庫中建立表格。
建立表格後，若要在表格插入一筆資料，可以如下使用Statement.executeUpdate()：
stmt.executeUpdate("INSERT INTO messages VALUES(1, 'justin', " + " 'justin@mail.com',  'mesage...')");

指定欄位名稱
var result = stmt.executeQuery("SELECT * FROM messages");
while(result.next()) {
	var id = result.getInt("id");
	var name = result.getString("name");
	var email = result.getString("email");
	var msg = result.getString("msg");
	// ...
}
指定欄位順序
var result = stmt.executeQuery("SELECT * FROM messages");
while(result.next()) {
	var id = result.getInt(1);
	var name = result.getString(2);
	var mail = result.getString(3);
	var msg = result.getString(4);
	// ...
}
Statement的execute()可用來執行SQL，並可測試SQL是執行查詢或是更新，傳回True表示SQL執行可有ResultSet作為查詢結果，此時可用getResultSet()取得ResultSet物件。傳回False，表示SQL執行會有更新筆數，可使用getUpdateCount()取得更新筆數。若事先無法得知SQL是查詢或是更新，就可以使用execute()：
if (stmt.execute(sql)) {
	var rs = stmt.getResultSet();	//取得查詢結果ResultSet
	...
}
else {	//這是個更新操作
	var updated = stmt.getUpdateCount();	//取得更新筆數
	...
}
視需求而定，Statement、ResultSet不使用時可使用close()釋放相關資源，Statement關閉時，相關的ResultSet也會自動關閉。
接下來實作一個簡單的留言板，首先實作一個MessageDAO來存取資料庫：

import java.sql.*;
import java.util.*;

public class MessageDAO {
	private String url;
	private String username;
	private String password;

	public MessageDAO(String url, String username, String password) {
		this.url = url;
		this.username = username;
		this.password = password;
	}

	public void add(Message message) {
		try(var conn = DriverManager.getConnection(url, username, password);
			var statement = conn.createStatement()) {

			var sql = String.format(
		"INSERT INTO messages(name, email, msg) VALUES ('%s', '%s', '%s')",
				message.getName(), message.getEmail, message.getMsg());
			statement.executeUpdate(sql);
		} catch(SQLException ex) {
			throw new RuntimeExceptioin(ex);
		}
	}

	public List<Message> get() {	//這個方法會從資料庫中查詢所有留言
		var messages = new ArrayList<Message>();
		try(var conn = DriverManager.getConnection(url, username, password);
			var statement = conn.createStatement()) {
			var result = statement.executeQuery("SELECT * FROM messages");
			while (result.next()) {
				var message = toMessage(result);
				messages.add(message);
			}
		} catch(SQLException ex) {
			throw new RuntimeException(ex);
		}
		return messages;
	}
	
	private Message toMessage(ResultSet result) throws SQLException {
		var message = new Message();
		message.setID(result.getLong(1));
		message.setName(result.getString(2));
		message.setEmail(result.getString(3));
		message.setMsg(result.getMsg(4));
		return message;
	}
}
可以撰寫一個Message.java是封裝留言訊息的簡單類別：
可以撰寫一個簡單的MessageDAODemo類別來使用MessageDAO：

import static java.lang.System.out;
import java.util.Scanner;

public class MessageDAODemo {
	public static void main (String[] args) throws Exception {
		var jdbcUrl = "jdbc:h2:tcp://localhost/c:/workspace/JDBCDemo/demo";
		var username = "caterpillar";
		var password = "12345678";

		var dao = new MessageDAO(jdbcUrl, username, password);
		var console = new Scanner(System.in);
		while(true) {
			out.print("(1) 顯示留言 (2) 新增留言: ");
			switch(Integer.parseInt*console.nextLine())) {
				case1:
					dao.get().forEach(message -> {
						out.printf("%d\t%s\t%s\t%s%n",
							message.getId(),
							message.getName(),
							message.getEmail(),
							message.getMsg());
					});
					break;
				case2:
					out.print("姓名:");
					var name = console.extLine();
					out.print("郵件:");
					var email = console.nextLine();
					out.print("留言:");
					var msg = console.nextLine();
					dao.add(new Message(name, email, msg));	
			}
		}
	}
}

（使用DataSource取得連線：）
資料庫連線基本上需提供JDBC URL、使用者名稱、密碼等，這些是敏感資訊。可以讓MessageDAO依賴於javax.sql.DataSource介面，透過其定義的getConnection()取得Connection：
import java.sql.*;
import java.util.*;
import javax.sql.DataSource

public class MessageDAO3 {
	private DataSource dataSource;

	public MessageDAO3(DataSource dataSource) {
		this.dataSource = dataSource;
	}

	public void add(Message message) {
		try(var conn = dataSource.getConnection();
			var statement = conn.prepareStatement(
				"INSERT INTO messages(name, email, msg) VALUES (?, ?, ?)")) {
			...略
		} catch(SQLException ex) {
			throw new RuntimeException(ex);
		}
	}

	public List<Message> get() {
		var messages = new ArrayList<Message>();
		try(var conn = dataSource.getConnection();
			var statement = conn.createStatement()) {
			...略
		} catch(SQLException ex) {
			throw new RuntimeException(ex);
		}
		return messages;
	}
}
以下範例實作具有簡單連接池機制的DataSource，示範如何重複使用Connection：
import java.util.*;
import java.io.*;
import java.sql.*;
import java.util.concurrent.Executor;
import java.util.logging.Logger;
import javax.sql.DataSource;

public class SimpleConnectionPoolDataSource implements DataSource {
	private Properties props;
	private String url;
	private int max;	//連接池中最大Connection數目
	private List<Connection> conns;	//維護可重用的Connection物件

	public SimpleConnectionPoolDataSource() throws IOException, ClassNotFoundException {
		this("jdbc.properties");
	}

	public SimpleConnectionPoolDataSource(String [] args) throws IOException, ClassNotFoundException {
		props = new Properties();
	props.load(new FileInputStream(configFile));

	url = props.getProperty("cc.openhome.url");
	max = Integer.parseInt(props.getProperty("cc.openhome.poolmax"));

	connc = Collections.synchronizedList(new ArrayList<>());
}

	public synchronized Connection getConnection() throws SQLException {
		if(conns.isEmpty()) {
			return new ConnectionWrapper(
				DriverManager.getConnection(url),
				conns,
				max
			};
		}
		else {
			return conns.remove(conns.size() - 1);
		}
	}

	private class ConnectionWrapper implements Connection {
		private Connection conn;
		private List<Connection> conns;
		private int max;

		public ConnectionWrapper(Connection conn,
					List<Connection> conns, int max) {
			this.conn = conn;
			this.conns = conns;
			this.max = max;
		}

		@Override
		public void close() throws SQLException {
			if(conns.size() == max) {
				conn.close();
			}
			else {
				conns.add(this);
			}
		}
	
		@Override
		public Statement createStatement() throws SQLException
			return conn.createStatement();
		}
		...略
	}
	...略
}	

（ACID）：原子性(Atomicity)、一致性(Consistency)、隔離性(Isolation behavior)、持續性(Durability)
Connection conn = null;
try {
	conn = dataSource.getConnection();
	conn.setAutoCommit(false);	// 取消自動提交
	var stmt = conn.createStatement();
	stmt.executeUpdate("INSERT INTO ...");
	stmt.executeUpdate("INSERT INTO ...");
	conn.commit();
}
catch(SQLException e) {
	e.printStackTrace();
	if(conn != null) {
		try {
			conn.rollback();
		}
		catch(SQLException ex) {
			ex.printStackTrace();
		}
	}
}
finally {
	...
	if (conn != null) {
		try {
			conn.setAutoCommit(true);	//回復自動提交
			conn.close();
		}
		catch(SQLException ex) {
			ex.printStackTrace();
		}
	}
}

交易管理時，僅想撤回某執行點，可以設定儲存點(Save point)：
Savepoint point = null;
try {
	conn.setAutoCommit(false);
	var stmt = conn.createStatement();
	stmt.executeUpdate("INSERT INTO ...");
	...
	point = conn.setSavepoint();	//設定儲存點
	stmt.executeUpdate("INSERT INTO ...");
	...
	conn.commit();
}
catch(SQLException e) {
	e.printStackTrace();
	if(conn != null) {
		try {
			if(point == null) {
				conn.rollback();
			}
			else {
				conn.rollback(point);
				conn.releaseSavepoint(point);
			}
		}
		catch(SQLException ex) {
			ex.printStackTrace();
		}
	}
}
finally {
	...
	if( conn != null);
		try {
			conn.setAutoCommit(true);
			conn.close();
		}
		catch(SQLException ex) {
			ex.printStackTrace();
		}
	}
}
批次更新時，不用每筆都確認的話，也可以搭配交易管理：
try {
	conn.setAutoCommit(false);
	stmt = conn.createStatement();
	while(someCondition) {
		stmt.addBatch("INSERT INTO ...");
	}
	stmt.executeBatch();
	conn.commit();
}catch (SQLException ex) {
	ex.printStackTrace();
	if(conn != null)
		trry {
			conn.rollback();
		}catch(SQLException e) {
			e.printStackTrace();
		}
	}
} finally {
	...
	if(conn != null) {
		try {
			conn.setAutoCommit(true);
			conn.close0;
		}
		catch(SQLException ex) {
			ex.printStackTrace();
		}
	}
}
JDBC的metadata相關API，取得messages表格相關資訊：
import java.sql.*;
import java.util.*;
import javax.sql.DataSource;

public class MessageInfo {
	private DataSource dataSource;

	public MessagesInfo(DataSource dataSource) {
		this.dataSource = dataSource;
	}

	public List<ColumnInfo> getAllColumnInfo() {
		List<ColumnInfo> infos = null;
		try ( var conn = dataSource.getConnection()) {
			var meta = conn.getMetaData();
			var crs = meta.getColumns(
					null, null, "MESSAGES", null);
			infos = new ArrayList<>();
			while (crs.next()) {
				ColumnInfo info = toColumnInfo(crs);
				infos.add(info);
			}
		}
		catch(SQLException ex) {
			throw new RuntimeException(ex);
		}
		return infos;
	}

	private ColumnInfo toColumnInfo(ResultSet crs) throws SQLException {
		var info = new ColumnInfo();
		info.setName(crs.getString("COLUMN_NAME"));
		info.setType(crs.getString("TYPE_NAME"));
		info.setSize(crs.getInt("COLUMN_SIZE"));
		info.setNullable(crs.getBoolean("IS_NULLABLE"));
		info.setDef(crs.getString("COLUMN_DEF"));
		return info;
	}
}

（RowSet）
  ResultSet   ←    RowSet   ←   JdbcRowSet		
<interface>       <interface>        <interface> 
		             CachedRowSet   ←   WebRowSet	   ←FilterRowSet
			<interface>             <interface>	        <interface>
						        JoinRowSet
						        <interface>

這邊使用的實作是Oracle JDK附帶的JdbcRowSetImpl，可以如下建立JdbcRowSet實例：
JDK6之前
JdbcRowSet rowset = new JdbcRowSetImpl();

JDK7之後
新增了javax.sql.rowet.RowSetFactory介面、javax.sql.rowset.RowSetProvider類別，可以使用RowSetProvider.newFactory()取得RowSetFactory實作物件，再利用RowSetFactory.createJdbcRowSet()、createCachedRowSet()等方法，建立RowSet實例。例如建立JdbcRowSet實例：
RowSetFactory rowSetFactory = RowSetProvider.newFactory();
JdbcRowSet rowset = rowSetFacotry.createJdbcRowSet();

RowSet查詢資料：
rowset.setUrl("jdbc:h2:tcp://localhost/c:/workspace/JDBCDemo/demo");
rowset.setUsername("caterpillar");
rowset.setPassword("12345678");
rowset.setCommand("SELECT * FROM messages WHERE id = ?");
rowset.setInt(1, 1);
rowset.execute();

setCommand()設定查詢SQL。JdbcRowSet也有setAutoCommit()與commit()，可以進行交易控制。
若查詢後，想離線進行操作，可以使用CachedRowSet或其子介面實作物件，查詢資料後可以直接使用close()關閉連線，若在相關更新操作之後，想再與資料來源進行同步，可以呼叫acceptChanges()：
conn.setAutoCommit(false);	//conn是Connection
rowSet.acceptChanges(conn);	//rowSet是CachedRowSet
ocnn.setAutoCommit(true);

WebRowSet是CachedRowSet子介面，還能進行XML讀寫。例如以下的writeXML()，可用來讀取資料庫的表格資料，然後對指定的OutputStream寫出XML：
public static void writeXml(OutputStream outputStream) throws Exception {
	try(WebRowSet rowset = RowSetProvider.newFactory().createWebRowSet()) {
		rowset.setUrl("jdbc:h2:tcp://localhost/c:/workspace/JDBCDemo/demo");
		rowset.setUsername("root");
		rowset.setPassword("openhome");
		rowset.setCommand("SELECT * FROM messages");
		rowset.execute();
		rowset.writeXml(outputStream);
	}
}
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Reflect && ClassLoader）
框架的底層原理 AOP 就是使用反射，很多地方都有使用，被稱為框架的靈魂，主要是因為它賦予了我們在運行時分析類以及執行類中方法的能力。

反射機制優缺點：
優點：可以讓代碼更加靈活、為各種框架提供開箱即用的功能提供了便利性
缺點：讓我們在運行時有了分析操作類的能力，這同樣也增加了安全問題。如可以無視泛型參數的安全檢查(泛型參數的安全檢查發生在編譯時)。另外，反射的性能也要稍差點，不過，對於框架來說實際是影響不大的。

反射的應用場景：
平常寫業務代很少會接觸到直接使用反射機制的場景。但是，正是因為反射，你才能這麼輕鬆地使用各種框架。
Spring/Spring Boot、MyBatis 等等框架中大量使用反射機制。也大量使用了動態代理，動態代理的實現也依賴反射。
比如下面是通過 JDK 實現動態代理的示例代碼，其中就使用反射類 Method 來調用指定的方法。
public class DebugInvocationHandler implements InvocationHandler {
	// 代理類中的真實對象
	private final Object target;

	public DebugInvocationHandler(Object target) {
		this.traget = target;
	}

	public Obejct invoke(Object proxy, Method method, Object[] args) throws InvocationTargetException, IllegalAccessException {
		System.out.println("before method " + method.getName());
		Object result = method.invoke(target, args);
		System.out.println("after method " + method.getName());
		return result;
	}
}
另外，像 Java 中的一大利器「註解」的實現也用到了反射。
為什麼你使用 Spring 的時候，一個 @Component 註解就聲明了一個類為 Spring Bean 呢？為什麼你通過一個 @Value 註解就讀取到配置文件中的值呢？
這些都是因為你可以基於反射分析類，然後獲取到類/屬性/方法/方法的參數上的註解。你獲取到註解之後，就可以做進一步的處理。


Java反射相關的主要API
java.lang.Class
java.lang.reflect.Method
java.lang.reflect.Field
java.lang.reflect.Constructor
以上其實都直接或間接實現了AnnotatedElement介面，並實現了它定義的方法，AnnotatedElement介面的作用主要用於表示正在JVM中執行的程式中已使用註解的元素，透過該介面提供的方法可以獲取到註解資訊。

運用反射Class與.class檔案
java需要某類別時才載入.class檔案，而非在程式啟動就載入全部類別。可讓系統資源運用更有效率。
java.lang.Class實例代表Java應用程式運行時載入的.class檔案，類別、介面、Enum等編譯後都會生.class檔。Class類別沒有public建構式，實例是由JVM自動產生。
每個.class檔案載入時，JVM會自動生成對應的Class實例。可以透過Object.getClass()，或者透過.class常量(Class literal)取得物件對應的Class實例，若基本型態，可以使用對應的包裹類別.TYPE取得Class實例，例如Integer.TYPE可取得int的Class實例(int.class)，若要取Integer.class檔的Class必須使用Integer.class。
JDK9以後新增Class.getModule()取得代表模組的java.lang.Module實例，以便取得模組資訊。
編譯時期檢查對應.class檔案之資訊，執行時期使用某類別時，會先檢查是否有對應的Class實例，如果沒有，會載入對應的.class檔案並生成對應的Class實例。

預設JVM只會用一個Class實例代表一個.class檔案，精確說是經由「同一類別載入器」載入的.class只會有一個對應的Class實例。
使用Class.forName()動態載入類別，找不到會拋出ClassNotFoundExceptioin：
static Class forName()
static Class forName(String name, boolean initialize, ClassLoader loader)
從Class建立物件：
var clz = Class.forName(args[0]);
Object obj = clz.getDeclaredConstructor().newInstance();	//或者Class.getConstructor
Class.newInstance，JDK9以後廢棄了，因為若建構式宣告拋出了非受檢例外，呼叫此方法等於略過編譯時期檢查；Constructor.newInstance()會拋出受檢例外的InvocationTargetException，而任何建構式拋出的例外，會被InvocationTargetException實例包裹。
不知道類別名稱建構類別實例：
public interface Player {
	void play(String video);
}
import java.util.Scanner;

public class MediaMaster {
	public static void main (String[] args) throws ReflectiveOperationException {
		var playerImpl = System.getProperty("cc.openhome.PlayerImpl");
		var player = (Player) Class.forName(playerImpl).getDeclaredConstructor().newInstance();
		System.out.print("輸入想播放的影片:");
		Player.play(new Scanner(System.in).nextLine());
	}
} 
沒有寫死實作Player的類別名稱，可以在啟動程式時，透過系統屬性cc.openhome.PlyaerImpl指定。例如若實作Player的類別名稱為cc.openhome.ConsolePlayer：
public class ConsolePlayer implements Player {
	@override
	public void play(String video) {
		System.out.println("正在播放" + video);
	}
}

執行時指定-Dcc.openhome.PlayerImpl=cc.openhome.ConsolePlayer

若類別定義多個建構式，可以指定使用哪個建構式生成物件，Class.getConstructor()或Class.getDeclaredConstructor()時指定參數類型，取得代表建構式的Constructor物件，Constructor.newInstance()指定建構時的參數值。
假設因為某原因，必須動態載入java.util.List實作類別，只知道有個接受int的建構式，用來指定List初始容量(capacity)，就可以如下建構實例：
var clz = Class.forName(args[0]);	//動態載入.class
Constructor constructor = clz.getConstructor(Integer.TYPE);	//取得建構式
var list = (List) constructor.newInstance(100);	//利用建構式建立實例
若要生成陣列呢？陣列的Class實例由JVM生成，可透過.class或getClass()取得Class實例，不過並不知道陣列的建構式為何，因此必須使用java.lang.reflect.Array的newInstance()。例如動態生成長度為10的java.util.ArrayList陣列：
var clz = java.util.ArrayList.class;
Object obj = Array.newInstance(clz, 10);
取得陣列物件之後，可以Array.set()指定索引設值、Array.get()指定索引取值，另一個比較偷懶的方式，是直接當作Object[](或已知的陣列型態)使用：
var clz = java.util.ArrayList.class;
var objs = (Object[]) Array.newInstance(clz, 10);
objs[0] = new ArrayList();
ArrayList list = (ArrayList) objs[0];
以上程式片段，objs參考的陣列實例，每個索引處都是ArrayList型態而不是Object型態，這就是為何使用Array.newInstance()建立陣列的原因，想理解應用場合，若現在為實作過的ArrayList設計一個toArray()：
public class ArrayList<E> {
	private Object[] elems;
	...略
	public ArrayList(int capacity) {
		elems = new Object[capacity];
	}
	...略
	pubic E[] toArray() {
		return (E[]) elems;
	}
}
若現在有個使用者這麼使用ArrayList，悲劇就發生：
var list = new ArrayList<String>();
list.add("One");
list.add("Two");
String[] strs = list.toArray();
會拋出java.lang.ClassCastException，告訴你不可將Object[]當作String[]來使用，可以如下解決：
import java.lang.reflect.Array;
import java.util.Arrays;

public class ArrayList<E> {
	private Object[] elems;
	private int next;

	public ArrayList(int capacity) {
		elems = new Object[capacity];
	}

	public ArrayList() {
		this(16);
	}
	...略

	public E[] toArray() {
		E[] elements = null;
		if(size() > 0) {
			elements = (E[]) Array.newInstance(elems[0].getClass(), size());
			for(var i = 0; i<elements.length; i++) {
				elements[i] = (E) elems[i];
			}
		}
		return elements;
	}
}
從 Class 獲得資訊：
對應型態為java.lang.Module、java.lang.Package、java.lang.reflect.Constructor、java.lang.reflect.Method、java.lang.reflect.Field等。例如要取得指定String類別的套件名稱：
Package p = String.class.getPackage();
out.println(p.getName());	//顯示java.lang

操作物件方法與成員：
java.lang.reflect.Method.invoke()動態呼叫指定的方法。
以下程式片段可動態生成Student實例，並使用setName()、getName()：

Class clz = Class.forName("cc.openhome.Student");
Constructor constructor = clz.getConstructor(String.class, Integer.class);
Object obj = constructor.newInstance("caterpillar", 90);
//指定方法名稱與參數型態，呼叫getMethod()取得對應的公開Method實例
Method setter = clz.getMethod("setName", String.class);
//指定參數值呼叫物件obj方法
setter.invoke(obj,"caterpillar");
Method getter = clz.getMethod("getName");
out.println(getter.invoke(obj));

這只是動態呼叫方法的基本流程，實際應用，底下會設計 BeanUtil 類別，可指定 Map 物件與類別名稱呼叫 getBean()，這方法會抽取 Map 內容封裝為指定類別的實例，Map 的鍵為要呼叫的
setXXX()方法名稱(裡面的XXX不包括set)，而值為呼叫setXXX()時的引數。
例如，若Map收集了學生資料，以下傳回的就是Student實例，當中包括了Map的資訊：
var data = new HashMap<String, Object>();
data.put("name", "Justin");
data.put("score", "90");
var student = (Student) BeanUtil.getBean(data, "cc.openhome.Student");
//以下顯示(Justin, 90)
out.printf("(%s, %d)%n",student.getName(),student.getScore());

底下為BeanUtil實作
import java.lang.reflect.*;
import java.util.*;

public class BeanUtil {
	public static <T> T getBean(Map<String, Object> data, String clzName) throws Exception {
		var clz = Class.forName(clzName);
		var bean = clz.getDeclaredConstructor().newInstance();

		data.entrySet().forEach(entry -> {
			var setter = String.format("set%s%s", 
					entry.getKey().substring(0, 1).toUpperCase(),
					entry.getKey().substring(1));
			try {
					//根據方法名稱與參數型態取得Method實例
				var method = clz.getMethod(setter, entry.getValue().getClass());
					//必須是公開方法
				if (Modifier.isPublic(method.getModifiers())) {
					//指定實例與參數值呼叫方法
					method.invoke(bean, entry.getValue());
				}
			} catch (IllegalAccessException | IllegalArguentException |
				NoSuchMethodException | SecurityException |
				InvocationTargetException ex) {
				throw new RuntimeException(ex);
			}
		});
		return (T) bean;
	}
}
呼叫protected、private method，可以使用Class.getDeclaredMethod()取得Method，並呼叫Method的setAccessible()時指定true，將存取限制解除：

Method priMth = clz.getDeclaredMethod("priMth", ...);
priMth.setAccessible(true);
priMth.invoke(target, args);

也可以用反射機制存取類別資料成員，Class.getField()可取得公開的Field，若想取私有Field，可以使用getDeclaredField()。例如動態建立Student實例，並存取private的name、score成員：

var clz = Student.class;
var o = clz.getDeclaredConstructor().newInstance();
Field name = clz.getDeclaredField("name");
Field score = clz.getDeclaredField("score");
name.setAccessible(true);	//如果是private的Field，要修改得呼叫此方法
score.setAccessible(true);
name.set(o, "Justin");
score.set(o, 90);
var student = (Student) o;
//底下顯示(Justin 90)
out.printf("(%s,%d)%n", student.getName(), student.getScore());

靜態代理：實作同一個介面代理原本的實作類別，new代理物件需指定被代理物件，但實作與維護多個代理物件時太負擔。
動態代理：反射API有個Proxy類別，可動態建立介面的實作物件。反射API提供動態代理相關類別，不必為特定介面實作特定代理物件，使用一個處理者(Handler)代理多個介面的實作物件。
處理者類別必須實作java.lang.reflect.InvocationHandler介面，例如設計一個LoggingProxy類別：
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.util.logging.Level;
import java.util.logging.Logger;

public class LoggingProxy {
	public static Object bind(Object target) {
		return Proxy.newProxyInstance(		//動態建立代理物件
			target.getClass().getClassLoader(),
			target.getClass().getInterfaces(),
			new LoggingHandler(target)
		);
	}

	private static class LoggingHandler implements InvocationHandler {
		private Object target;

		LoggingHandler(Object target) {
			this.target = target;
		}

		public Object invoke(Object proxy, Method method,
				Object[] args) throws Throwable {
			Object result = null;
			try {
	         //實現日誌		log(String.format("%s()  呼叫開始...", method.getName()));
				result = method.invoke(target, args);	//執行被代理物件職責
	         //實現日誌		log(String.format("%s()  呼叫結束...", method.getName()));
	    		} catch (IllegalAccessException | IllegalArgumentException |
				InvocationTargetException e) {
				log(e.toString());
			}
			return result;
		}

		private void log(String message) {
			Logger.getLogger(LoggingHandler.class.getName())
				.log(Level.INFO, message);
		}
	}
}

（Java動態載入.class檔案）
使用Class.forName()取得Class實例
呼叫Class.getConstructor()或Class.getDeclaredConstructor()取得代表建構式的Constructor物件
再利用其newInstance()建立類別實例
package cc.openhome;

import java.util.Scanner;

public class MediaMaster {
	public static void main (String[] args)
		var playerImpl = System.getProperty("cc.openhome.PlayerImpl");
		var player = (Player) Class.forName(playerImpl)
				.getDeclaredConstructor().newInstance();
		System.out.print("輸入想播放的影片:");
		player.play(new Scanner(System.in).nextLine());		//讓使用者輸入
	}
}
雖然讓開發者開發速度與彈性提升，但是動態語言有風險，Java7之下的JVM層，物件與類別的方法可以在runtime才被覆寫或改寫，而不是在編譯、載入的時期就決定。https://www.ithome.com.tw/node/79425

使用了反射機制來呼叫c()。可以先看看不同選項下，StackWalker走訪的StackFrame有何不同：
import static java.lang.StackWalker.Option.*;
import static java.lang.System.out;
import java.util.List;

public class StackWalkerDemo3 {
	public static void main(String[] args) throws Exception {
		StackWalkerDemo3.class.getDeclaredMethod("c").invoke(null);
	}

	static void c() {
		b();
	}

	static void b() {
		a();
	}

	static void a() {
		var stackWalkers = List.of(
			StackWalker.getInstance(),
			StackWalker.getInstance(SHOW_REFLECT_FRAMES),
			StackWalker.getInstance(SHOW)HIDDEN_FRAMES)
		};

		stackWalkers.forEach(
			stackWalker -> {
				out.println();
				stackWalker.forEach(out::println);
			}
		};
	}
}
可以看到預設的堆疊追蹤紀錄最為簡潔，而SHOW_REFLECT_FRAMES顯示了一些反射相關的StackFrame，至於SHOW_HIDDEN_FRAMES除了顯示反射相關的StackFrame外，還多了個JVM特定實作的StackFrame。
若需要在StackWalker.getInstance()時指定多個選項，可以使用set()來指定，這時結合Set.of()會很方便：
var stackWalker = StackWalker.getInstance(
	Set.of(RETAIN_CLASS_REFERENCE, SHOW_REFLECT_FRAMES)
);
若想限制可取得的StackFrame深度，可以使用StackWalker.getInstance()的另一個版本：
var stackWalker = StackWalker.getInstace(
	Set.of(RETAIN_CLASS_REFERENCE, SHOW_REFLECT_FRAMES),
	10	//深度最多為10
);
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Generics）
收集物件時，考慮到收集各種物件之需求，因而內部實作採用Object參考收集之物件，所以執行時期被收集的物件會失去形態資訊，也因此你取回物件之後，必須自行記得物件的真正型態，並在語法上告訴編譯器讓物件重新扮演為自己的型態。
JDK5之後，新增了泛型 Generics 語法，讓你在設計API時可以指定類別或方法支援泛型，而使用API的客戶端在語法上會更為簡潔，並得到編譯時期檢查。
以在 java.lang.Object 中實作過的ArrayList為例，，可加入泛型語法：
package cc.openhome;

import java.util.Arrays;

public class ArrayList<E> {
	private Object[] list;
	private int next;					// next C語言預設是0，但我記得Java是100

	public ArrayList(int capacity) {
		list = new Object[capacity];
	}

	public ArrayList() {
		this(16);
	}

	public void add(E e) {
		if(next == list.length) {
			list = Arrays.copyOf(list, list.length * 2 );
		}
		list[next++] = e;
	}

	public E get(int index) {
		return (E) list[index];
	}

	public int size() {
		return next;
	}
}

類別名稱旁<E>，這表示此類別支援泛型，實際加入ArrayList的物件會客戶端宣告的E型態，E只是一個型態參數（表示Element），高興的話，你可以用T、K、V等參數名稱。
由於使用<E>定義型態參數，在需要編譯器檢查型態的地方，都可以使用E，像是add()方法必須檢查傳入的物件型態是E，get()方法必須轉換為E型態。

使用泛型語法，會對設計API造成一些語法上的麻煩，但對客戶端會多一些友善。例如：
...
ArrayList<String> names = new ArrayList<String>();
names.add("Justin");
names.add("Monica");
String name1 = names.get(0);
String name2 = names.get(1);
...
宣告與建立物件時，可使用角括號告知編譯器，這個物件收集的都會是String，而取回之後也會是String，不用再使用括號轉換型態。如果實際上加入了不是String的東西會如何呢？
由於你告訴編譯器，這個ArrayList會收集的物件都是String，若你收集非String的物件，編譯器就會檢查出這個錯誤。使用了宣告泛型的類別而不做型態宣告，型態部份會使用Object，也就是回歸沒有使用泛型前的做法，例如：
...
ArrayList names = new ArrayList();
names.add("Justin");
names.add("Monica");
String name1 = (String) names.get(0);
String name2 = (String) names.get(1);
...
編譯時會出現警告訊息：
Note: Main.java uses unchecked or unsafe operations.
Note: Recompile with -Xlint:unchecked for details.
使用javac時再加上-Xlint:unchecked就會告訴你詳細原因，主要是編譯器發現這個類別可以使用泛型，貼心地提醒你，是不是要使用，以避免發生非受檢（unckecked）的ClassCastExcetpion例外：
實際上你在編譯上頭的ArrayList時，也會出現警告訊息，因為在使用泛型時，get()方法傳回物件時還是用了CAST語法，編譯時加上-Xlint:unchecked時就可以看到原因：
這個部份的CAST是必要的，如果想避免編譯時看到這個警訊，可以在get()上標註@SuppressWarnings("unchecked")，告訴編譯器忽略這個可能的錯誤：
...
	@SuppressWarnings("unchecked")
	public E get(int index) {
		return (E) list[index];
	}
...
使用這邊的ArrayList如下宣告時：
...
	ArrayList<String> words = new ArrayList<>();
	words.add("one");
	String word = words.get(0);
...
實際上，泛型語法有一部份是編譯器蜜糖（一部份是記錄於位元碼中的資訊），若組譯以上程式片段，可以看到還是展開為JDK1.4之前的寫法：
...
	ArrayList arrayList = new ArrayList();
	arraylist.add("one");
	String s = (String) arraylist.get(0);
...
正因為展開後會有額外的語法，因而以下會編譯錯誤：
...
	ArrayList<String> words = new ArrayList<>();
	words.add("one");
	Integer number = words.get(0);		// 編譯錯誤
...
編譯器展開程式碼後，實際上會如下：
...
	ArrayList words = new ArrayList();
	words.add("one");
	Integer number = (String) words.get(0);	// 編譯錯誤
...

若介面支援泛型，在實作時也會比較方便，例如想排序陣列的話，可以使用java.util.Arrays的靜態sort()方法，若想指定元素順序，可以指定Comparator實作物件，Comparator中有關泛型的宣告是這樣的：
...
public interface Comparator<T> {
	int compare(T o1, T o2);
	...
}
這表示實作介面時，可以指定T代表的型態，而compare()就可以直接套用T型態。例如：
import java.util.*;

class ReversedStringOrder implements Comparator<String> {
	@Override
	public int compare(String s1, String s2) {
		return -s1.compareTo(s2);
	}
}

public class Main {
	public static void main(String[] args) {
		String[] words = {"B", "X", "A", "M", "F", "W", "O"};
		Arrays.sort(words, new ReversedStringOrder());
		for(String word: words) {
			System.out.println(word);
		}
	}
}
Arrays.sort()該行，如果想使用匿名內部類別來實現，可以如下：
Arrays.sort(words, new Comparator<String>() {
	@Override
	public int compare(String s1, String s2) {
		return -s1.compareTo(s2);
	}
});
可以看到，可讀性並不好，實際上我們只關心s1與s2的順序，這個寫法在JDK8支援Lambda之後，可以簡化為以下：
Arrays.sort(words, (s1, s2) -> -s1.compareTo(s2));


在定義泛型時，可以定義型態的邊界。例如：
class Animal {}
class Human extends Animal {}
class Toy {}
class Duck<T extends Animal> {}

public class BoundDemo {
	public static void main(String[] args) {
		Duck<Animal> ad = new Duck<Animal>();
		Duck<Human> hd = new Duck<Human>();
		Duck<Toy> td = new Duck<Toy>();	// 編譯錯誤
	}
}
在上例中，使用extends限制指定T實際型態時，必須是Animal的子類別，你可以使用Animal與Human來指定T實際型態，但不可以使用Toy，因為Toy不是Animal的子類別。
一個實際應用可以用快速排序法的例子來說明：
public class Util {
	public static <T extends Comparable> void sort(T[] array) {
		sort(array, 0, array.length-1);
	}

	private static <T extends Comparable> void sort(T[] array, int left, int right) {
		if(left < right) {
			int q = partition(array, left, right);
			sort(array, left, q-1);
			sort(array, q+1, right);
		}
	}

	private static<T extends Comparable> int partition(T[] array, int left, int right) {
		int i = left-1;
		for(int j = left; j < right; j++) {
			if(array[j].compareTo(array[right]) <= 0 ) {
				i++;
				swap(array, i, j);
			}
		}
		swap(array, i+1, right);
		return i + 1;
	}

	private static<T> void swap(T[] array, int i, int j) {
		T t = array[i];
		array[i] = array[j];
		array[j] = t;
	}
}
物件要能排序，基本上物件本身必須能比較大小，因此這個範例要求sort()方法傳入的陣列，當中每個元素必須是T型態，<T extends Comparable>語法限制了T必須實作java.lang.Comparable介面。可以如下使用sort()方法：
String[] words = {"B", "X", "A", "M", "F", "W", "O"};
Util.sort(words);
由於String實作了Comparable介面，因此可以使用Util的sort()方法進行排序。若extends之後指定了類別或介面後，想再指定其它介面，可以使用&連接。例如：
public class Some<T extends Iterable<T> & Comparable<T>> {
	...
}

接著要來看看在泛型中的型態通配字元?。如果你定義了以下類別：
public class Node<T> {
	public T value;			// T讓value跟next有關聯
	public Node<T> next;

	public Node(T value, Node<T> next) {
		this.value = value;
		this.next = next;
	}
}
如果有個Fruit類別繼承體系如下：
class Fruit {
	int price;
	int weight;
	Fruit() {}
	Fruit(int price, int weight) {
		this.price = price;
		this.weight = weight;
	}
}
class Apple extends Fruit {
	Apple() {}
	Apple(int price, int weight) {
		Super(price, weight);
	}
	@Override
	public String toString() {
		return "Apple";
	}
}
class Banana extends Fruit {
	Banana() {}
	Banana(int price, int weight) {
		super(price, weight);
	}
	@Override
	public String toString() {
		return "Banana";
	}
}
如果有以下程式片段，則會發生編譯錯誤：
Node<Apple> apple = new Node<>(new Apple(), null);
Node<Fruit> fruit = apple;				// 編譯錯誤，incompatible types
在這個片段中，apple型態宣告為Node<Apple>，而fruit型態宣告為Node<Fruit>，那麼Node<Apple>是一種Node<Fruit>嗎？顯然地，編譯器認為不是，所以不允許通過編譯。

如果B是A的子類別，而Node<B>可視為一種Node<A>，則稱Node具有共變性（Covariance）或有彈性的（flexible）。從以上編譯結果可看出「Java的泛型並不具有共變性」，不過可以使用「型態通配字元?」與「extends」來宣告變數，使其達到類似共變性。例如以下可以通過編譯：
Node<Apple> apple = new Node<>(new Apple(), null);
Node<? extends Fruit> fruit = apple;

一個實際應用的例子是：
public class CovarianceDemo {
	Node<Apple> apple1 = new Node<>(new Apple(), null);
	Node<Apple> apple2 = new Node<>(new Apple(), apple1);
	Node<Apple> apple3 = new Node<>(new Apple(), apple2);

	Node<Banana> banana1 = new Node<>(new Banana(), null);
	Node<Banana> banana2 = new Node<>(new Banana(), banana1);

	printlnForEach(apple3);
	printlnForEach(banana2);
}
	static void printlnForEach(Node<? extends Fruit> n) {
		Node<? extends Fruit> node = n;
		do {
			System.out.println(node.value);
			node =node.next;
		} while(node != null);
	}
}
printlnForEach()方法目的是可以顯示所有的水果節點，如果參數n僅宣告為Node<Fruit>型態，將只能接受Node<Fruit>實例。

若宣告?不搭配extends，則預設為? extends Object。
注意！這與宣告為Node<Object>不同，如果node宣告為Node<Object>，那就真的只能參考至Node<Object>實例了！

一旦使用通配字元?與extends限制T的型態，就只能透過T宣告的名稱取得物件指定給Object，或將T宣告的名稱指定為null，除此之外不能進行其它指定動作。例如：
Node<? extends Fruit> node = new Node<>(new Apple(), null);
Object o = node.value;
node.value = null;
Apple apple = node.value;	// 編譯錯誤
node.value = new Apple();	// 編譯錯誤

因為Java的泛型語法只用在編譯時期檢查，也就是泛型上的型態資訊僅提供編譯器進行型態檢查，不做為執行時期的確切型態資訊（又稱為型態抹除），由於無法在執行時期獲得確切型態資訊，編譯器就只能就編譯時期看到的型態來作檢查，因而造成以上談及的限制。

Java泛型在執行時期型態抹除，有時會讓人感到困惑。例如以下執行結果會是true或false呢？
List<Integer> list1 = new ArrayList<>();
List<String> list2 = new ArrayList<>();
System.out.println(list1.equals(list2));	// true
List<Integer>、List<String>是不同的型態，但Java這麼想，l1、l2都是空串列，那它們不就是相等的嗎？這是採取型態抹除的結果。

class Basket<T> {
	T[] things;
	Basket(T... things) {
		this.things = things;
	}

	@Override
	public boolean equals(Object o) {
		if(o instanceof Basket<T>) {
			Basket that = (Basket) o;
			return Arrays.deepEquals(this.things, that.things);
		}
		return false;
	}
}
在程式中instanceof對Basket<T>的型態判斷是不合法的，因為Java的泛型所採用的是型態抹除，也就是說，程式中泛型語法的 型態指定，僅提供編譯器使用，執行時期無法獲型態資訊，因而instanceof在執行時期比對時，僅能針對Basket型態比對，無法針對當中的泛型實際型態進行比對。
如果想要通過編譯，可以使用型態通配字元?：
class Basket<T> {
	T[] things;
	Basket(T... things) {
		this.things = things;
	}

	@Override
	public boolean equals(Object o) {
		if(o instanceof Basket<?>) {
			Basket that = (Basket) o;
			return Arrays.deepEquals(this.things, that.things);
		}
		return false;
	}
}
現在你可以使用equals()來比較兩個Basket是不是相同了：
public class Main {
	public static void main(String[] args) {
		Basket<Integer> b1 = new Basket<Integer>(1, 2);
		var b2 = new Basket<Integer>(1, 2);
		var b3 = new Basket<Integer>(1, 2);
		var b3 = new Basket<Integer>(2, 2);
		var b4 = new Basket<String>("1", "2");
		System.out.println(b1.equals(b2));	// true	String、Integer、Date的equals()覆寫為比較內容，而不是Object的比較記憶體位址( == )。
		System.out.println(b1.equals(b3));	// false
		System.out.println(b1.equals(b4));	// false
	}
}

以下考慮繼承關係後的equals()、hashCode()定義：
class Basket<T> {
	T[] things;
	Basket(T... things) {
		this.things = things;
	}

	@Override
	public boolean equals(Object o) {
		if(o instanceof Basket<?>) {
			Basket that = (Basket) o;
			return that.canEquals(this) && Arrays.deepEquals(this.things, that.things);
		}
		return false;
	}

	public boolean canEquals(Object other) {
		return other instanceof Basket<?>;
	}

	@Override
	public int hashCode() {
		int sum = 1;
		for (T t : things) {
			sum = sum * 41 + t.hashCode();
		}
		return 41 * sum + things.hashCode();
	}
}
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Enum）

想使用 enum 重新定義列舉，又必須與既存 API 搭配，也就是必須有個 int 值符合既存 API 的 Priority 值：
public enum Priority {
	MAX(10), NORM(5), MIN(1);	// 呼叫 enum 建構式

	private int value;

	private Priority((int value) {	// 不為 public 的建構式
		this.value = value;
	}

	public int value() {		// 自定義方法
		return value;
	}

	public static void main(String[] args) {
		for(var priority : Priority.values()) {
			System.out.printf("Priority(%s, %d)%n",
				priority, priority.value());
		}
	}
}

public enum Action {
	STOP, RIGHT, LEFT, UP, DOWN
}

反編譯：
使用 enum 定義列舉常數，實際上，enum 定義了特殊的類別，繼承自 java.lang.Enum，不過這是由編譯器處理，直接撰寫程式繼承 Enum 類別會被編譯器拒絕。在編譯過後，會產生 Action.class 檔案，嘗試反編譯觀察程式碼，可以了解 enum 列舉常數的部分細節：
public final class Action extends Enum {
	略...
	private Action(String s, int i) {
		super(s, i);
	}
	public static final Action STOP;
	public static final Action RIGHT;
	public static final Action LEFT;
	public static final Action UP;
	public static final Action DOWN;
	略...
	static {
		STOP = new Action("STOP", 0);
		RIGHT = new Aciton("RIGHT", 1);
		LEFT = new Action("LEFT", 2);
		UP = new Action("UP", 3);
		DOWN = new Action("DOWN", 4);
		略...
	}
}
enum定義的列舉類默認繼承了java.lang.Enum外，並實現了java.lang.Seriablizable、java.lang.Comparable兩個介面。values()、ordinal()、valueOf()方法位於java.lang.Enum類中：
values() 返回列舉類中所有的值
ordinal() 返回列舉常量的索引，就像數組索引一樣
valueOf() 返回指定字符串值的列舉常數

public enum Color {
	RED, GREEN, BULE
}

public class Test {
	public static void main(String[] args) {
		Color[] arr = Color.values();

		for (Color col : arr) {
			System.out.println(col + " at index " + col.ordinal());
		}

		System.out.println(Color.valueOf("RED"));
	}
}

RED at index 0
GREEN at index 1
BLUE at index 2
RED

（列舉類成員）
列舉跟普通類一樣可以用自己的變量、方法、構造函數，構造函數只能用private訪問修飾符，所以外部無法調用。
列舉既可以包含具體方法，也可以包含抽象方法。如果列舉類具有抽象方法，則列舉類的每個物件都必須實現它。
public enum Color {
	RED, GREEN, BULE

	private Color() {
		System.out.println("Constructor called for : " + this.toString());
	}

	public void colorInfo() {
		System.out.println("Universal Color");
	}
}

public class Test {
	public static void main(String[] args) {
		Color c1 = Color.RED;
		System.out.println(c1);
		c1.colorInfo();
	}
}

public enum Color {
	RED {
		public String getColor() {
			return "紅色";
		}
	},

	GREEN {
		public String getColor() {
			return "綠色";
		}
	},

	BLUE {
		public String getColor() {
			return "藍色";
		}
	};
	public abstract String getColor();	// 定義抽象方法
}

public class Test {
	public static void main(String[] args) {
		for( Color c : Color.values()) {
			System.out.println(c.getColor() + "、");
		}
	}
}


可以看到範例的enum定義的Action實際上是個類別，而enum中列舉的STOP、RIGHT、LEFT、UP、DOWN常數，實際上是public static final，且為Action實例，你無法直接撰寫程式直接實例化Action，因為建構式權限設定為private，只有Action類別中才可以實例化。
那麼如何使用這個Action呢？可以用它來宣告型態：
import static java.lang.System.out;

public class Game {
	public static void main(String[] args) {
		play(Action.RIGHT);		// 只能傳入Action實例
		play(Action.UP);
	}

	public static void play(Action action) {	// 宣告為Action型態
		out.println(
			switch(action) {
				case STOP	-> "播放停止動畫";
				case RIGHT	-> "播放向右動畫";
				case LEFT		-> "播放向左動畫";
				case UP		-> "播放向上動畫";
				case DOWN	-> "播放向下動畫";
			}
		);
	}
}
所以不用像先前範例，必須使用default於執行時期檢查，編譯器在編譯時期會進行型態檢查。

定義enum時使用特定值類別本體(Value-Specific Class Bodies)語法：比使用interface列舉常數再使用類別方法定義switch比對列舉實例要好(有個interface Command，定義了void execute())。
這代表每個列舉實例會有不同的execute()實作，職責分配上，比switch的方式清楚許多。
import static java.lang.System.out;

public enum Action3 implements Command {
	STOP {
		public void execute() {
			out.println("播放停止動畫");
		}
	},
	RIGHT {
		public void execute() {
			out.println("播放右轉動畫");
		}
	},
	LEFT {
		public void execute() {
			out.println("播放左轉動畫");
		}
	},
	UP {
		public void execute() {
			out.println("播放向上動畫");
		}
	},
	DOWN {
		public void execute() {
			out.println("播放向下動畫");
		}
	};
}
實際上編譯器會將Action3標示為抽象類別：
public abstract class Action3 extends Enum implements Command {
	...
}
並為每個列舉成員後的{}語法，產生匿名內部類別，這個匿名內部類別繼承了Action3，實作了execute()：
...略
	static
	{
		STOP = new Action3("STOP", 0) {
			public void execute() {
				System.out.println(
					"\u64AD\u653E\u505C\u6B62\u52D5\u756B");
			}
		};
		RIGHT = new Action3("STOP", 0) {
			public void execute() {
				System.out.println(
					"\u64AD\u653E\u505C\u6B62\u52D5\u756B");
			}
		};
		...略
	}
...略

內部類:https://www.itread01.com/content/1543168327.html
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Annotation）

任何註解都實現了 Annotation 接口成為子接口，並且無法繼承其他註解與接口，以 public、default 訪問修飾符，所以註解內可以擁有常數(用不到)、方法，跟一般 implements 不同，實現是由 JVM 完成。

常用註解分為三大類：
1. Java 標準註解
@Override、@Deprecated、@SuppressWarnings等。

2. 元註解(也是標準註解)
定義註解的註解，包括@Retention、@Target、@Inherited、@Documented、@Repeatable等。

3. 自定義註解

^^^
@Retention(RetentionPolicy.SOURCE)	// 註解僅存在於源碼中
@Retention(RetentionPolicy.CLASS)	// 默認，存在於源碼、class字節碼文件
@Retention(RetentionPolicy.RUNTIME)	// 存在於源碼、class字節碼文件、運行時可以通過反射獲取

@Target(ElementType.TYPE)
@Target(ElementType.FIELD)
@Target(ElementType.METHOD)
@Target(ElementType.PARAMETER)
@Target(ElementType.CONSTRUCTOR)
@Target(ElementType.LOCAL_VARIABLE)
@Target(ElementType.ANNOTATION_TYPE)
@Target(ElementType.PACKAGE)
@Target(ElementType.TYPE_PARAMETER)
@Target(ElementType.TYPE_USE)
@Target(ElementType.MODULE		// @since 9
@Target(ElementType.RECORD_COMPONENT	// @since 14
^^^

Java 註解(Annotation) 架構：

				Deprecated
ElementType			Documented
1..n		<<接口>>		Inherited
		Annotation	Override
				Retention
1				Target
RetentionPolicy			...


（作用）
註解: 分散式元數據，與源代碼緊綁定。
xml: 集中式元數據，與源代碼無綁定。

1. 生成文檔，生成 javadoc 文檔
2. 編譯檢查
3. 編譯時期動態處理，例如動態生成代碼。
4. 運行時期動態處理，例如使用反射注入實例(物件)。


（觀念）
1. 當方法沒有預設值時，則需要在使用註解時顯式的賦值。
2. 當一個類實現了此介面時，有預設實現的方法可以不重寫。
使用一個註解近似的看做是定義一個介面的實現類，重寫那些沒有預設值的方法，相當於定義註解的屬性值(參數、或是鍵值)。
3. 我們通過反射獲取到的物件是一個 jdk Proxy 動態代理生成的物件，整個物件繼承自 Proxy，實現了${註解}介面。
所以說所有的@interface 均 extends Annotation，我們想要獲取獲取註解的值時，可以像類一樣使用反射獲取其方法，然後呼叫方法獲取定義的值。
4. 返回值類型只能是原始資料型別、String、Class、enum、註解型別，或前面這些的陣列。


AnnotationElement 介面方法如下：

// 判斷該元素是否包含指定註解，包含則返回true
boolean isAnnotationPresent(Class<? extends Annotation> annotationClass)
    
// 返回該元素上對應的註解，如果沒有返回null
<T extends Annotation> T getAnnotation(Class<T> annotationClass);

// 返回該元素上的所有註解，如果沒有任何註解則返回一個空陣列
Annotation[] getAnnotations();

// 返回指定型別的註解，如果沒有返回空陣列
T[] getAnnotationsByType(Class<T> annotationClass)
    
// 返回指定型別的註解，如果沒有返回空陣列，只包含直接標註的註解，不包含inherited的註解
T getDeclaredAnnotation(Class<T> annotationClass)
    
// 返回指定型別的註解，如果沒有返回空陣列，只包含直接標註的註解，不包含inherited的註解
T[] getDeclaredAnnotationsByType
    
// 返回該元素上的所有註解，如果沒有任何註解則返回一個空陣列，只包含直接標註的註解，不包含inherited的註解
Annotation[] getDeclaredAnnotations();
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（使用Module）

import static java.lang.System.out;

public class ModuleInfo {
	public static void main(String[] args) throws Exception {
		Class clz = Class.forName(args[0]);

	Module current = ModuleInfo.class.getModule();
	Module module = clz.getModule();

	out.printf("%s 模組%s 讀取 %s 類別所在之 %s 模組%n",
		current.getName(),
		current.canRead*module) ? "可" : "不可",
		args[0],
		module.getName());

	out.println("exports 的套件 : ");
	module.getPackages().stream()
			.filter(module::isExported)
			.forEachOrdered(out::println);
	}
}
___________________________________________________________________________________________________________________________________________________________________________________________________________________
set_list = [ ( {"a":1}, {"a":2} ),
	( {"a":3}, {"a":4} )
	]
_len = len(set_list[0])
total = [0]*_len
for item_list in set_list:
	for i in range(_len):
		total[i] += item_list[i]["a"]

total = map(lambda item: sum(x["a"] for x in item), zip(*set_list))
___________________________________________________________________________________________________________________________________________________________________________________________________________________
private void batch(EnityManager em) {
	Employee e1 = null;
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（敏捷開發四個會議：）
PO(Product Owner)、SM(Scrum Master)、DEV(開發人員)、QA(測試人員)
敏捷計畫會：月初，一個迭代開一次，任務明確、需求分析、故事點劃分(小任務)，確定每個迭代要做哪些事情。
每日立會：早上開立會，任務展板，昨天完成的事情，今天計畫到明天早上完成的事情，並將問題提出。
敏捷評審會：向客戶或利益關係人展示團隊本次迭代、衝刺的完成工作，並獲取客戶的反饋。
敏捷回顧會：月尾，總結工作中經驗和教訓，定量分析(可用文檔工具，會有每個團隊的定量報表，包括迭代速率、客戶滿意度、團隊滿意度等等定量指標)、定性分析(較主觀的團隊建議，下個迭代做改進)。
CI自動驗證代碼質量、代碼評審。人與人、任務與任務不相干。主分支代碼隨時可交付，而且能保證質量。
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（使用Maven管理Java專案）

Local儲存庫
1.找到xml設定檔：{M2_HOME}\conf\setting.xml
2.更新標籤localRepository值如下：
...略
Default:${user.home}/.m2/repository	//預設
<localRepository>D:\IDE\maven_repo</localRepository>	//新增
由setting.xml修改local儲存庫的位置

Central儲存庫
可取得的檔案分4類：
javadoc
source
JAR
POM

Remote儲存庫
由其他地方下載不足的檔案，常見如java.net、JBoss repository，可以在專案的POM.xml使用標籤<repository>指定
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（使用Maven指令建立專案）

mvn archetype:generate > templates.txt
藉由導出的檔案，可以了解Maven支援的專案類型。

Maven使用模板建立專案，和Java比較相關的有2種模板：
構建Java SE(JAR)專案，maven-archetype-quickstart
構建Java Web(WAR)專案，maven-archetype-webapp

使用Maven模板建構Java專案的基本指令為：
mvn archetype:generate
-DgroupId = 專案使用的package根目錄，如com.xxx
-DartifactId = 專案名稱
-DarchetypeArtifactId = 模板名稱
-DinteractiveMode = false
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Eclipse的使用）
快捷鍵的配置，常用快捷鍵：
．內容提示：Alt + /
．快速修復：Ctrl + 1
．導包：Ctrl + shift + O
．格式化代碼塊：Ctrl + shift + F
．向前向後：Alt + 方向鍵
．添加註釋：Ctrl + shift + /
．除去註釋：Ctrl + shift + \
程序的調試和運行
．F5(跳入) F6(跳過) F7(跳出)
Junit
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（JPA）最初使用在Java EE架構的EJB容器裡，後來可獨立使用於Java SE。
EntityManager與Transaction
EntityManager的種類：
JPA的規格裡有幾種EntityManager的分類：
1.依使用不同的persistence context區分：
transaction-scoped類型的EntityManager，此時的使用persistence context為javax.persistence.PersistenceContextType.TRANSACTION
extended類型的EntityManager，此時的使用persistence context為javax.persistence.PersistenceContextType.EXTENDED
2.依EntityManager的管理權責區分：
container-managed類型的EntityManager，由容器管理
application-managed類型的EntityManager，由程式自己管理
3.依使用的交易(transaction)機制區分：
JTA類型的EntityManager，使用JTA(Java Transaction API)由Java管理交易
resource-local類型的EntityManager，由程式使用當地資源(local resource)自行管理交易

transaction-scoped和extended的差異：
Java EE架構中，EJB的session bean用來處理商業邏輯和資料庫的存取，區分為：
1.StateFul Session Bean，SFSB
2.StateLess Session Bean，SLSB
3.Singleton Session Bean
對一個實作Java EE規格的網站應用程式提出資源請求(request)時，可能有兩種情境：
情境1.一個操作僅由一次請求即可完成，如金額轉帳
情境2.一個操作需由多次請求才可完成，如購物車

情境1的狀況下，web容器會建立1個執行緒，這個執行緒經過Servlet後可以往後向EJB容器的SLSB元件呼叫一個需要交易的方法，此時開始交易；當方法執行完畢後，交易亦結束，最終執行緒結束並回應(response)結果與使用者。因為這類session bean元件不需要特別記錄使用者操作狀態，為無狀態，故名為StateLess Session Bean。這種情境下EntityManager預設使用transaction-scoped的persistence context，此時EntityManager所有的操作均在同一交易內完成，不需要跨越交易，commit前要將所有異動傾倒(flush)至資料庫，且commit後Entity物件的生命週期狀態將由managed轉為detached。而啟用交易的範圍又和定義商業邏輯的method一致，方法開始交易亦開始(若需交易)，也開始EntityManager對Entity物件的操作，方法結束前要將異動的資料同步至資料庫，方法結束同時也將結束交易，因此EntityManager也不需要跨越method。
方法、交易、persistence context同時開始
方法、交易、persistence context同時結束
persistence context為EntityManager所管理的Entity物件集合，因此EntityManager也不跨越方法、交易
SLSB與transaction-scoped類型的persistence context的建立方式如下：
@Stateless
public class StatelessSessionBean implements XXX {
	@PersistenceContext
	EntityManager entityManager;

	//other fields and methods
}
在情境2的狀況下
***
___________________________________________________________________________________________________________________________________________________________________________________________________________________
在persistence.xml內的transaction-type屬性設定值決定使用的交易型態，以下使用resource-local，亦即底下的Java SE範例裡使用的方式：
<persistence-unit name="..." transaction-type="RESOURCE_LOCAL"  >
</  persistence-unit  >
開發者使用javax.persistence.EntityTransaction進行交易的begin、commit、rollback：
import javax.persistence.EntityTransaction;

public class EntityTransactionDemo {
	public static void main(Stirng[] args) {
		EntityManagerFactory factory
			=Persistence.createEntityManagerFactory("PersistenceUnit");
		EntityManager em = factory.createEntityManager();
		EntityTransaction etx = em.getTransaction();
		try {
			etx.begin();
			Employee e1 = new Employee("Jim", "Tzeng", new Date(), 10000);
			em.persist(e1);
			etx.commit();
		catch (Exception e) {
			if (etx.isActive()) {
				etx.rollback();
			}
		}
	}
}
若使用JTA(Java Transaction API)：
<persistence-unit name="..." transaction-type="JTA"  >
</  persistence-unit  >
一旦使用container-managed的EntityManager將預設使用JTA的交易管理機制；若使用application-managed的EntityManager，則可以使用JTA或resource-local的交易管理機制。
JTA優勢在於可以關注在較高層級的交易控管，可以分為CMT(Container Manager Transaction)、BMT(Bean Manager Transaction)
CMT，開發者以@javax.ejb.TransactionAttribute標註方法以定義交易有效範圍後交由容器begin、commit、rollback交易，此為預設
BMT，開發者以javax.transaction.UserTransaction更細緻地控制交易，必須自己begin、commit、rollback交易

（CMT教學碼）
import javax.ejb.TransactionManagement;
import javax.ejb.TransactionManagementType;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;

@Stateless
@TransactionManagement(value=TransactionManagementType.CONTAINER)
@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
public class SampleBean {

	@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)
	public void method1() {...}

	@TransactionAttribute(TransactionAttributeType.MANDATORY)
	public void method2() {...}

	public void method3() {...}
}
（BMT教學碼）
import javax.ejb.TransactionManagement;
import javax.ejb.TransactionManagementType;
import javax.transaction.UserTransaction;

@Stateless
@TransactionManagement(value=TransactionManagementType.BEAN);
public class SomeBean {

	@Resource
	private UserTransaction utx;

	public void method1() {
		try {
			utx.begin();
			//some database access
			utx.commit();
		}catch (InsufficientFundException exception) {
			utx.rollback();
		}
	}
}
使用BMT與application-managed的EntityManager
1.開發者以EntityManagerFactory取得application-managed的EntityManager
2.BMT允許開發者以javax.transaction.UserTransaction更細緻地控制交易

藉由以下數個案例說明兩者的結合方式：
1.未啟動任何交易。結果為無任何Exception拋出且資料未寫入資料庫：
EntityManager em = emf.createEntityManager();
em.persist(new Employee());

2.改用BMT機制，且EntityManager建立於交易啟動後。資料將如預期寫入資料庫：
utx.begin();
EntityManager em = emf.createEntityManager();
em.persist(new Employee());
utx.commit();

3.使用BMT機制，但EntityManager建立於交易啟動前。無任何Exception拋出且資料未寫入資料庫：
EntityManager em = emf.createEntityManager();
utx.begin();
em.persist(new Employee());
utx.commit();

4.承前例，使用EntityManager.joinTransaction()將EntityManager接合(join)已經存在的UserTransaction，資料將寫入資料庫：
EntityManager em = emf.createEntityManager();
utx.begin();
em.joinTransaction();
em.persist(new Employee());
utx.commit();

5.妥善使用joinTransaction()可以讓EntityManager跨越不同的BMT交易，即便交易存在不同的方法內：
EntityManager em = emf.createEntityManager();
...
utx.begin();
em.joinTransaction();
em.persist(new Employee());
utx.commit();
...
utx.begin();
em.joinTransaction();
em.persist(new Employee());
utx.commit();
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Entity的繼承設計：）
使用SINGLE_TABLE策略
專案範例中定義Entity類別Person.java如下：
/jpa-basic/src/main/java/jpa/entity/Person.java
@Entity
@Table(name = "T_PERSON")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public class Person {
	@Id
	@GeneratedValue
	@Column(name = "FIRST_NAME")
	private String firstName;
	@Column(name = "LAST_NAME")
	private String lastName;
	// others
}
不同種類的Person會需要不同欄位，設計資料庫的關聯表格時可以將欄位放在表格T-PERSON內，或是獨立於另一個表格而在需要時再以SQL join的方式連結查詢，以Entity類別Developer.java為例：
/jpa-basic/src/main/java/jpa/entity/Developer.java
@Entity
@Table(name = "T_DEVELOPER")
@Access(AccessType.PROPERTY)
public class Developer extends Person {
	private String programmingLanguage;
	@Column(name = "PROG_LANG")
	public String getProgrammingLanguage() {
		return programmingLanguage;
	}
	public void setProgrammingLanguage(String programmingLanguage) {
		this.programmingLanguage = programmingLanguage;
	}
	// others
}
父類別的@Inheritance(strategy = InheritanceType.SINGLE_TABLE)將決定與子類別在資料庫的表格關聯設計方式。SINGLE_TABLE顧名思義會將所有欄位包含子類別Developer的PROG_LANG欄位，都集中在Person.java所建立的表格中，如下行6：
create table T_PERSON (
	DTYPE varchar(31) not null,
	ID bigint not null,
	FIRST_NAME varchar(255).
	LAST_NAME varchar(255),
	PROG_LANG varchar(255),
	primary key (id)
)
為了可以區分每筆資料是因為保存Person或Developer物件實例所產生，預設建立行2的欄位DTYPE來區別。
SINGLE_TABLE的繼承策略因此只會以Entity父類別Person.java建立單一T_PERSON表格，子類別Developer.java不會再建立T_DEVELOPER表格。若啟用Developer.java行2的標註@Table(name = "T_DEVELOPER")
將在執行時期拋出以下警告訊息，但不影響執行：
HHH000139:Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy:jpa.entity.Developer

保存Person物件實例的資料：
/jpa-basic/src/main/java/jpa/InheritanceDemo.java
private void persistPerson(EntityManager em) {
	EntityTransaction transaction = em.getTransaction();
	transaction.begin();

	Person person = new Person();
	person.setFirstName("Jim");
	person.setLastName("Tzeng");
	em.persist(person);

	transaction.commit();
}
保存Developer物件實例的資料：
/jpa-basic/src/main/java/jpa/InheritanceDemo.java
private void persistDeveloper(EntityManager em) {
	EntityTransaction transaction = em.getTransaction();
	transaction.begin();

	Developer dev1 = new Developer();
	dev1.setFirstName("Bill");
	dev1.setLastName("Wang");
	dev1.setProgrammingLanguage("Java");
	em.persist(dev1);

	Developer dev2 = new Developer();
	dev2.setFirstName("John");
	dev2.setLastName("Chang");
	dev2.setProgrammingLanguage("C#");
	em.persist(dev2);

	transaction.commit();
}
使用簡單的JPQL查詢資料新增結果：
/jpa-basic/src/main/java/jpa/InheritanceDemo.java
private void loadPersons(EntityManager em) {
	TypedQuery<person> query = 
		em.createQuery("select p from Person p", Person.class);
	List<person> resultList = query.getResultList();
	for (Person person : resultList) {
		System.out.println(person.toString());
	}
}
和SQL比較相同效果的語法：
SQL：select p.* from T_PERSON p
JPQL：select p from Person p
EntityManager.createQuery()傳回TypedQuery物件，支援泛型。
TypedQuery.getResultList()傳回List物件，支援泛型。
啟動run()，將依序執行前3個方法：
/jpa-basic/src/main/java/jpa/InheritanceDemo.java
public void run() {
	EntityManagerFactory factory = null;
	EntityManager entityManager = null;
	try {
		factory = Persistence.createEntityManagerFactory("PersistenceUnit");
		entityManager = factory.createEntityManager();
		persistPerson(entityManager);
		persistDeveloper(entityManager);
		loadPersons(entityManager);
	} catch (Exception e) {
		LOGGER.log(Level.SEVERE, e.getMessage(), e );
		e.printStackTrace();
	} finally {
		if (entityManager != null) {
			entityManager.close();
		}
		if (factory != null) {
			factory.close();
		}
	}
}
第一筆屬於Person物件實例的資料及其欄位PROG_LANG為null
DTYPE欄位保留Entity物件實例的型態。可使用@DiscriminatorColumn修改預設欄位名稱及儲存型態，並以@DiscriminatorValue指定個別Entity類別的儲存值。
/jpa-basic/src/main/java/jpa/entity/Person.java、Developer.java
@Entity
@Table(name = "T_PERSON")					//表格名稱
@Inheritance(strategy =  InheritanceType.SINGLE_TABLE)		//繼承策略
@DiscriminatorColumn(name = "PERSON_TYPE",			//修改預設欄位名稱
		discriminatorType = DiscriminatorType.INTEGER)	//修改預設儲存型態
@DiscriminatorValue("100")					//個別Entity類別的值
public class Person {
	//...
}

@Entity
@Table(name = "T_DEVELOPER")
@Access(AccessType.PROPERTY)
@DiscriminatorValue("200")
public class Developer extends Person {
	//...
}
使用JOINED策略
/jpa-basic/src/main/java/jpa/entity/Person.java
@Entity
@Table(name = "T_PERSON")
@Inheritance(strategy = InheritanceType.JOINED)			//Entity繼承策略
public class Person {
	//...
}
Developer類別標註@Table(name = "T_DEVELOPER")：
/jpa-basic/src/main/java/jpa/Developer.java
@Entity
@Table(name = "T_DEVELOPER")
@Access(AccessType.PROPERTY)				//Entity父類與子類寫作風格不同的話加上這段
public class Developer extends Person {
	//...
}
依前例執行InheritanceDemo.java的main()後JPA將自動建立2個表格。
執行JPQL select p from Person查詢時將轉換為T_PERSON、T_DEVELOPER兩表格left join的SQL，但結果不變。
使用TABLE_PER_CLASS策略
/jpa-basic/src/main/java/jpa/entity/Person.java
@Entity
@Table(name = "T_PERSON")
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class Person {
	//...
}
Developer類別無需更動：
/jpa-basic/src/main/java/jpa/entity/Developer.java
@Entity
@Table(name = "T_DEVELOPER")
@Access(AccessType.PROPERTY)
public class Developer extends Person {
	//...
}
依前例執行後JPA將自動建立2個表格。
執行JPQL select p from Person查詢時將轉換為T_PEROSN、T_DEVELOPER兩表格union的SQL查詢，T_PERSON缺乏的PROG_LANG欄位則以null as PROG_LANG方式建立，且結果不變。
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Entity的關聯設計）
使用OneToOne設計
以下使用JPA的Entity類別定義：
@Entity
@Table(name = "T_ID_CARD")
public class IdCard {
	private Long id;
	private String idNumber;
	private Date issueDate;
	private boolean valid;

	@Id
	@GeneratedValue(strategy = GenerationType.IDENTITY)
	@Column(name = "ID")
	public Long getId() {
		return id;
	}

	@Column(name = "ID_NUMBER")
	public String getIdNumber() {
		return idNumber;
	}

	@Column(name = "ISSUE_DATE")
	@Temporal(TemporalType.TIMESTAMP)
	public Date getIssueDate() {
		return issueDate;
	}

	@Column(name = "VALID")
	@Convert(convert = BooleanConverter.class)
	public boolean isValid() {
		return valid;
	}

	// setter methods
	@Override
	public String toString() {
		return "IdCard [id=" + id + ", idNumber=" + idNumber + ",
			issueDate=" + issueDate + ", valid=" + valid + "]";
	}
}
指定以下轉換器(converter)在ORM流程進行時自動轉換：
import javax.persistence.AttributeConverter;
import javax.persistence.Converter;

@Converter
public class BooleanConverter implements AttributeConverter<Boolean, Integer> {
	@Override
	public Integer converToDatabaseColumn(Boolean aBoolean) {
		if (Boolean.TRUE.equals(aBoolean)) {
			return 1;
		} else {
			return -1;
		}
	}
	@Override
	public Boolean convertToEntityAttribute(Integer value) {
		if(value == null) {
			return Boolean.FALSE;
		} else {
			if (value == 1) {
				return Boolean.TRUE;
			} else {
				return Booelan.FALSE;
			}
		}
	}
}
此時JPA建立表格時將指定欄位VALID的型態為integer

JPA建立表格T_ID_CARD使用的DDL
create table T_ID_CARD {
	ID bigint generated by default as identity,
	ID_NUMBER varchar(255),
	ISSUE_DATE timestamp,
	VALID integer,
	primary key (id)
}
修改Entity類別Person
JPA自動建立表格T_PERSON與FK欄位ID_CARD_ID以關聯表格T_ID_CARD的PK欄位
@Entity
@Table(name = "T_PERSON")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public class Person {
	@OneToOne
	@JoinColumn(name = "ID_CARD_ID")
	private IdCard idCard;

	public IdCard getIdCard() {
		return idCard;
	}
	public void setIdCard(IdCard idCard) {
		this.idCard = idCard;
	}
// others fields and methods
}
create table T_PERSON {
	DTYPE varchar(31) not null,
	ID bigint not null,
	FIRST_NAME varchar(255),
	LAST_NAME varchar(255),
	PROG_LANG varchar(255),
	ID_CARD_ID bigint,
	primary key (id)
}

alter table T_PERSON
	add constraint FK8qhp1bnus6n6ic40o4w6awowp
	foreign key (ID_CARD_ID)
	references T_ID_CARD
新增與修改Person、IdCard資料
因為Person和IdCard有關聯性，新增資料方式：
/jpa-basic/src/main/java/jpa/OneToOneDemo.java
private void persistPerson(EntityManager em) {
	EntityTransaction transaction = em.getTransaction();
	transaction.begin();

	IdCard idCard = new IdCard();
	idCard.setIdNumber("1111");
	idCard.setIssueDate(new Date());		//建立IdCard與IssueDate的關聯

	Person person = new Person();
	person.setFirstName("Jim");
	person.setLastName("Tzeng");
	person.setIdCard(idCard);			//建立Person與IdCard的關聯

	em.persist(person);
	em.persist(idCard);
	transaction.commit();
}
Developer是Person子類別，保存資料方式相似：
private void persistDeveloper(EntityManager em) {
	EntityTransaction tx = em.getTransaction();
	tx.begin();

	IdCard idCard = new IdCard();
	idCard.setIdNumber("2222");
	idCard.setIssueDate(new Date());

	Developer dev = new Developer();
	dev.setFirstName("Bill");
	dev.setLastName("Wang");
	dev.setProgrammingLanguage("Java");
	dev.setIdCard(idCard);

	em.persist(idCard);
	em.persist(dev);
	tx.commit();
}
更新資料的方式：
private void updatePerson(EntityManager em) {
	EntityTransaction transaction = em.getTransaction();
	transaction.begin();

	Person p = em.find(Person.class, 11);
	p.setFirstName("Jim2");

	IdCard c = p.getIdCard();
	c.setIdNumber("11112");

	transaction.commit();
}
設定為EAGER
public class Person {
	@OneToOne(fetch = FetchType.EAGER)
	@JoinColumn(name = "ID_CARD_ID")
	private IdCard idCard;
	//...
}
/jpa-basic/src/main/java/jpa/OneToOneDemo.java
private void loadPersons(EntityManager entityManager) {
	entityManager.clear();
	TypedQuery<Person> query
		=entityManager.createQuery("from Person", Person.class);
	List<Person> resultList = query.getResultList();
	for (Person person : resultList) {
		StringBuilder sb = new StringBuilder();
		sb.append(person.toString());
		IdCard idCard = person.getIdCard();
		if (idCard != null) {
			sb.append(", ").append(idCard.toString());
		}
		System.out.println(sb);
	}
}
執行時期將連續觸發以下SQL：
1.查詢T_PERSON共1次，將取得2筆資料：
select
	person0_.ID as id2_4_,
	person0_.FIRST_NAME as FIRST_NA3_4_,
	person0_.ID_CARD_ID as ID_CARD_6_4_,
	person0_.LAST_NAME as LAST_NAM4_4_,
	person0_.PROG_LANG as PROG_LAN5_4_,
	person0_.DTYPE as DTYPE1_4_
from
	T_PERSON person0_
2.查詢T_ID_CARD共2次。因前述每筆T_PERSON資料必須各自發動1次SQL查詢T_ID_CARD：
select
	idcard0_.ID as id1_3_0_,
	idcard0_.ID_NUMBER as ID_NUMBE2_3_0_,
	idcard0_.ISSUE_DATE as ISSUE_DA3_3_0_,
	idcard0_.VALID as VALID4_3_0_
from
	T_ID_CARD idcard0_
where
	idcard0_.ID =?
因為行5一次發動了所有相關SQL，故名EAGER
設定為LAZY
則前述行5將先觸發查詢T_PERSON的SQL共1次，並取得2筆資料：
select
	person0_.ID as id2_4_,
	person0_.FIRST_NAME as FIRST_NA3_4_,
	person0_.ID_CARD_ID as ID_CARD_6_4_,
	person0_.LAST NAME as LAST_NAM4_4_,
	person0_.PROG_LANG as PROG_LAN5_4_,
	person0_.DTYPE as DTYPE1_4_
from
	T_PERSON person0_
後續在loadPersons()行11再陸續迴圈觸發查詢T_ID_CARD的SQL前後共2次。因前述每筆T_PERSON資料必須各自發動1次SQL查詢T_ID_CARD：
select
	idcard0_.ID as id1_3_0_,
	idcard0_.ID_NUMBER as ID_NUMBE2_3_0_,
	idcard0_.ISSUE_DATE as ISSUE_DA3_3_0_,
	idcard0_.VALID as VALID4_3_0_
from
	T_ID_CARD idcard0_
where
	idcard0_.ID =?
查詢得到Person的資料筆數，影響載入IdCard資料時發動的SQL，對效能不可不慎。
使用JPQL的inner join fetch語法。將loadPersons()行4的JPQL由
from Person
改為
from Person p inner join fetch p.idCard
無關使用EAGER、LAZY，將改用表格T_PERSON直接inner join表格T_ID_CARD，1次SQL取回所有需要資料，與使用EAGER或LAZY的結果相同。JPQL觸發的SQL如下：
select
	person0_.ID as id2_4_0_,
	idcard1_.ID as id1_3_1_,
	person0_.FIRST_NAME as FIRST_NA3_4_0_,
	person0_.ID_CARD_ID as ID_CARD_6_4_0_,
	person0_.LAST_NAME as LAST_NAM4_4_0_,
	person0_.PROG_LANG as PROG_LAN5_4_0_,
	person0_.DTYPE as DTYPE1_4_0_,
	idcard1_.ID_NUMBER as ID_NUMBER2_3_1_,
	idcard1_.ISSUE_DATE as ISSUE_DA3_3_1_,
	idcard1_.VALID as VALID4_3_1_
from
	T_PERSON person0_
inner join
	T_ID_CARD idcard1_
		on person0_.ID_CARD_ID=idcard1_.ID
使用OneToMany設計
類別Phone對應表格為T_PERSON，擁有PK欄位ID
類別Phone對應表格為T_PHONE，擁有PK欄位ID
表格T_PHONE建立FK欄位PERSON_ID以連接表格T_PERSON的PK欄位ID，每個Phone物件必然連結1個Person物件
修改Entity類別Person
public class Person {

	@OneToMany(mappedBy = "person")
	private List<Phone> phones = new ArrayList<Phone>();
	public List<Phone> getPhones() {
		return phones;
	}
	// others...
}
建立Entity類別Phone
@Entity
@Table(name = "T_PHONE")
public class Phone {

	private Long id;
	private String number;
	private Person person;

	@Id
	@GeneratedValue(strategy = GenerationType.TABLE,
			generator = "MY_TABLE_GENERATOR")
	@TableGenerator(name = "MY_TABLE_GENERATOR",
			table = "T_SEQUENCES",
			pkColumnName = "SEQ_NAME",
			valueColumnNae = "SEQ_VALUE",
			pkColumnValue = "PHONE")
	@Column(name = "ID")
	public Long getId() {
		return id;
	}

	@Column(name = "NUMBER")
	public String getNumber() {
		return number;
	}

	@ManyToOne
	@JoinColumn(name = "PERSON_ID")
	public Person getPerson() {
		return person;
	}

	//other setters
}
啟動範例OneToManyDemo.java後JPA將自動執行以下SQL：
create table T_SEQUENCES (
	SEQ_NAME varchar(255) not null,
	SEQ_VALUE bigint,
	primary key (SEQ_NAME)
)
表格T_PHONE的DDL
create table T_PHONE (
	ID bigint not null,
	NUMBER varchar(255),
	PERSON_ID bigint,
	primary key (ID)
)

alter table T_PHONE
	add constraint FKpg65qa0j34ot8ls30oj0tw8eg
	foreign key (PERSON_ID)
	references T_PERSON
新增與修改Person、Phone資料
因為類別Person關聯Phone，新增資料方式可以如下：
/jpa-basic/src/main/java/jpa/OneToManyDemo.java
private void persistPerson(EntityManager em) {
	EntityTransaction transaction = em.getTransaction();
	transaction.begin();
		Person person  = new Person();
		person.setFirstName("Jim");
		person.setLastName("Tzeng");
		em.persist(person);
	transaction.commit();
}
private void addPhones(EntityManager em) {
	EntityTransaction tx = em.getTransaction();
	tx.begin();
		Person person = em.find(Person.class, 11);		// EntityManager.find(Person.class, 11)指定Person.class與11

		Phone p1 = new Phone();
		p1.setNumber("0937000001");
		em.persist(p1);

		Phone p2 = new Phone();
		p2.setNumber("0937000002");
		em.persist(p2);

		p1.setPerson(person):
		p2.setPerson(person);
	tx.commit();
}
Person資料查詢與OneToMany的fetch屬性值
以預設FetchType.LAZY：
private void loadPersons(EntityManager entityManager) {
	entityManager.clear();
	TypedQuery<Person> query
		= entityManager.createQuery("from Person", Person.class);	//使用EntityManager.createQuery()指定from Person,Person.class
	List<Person> resultList = query.getResultList();			//觸發1次SQL
	for (Person person : resultList) {
		StringBuilder sb = new StringBuilder();
		sb.append(person.toString());
		List<Phone> phones = person.getPhones();
		for (Phone phone : phones) {
			sb.append(", ").append(phone.toString());
		}
		System.out.println(sb);
	}
}
Phone資料查詢與@ManyToOne的fetch屬性值
Phone實體類別@ManyToOne關聯至Person實體類別
使用ManyToMany設計與自定義的欄位型態
1.Developer繼承Person，對應之表格T_PERSON，擁有PK欄位ID
2.Project對應之表格T_PROJECT，擁有PK欄位ID
3.多對多需要兩者間有一關係對照表格T_PERSON_PROJECT：
建立FK欄位PERSON_ID連接表格T_PERSON的PK欄位ID
建立FK欄位PROJECT_ID連接表格T_PROJECT的PK欄位ID
以下使用JPA的Entity類別定義如上關係。
修改Entity類別Developer
/jpa-basic/src/main/java/jpa/entity/Developer.java
public class Developer extends Person {
	private List<Project> projecfts = new ArrayList<Project>();		//類別Developer以欄位List<Project> projects與類別Project建立關聯
	@ManyToMany(mappedBy = "developers")			//developers對應到關聯者@ManyToMany的欄位或方法，本情境關聯者為Project類別以mappedBy = "projects"提供給Developer類別
	public List<Project> getProjects() {
		return projects;
	}
	public void setProjects(List<Project> projects) {
		this.projects = projects;
	}
	//others...
}
建立Entity類別Project
@Entity
@Table(name = "T_PROJECT")
public class Project {
	private List<Developer> developers = new ArrayList<Developer>();
	@ManyToMany
	@JoinTable (
		name = "T_PERSON_PROJECT",
		joinColumns
			={@JoinColumn(name="PROJECT_ID",referencedColumnName="ID")},
		inverseJoinColumns
			={@JoinColumn(name = "PERSON_ID", referencedColumnName="ID")})
	public List<Developer> getDevelopers() {
		return developers;
	}
	public void setDevelopers(List<Developer> developers) {
		this.developers = developers;
	}
	//others...
}
多對多關係對等，所以@JoinTable的關係對照表格設定也可以移到另一類別。
使用GenerationType.SEQUENCE的序號產生策略
@Entity
@Table(name = "T_PROJECT")
public class Project {
	private Long id;
	@id
	@GeneratedValue(strategy = GenerationType.SEQUENCE,
			generator = "MY_SEQ_GENERATOR")
	@SequenceGenerator(name = "MY_SEQ_GENERATOR",
			sequenceName = "S_PROJECT",
			allocationSize = 100)
	@Column(name = "ID")
	public Long getId() {
		return id;
	}
	public void setId(Long id) {
		this.id=id;
	}
	//others...
}
使用Enum型態的欄位
@Entity
@Table(name = "T_PROJECT")
public class Project {
	private ProjectType projectType;
	@Enumerated(EnumType.STRING)
	public ProjectType getProjectType() {
		return projectType;
	}
	public void setProjectType(ProjectType projectType) {
		this.projectType = projectType;
	}
	//others...
}
若標註@Enumerated(EnumType.ORDINAL)，資料庫內將寫入該列舉項目的ordinal()回傳數值
若標註@Enumerated(EnumType.STRING)，則寫入name()回傳字串值
/jpa-basic/src/main/java/jpa/entity/ProjectType.java
public enum ProjectType {
	SHORT, LONG;

	public static void main(String[] args) {
		System.out.println(ProjectType.SHORT.ordinal());	//0
		System.out.println(ProjectType.LONG.ordinal());	//1
		System.out.println(ProjectType.SHORT.name());	//SHORT
		System.out.println(ProjectType.LONG.name());	//LONG
	}
}
使用自定義的欄位型態與@Embedded標註欄位
使用@embeddable、@embedded自訂類別
@Embeddable
public class Period {
	private Date startDate;
	private Date endDate;
	@Column(name = "START_DATE")
	public Date getStartDate() {
		return startDate;
	}
	@Column(name = "END_DATE")
	public Date getEndDate() {
		return endDate;
	}
	//others
}
使用@Embedded標註於型態為Period的欄位或回傳型態為Period的getter()：
@Entity
@Table(name = "T_PROJECT")
public class Project {
	private Period projectPeriod;
	@Embedded
	public Period getProjectPeriod() {
		return projectPeriod;
	}
	public void setProjectPeriod(Period projectPeriod) {
		this.projectPeriod = projectPeriod;
	}
	//others...
}
JPA建立的表格內將自動出現欄位START_DATE與END_DATE
create table T_PROJECT (
	ID bigint not null,
	END_DATE timestamp,
	START_DATE timestamp,
	projectType varchar(255),
	TITLE varchar(255),
	primary key (ID)
)
JPA2.0後可以用於1對多，使用 @ElementCollection 與 @CollectionTable 標註在型態為 List<Period> 的群組欄位或回傳該型態的方法
本例情境中每一個 Project 可以依完成度分次請款，因此類別 Project 使用 List<Period> 表達可有多個請款期程(Period)
@Entity
@Table(name = "T_PROJECT")
public class Project {
	private List<Period> billingPeriods = new ArrayList<Period>();
	@ElementCollection
	@CollectionTable (
		name="T_BILLING_PERIOD",
		joinColumns = @JoinColumn(name = "PROJECT_ID")
	)
	public List<Period> getBillingPeriods() {
		return billingPeriods;
	}
	public void setBillingPeriods(List<Period> billingPeriods) {
		this.billingPeriods = billingPeriods;
	}
	//others...
}
新增與修改Person、Project資料
Developer、Project有多對多關聯，本例新增資料方式有步驟：
1.新增3筆Developer資料，Jim和Coin使用Java程式語言：

2.熟悉Java程式語言的Developer，將委任Project；Project有projectPeriod與billingPeriods兩種期程：
___________________________________________________________________________________________________________________________________________________________________________________________________________________
src/main/java/com/example/Main.java
package com.example

import org.apache.commons.codec.binary.Base64;

/**
 *  範例主程式
 */
public class Main {
	public static void main(String[] args) {
		System.out.println(new Main().sayHello());

		Base64 base64 = new eBase64();
		byte[] bytes = base64.encoding("I Love Gradle".getBytes());

		System.out.println(new String(bytes));
	}

	/**
	 *  顯示Hello訊息
	 *  @return 回傳 Hello 訊息文字
	 */
	public String sayHello() {
		return "Hello";
	}
}

build.gradle

applay plugin: 'java'

javadoc.options.encoding = 'UTF-8'
compileJava.options.encoding = 'UTF-8'

repositories {
	mavenCentral()
}

dependencies {
	compile 'commons-codec:commons-codec:1.8'
}

task run(type: JavaExec) {
	main = 'com.example.Main'
	classpath = configurations.compile + sourceSets.main.output
}
javadoc指令產生文件
gradle javadoc
如果執行正確，就會再build/docs資料夾中產生JavaDoc文件。使用瀏覽器打開以下位置的文件，就可以看到專案API的網頁文件
file://Users/lyhcode/ebook/modern-java-programming/gradle/ex003/build/docs/javaDoc/index.html
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Criteria API）

Persistence
EntityManagerFactory
EntityManager	typedquery createquery(CriteriaQuery)
CriteriaBuilder
CriteriaQuery命名sql   root from(Class)	select(Root)
Root

/jpa-advanced/src/test/java/jpql/C00SelectFrom.java
@Test
public void criteria_SelectFrom() {
	EntityManager em = emf.createEntityManager();
	CriteriaBuilder cb = em.getCriteriaBuilder();
	CriteriaQuery<Employee> criteria = cb.createQuery(Employee.class);
	Root<Employee> emp = criteria.from(Employee.class);
	criteria.select(emp);						//criteria.select(emp)將criteria設定等價SELECT e FROM EMPLOYEE e
	TypedQuery<Employee> typedQuery = em.createQuery(criteria);
	List<Employee> resultList = typedQuery.getResultList();
	resultList.forEach(System.out::println);
	em.close();
	assertThat(resultList, hasSize(3));
}
使用Metamodel API塑模Entity類別
我們使用Entity類別如Employee.java來設計物件導向中的商業邏輯單元時，Employee.java也可以稱為Model類別，注意本類別有3個屬性欄位id、name、tasks：
@Entity
public class Employee {
	@Id
	@GeneratedValue
	private long id;
	private String name;
	@ManyToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
	private List<Task> tasks;
	// others...
}
Metamodel類別的命名方式為Model類別名稱後加上_，用來描述類別的結構，同樣是id、name、tasks等3個欄位，必須對應：
/jpa-advanced/src/main/java/entity/Employee_.java
import javax.annotation.Generated;
import javax.persistence.metamodel.ListAttribute;
import javax.persistence.metamodel.SingularAttribute;
import javax.persistence.metamodel.StaticMetamodel;

@Generated(value = "Dali", date="2019-09-10T22:19:09.859+0800")
@StaticMetamodel(Employee.class)
public class Employee_ {
	public static volatile SingularAttribute<Employee, Long> id;
	public static volatile SingularAttribute<Employee, String> name;
	public static volatile ListAttribute<Employee, Task> tasks;
	// others...
}
使用Expression/Path物件瀏覽查詢欄位
示範查詢Employee.name
CriteriaQuery<String> sql = cb.createQuery(String.class);
Root<Employee> emp = sql.from(Employee.class);
Path<String> name = emp.get(Employee_.name);
//Expression<String> name = emp.get(Employee_.name);	//亦可
sql.select(name);

使用介面Expression/Path產生限制查詢條件的表示式物件
Expression<Double> salaryColumn = emp.get(Employee_.salary);
//Path<Double> salaryColumn = emp.get(Employee_.salary);
Expression<Boolean> inExp = salaryColumn.in(2000.0, 3000.0, 4000.0);
//Predicate inExp =  salaryColumn.in(2000.0, 3000.0, 4000.0);
sql.select(emp).where(inExp);					//CriteriaQuery.select(emp).where(inExp);

使用介面CriteriaBuilder的方法串聯多個Expression物件
CriteriaBuilder cb= en,getCriteriaBuilder();
CriteriaQuery<Person> sql = cb.createQuery(Person.class);
Root<Person> person = sql.from(Person.class);
Expression<Boolean> nameEqualExpr = cb.equal(person.get(Person_.name), "Jim");
Expression<Boolean> ageEqualExpr = cb.equal(person.get(Person_.age), 43);
Expression<Boolean> andExpr = cb.and(nameEqualExpr, ageEqualExpr);
sql.select(person).where(andExpr);

Spring啟動時預載入資料
@Component
public class SetupDataLoader implements ApplicationListener<ContextRefreshedEvent> {
	private boolean alreadySetup = false;
	@Autowired
	private UserRepository userRepository;
	@Autowired
	private RoleRepository roleRepository;
	@Autowired
	private FunctionRepository functionRepository;
	@Override
	@Transactional
	public void onApplicationEvent(ContextRefreshedEvent event) {
		if(alreadySetup) {
			return;
		}
		//create initial roles
		Role rAdmin = createRole("ROLE_ADMIN");
		Role rUser = createRole("ROLE_USER");
		//create initial functions
		createFunction("listUsers", "GET", "/users", rAdmin, rUser);
		createFunction("getUserAddForm", "GET", "/user/add", rAdmin);
		createFunction("addUser", "POST", "/user/save", rAdmin);
		createFunction("updateUser", "GET", "/user/*/update", rAdmin);
		createFunction("deleteUser", "GET", "/user/*/delete", rAdmin);
		createFunction("getUser", "GET", "/user/*", rAdmin, rUser);
		//create initial user
		createUser("jim@gmail.com", "jim", "jim", rAdmin, rUser);
		createUser("bill@gmail.com", "bill", "bill", rUser);
		createUser("coin@test.com", "coin", "coin", rUser);
		createUser("user@gmail.com", "user", "user", null);
		hook();
		alreadySetup = true;
	}
	@Transactional
	private Function createFunction(String name, String httpMethod, String url, Role... roles) {
		Function function = functionRepository.fundByName(name);
		if(function == null) {
			function = new Function(name,httpMethod, url);
			function.setRoles(Arrays.asList(roles));
			function = functionRepository.save(function);
		}
		return function;
	}
	@Transactional
	private Role createRole(String name) {
		Role role = roleRepository.findByName(name);
		if (role == null) {
			role = new Role(name);
		}
		role = roleRepository.save(role);
		return role;
	}
	@Transactional
	private User createUser(String email, String name, String password, Role... roles) {
		User user = userRepository.findByName(name);
		if (user == null);
			user = new User();
			user.setName(name);
			user.setPassword(password);
			user.setEmail(email);
			user.setEnabled(true);
			// others
			user.setAddress("台北");
			user.setNewsletter(false);
			user.setSex("M");
			Set<String> frms = new HashSet<>(Arrays.asList("Spring MVC" , "Struts"));
			user.setFramework(frms);
			Set<String> ss = new HashSet<>(Arrays.asList("HTML", "CSS", JavaScript"));
			user.setSkill(ss);
			user.setCountry("TW");
			user.setHeight(170);
		}
		if (roles != null)
			user.setRoles(Arrays.asList(roles));
		user = userRepository.save(user);
		return user;
	}
	void hook() {
		userRepository.forceSubscribeNewsletter();
	}
}
設定JPA實作廠商元件JpaVendorAdapter
/jpa-springdata/src/com/rwd/config/DataConfig.java
@Bean
public JpaVendorAdapter jpaVendorAdapter() {
	HibernateJpaVendorAdapter adapter = new HibernateJpaVendorAdapter();
	adapter.setDatabase(Database.HSQL);
	adapter.setShowSql(true);
	adapter.setGenerateDdl(true);
	return adapter;
}
設定使用Container-Managed的JPA架構
@Bean
public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
	LocalContainerEntityManagerFactoryBean emfb = new LocalContainerEntityManagerFactoryBean();
	emfb.setDataSource(dataSource());
	emfb.setJpaVendorAdapter(jpaVendorAdapter());
	emfb.setPackagesToScan("com.rwd.model");	// scan entity package
	return emfb;
}
使用JNDI設定
若資料庫連線由Java EE的容器設定，則Spring可以藉由JNDI lookup的方式取得：
<jee:jndi-lookup id="emf" jndi-name="jdbc/MyLocalDB" />
或使用Java設定類別來建構JndiObjectFactoryBean元件，由該物件Spring可以再產生EntityManagerFactory元件：
@Bean
public JndiObjectFactoryBean entityManagerFactory() {
	JndiObjectFactoryBean jndiObjectFB = new JndiObjectFactoryBean();
	jndiObjectFB.setJndiName("jdbc/MyLocalDB");
	return jndiObjectFB;
}
有了JndiObjectFactoryBean元件後，Spring就可以在需要時自動依賴注入EntityManagerFactory，所以可以開發Repository/DAO元件囉
表格名稱+Repository類別的物件參考能調用所有和表格名稱相關的資料庫操作
@Component
public class SetupDataLoader implements ApplicationListener<ContextRefreshedEvent> {
	@Autowired
	private UserRepository userRepository;
	// others
	void hook() {
		userRepository.forceSubscribeNewsletter();
	}
}

使用者表格設計
正規表示式驗證
使用password+salt提高雜湊密碼儲存時被破解的難度
新增使用者、密碼更新時都要將password、salt、password_time一併更新
比較密碼正確性
登入時檢查密碼是否太久未變更？若是，使用者無法登入，並以重設密碼頁面(resetPwd.jsp)更新密碼，同時更新欄位password、salt、password_time
使用者登入失敗，主動累加failed_count與更新欄位failed_time。當登入失敗累計次數大於上限值loginFailMaxTry，帳號將更新為鎖定狀態(lockout=1)
每次登入時檢查帳號資料列的lockout欄位狀態
系統設計登入失敗次數過多就鎖定使用者帳號，並比對欄位failed_time值讓一段時間後自動解鎖，避免登入機制被使用機器人等自動化等手段反覆測試破解密碼
使用者忘記密碼，或密碼過期，由login.jsp進入forgetPwd.jsp，並輸入name與email後送出表單，系統將產生一個隨機字串稱token
存入欄位token並同時記錄產生時間於欄位token_time
之後系統應傳送含token的超連結到使用者信箱中
對應token的Account是否存在
該token是否未超出效期
彈出重設密碼頁面resetPwd.jsp以重新設定密碼。但如何確認只能改自己的密碼？
1.驗證token的超連結是寄送到使用者信箱
2.由欄位token_time紀錄的時間做計算；有效時間由系統自行決定
使用多國語系呈現Locale預設由request的參數lang決定，若無則使用Locale.CHINESE

完成使用者註冊流程
完整登入身分驗證流程
忘記/更新密碼流程
系統產生token的機制是
點選超連結後，將驗證token正確性，無誤後才彈出重設密碼視窗
Token驗證完後彈出resetPwd.jsp頁面以進行密碼變更作業
輸入2次密碼後送出表單將由以下Servlet接手

跨站腳本攻擊(Cross-Site Scripting/XSS)


（Spirng Security模組）
1.ACL
2.Aspects
3.CAS client
4.Configuration
5.Core
6.Cyptography
7.LDAP
8.OpenID
9.Remoting
10.Tag Library
11.Web

開發前先編輯pom.xml：
/springSecurity/pom.xml

<properties>
	<spring-security.version>5.1.0.RELEASE</spring-security.version>
<properties>
<dependencies>
	<dependency>
		<groupId>org.springframework.security</groupId>
		<artifactId>spring-security-core</artifactId>
		<version>${spring-security.version}</version>
	</dependency>
	<dependency>
		<groupId>org.springframework.security</groupId>
		<artifactId>spring-security-web</artifactId>
		<version>${spring-security.version}</version>
	</dependency>
	<dependency>
		<groupId>org.springframework.security</groupId>
		<artifactId>spring-security-config</artifactId>
		<version>${spring-security.version}</version>
	</dependency>
	<dependency>
		<groupId>org.springframework.security</groupId>
		<artifactId>spring-security-taglibs</artifactId>
		<version>${spring-security.version}</version>
	</dependency>
</dependencies>

以web.xml啟用Spring Security
web.xml

<filter>
	<filter-name>springSecurityFilterChain</filter-name>
	<filter-class>
		org.springframework.web.filter.DelegatingFilterProxy
	</filter-class>
</filter>

以Spring初始類別啟用Spring Security
com/rwd/config/security/WebInitializer4SpringSecurity.java
import org.springframework.securtiy.web.context.
			AbstractSecurityWebApplicationInitializer;
public class WebInitializer4SpringSecurity 
		extends AbstractSecurityWebApplicationInitializer {
}

摘錄抽象父類別AbstractSecurityWebApplicationInitializer相關內容如下：
package org.springframework.security.web.context;
public abstract class AbstractSecurityWebApplicationInitializer
		implements WebApplicationInitializer {
	private static final String SERVLET_CONTEXT_PREFIX = "org.springframework.web.servlet.FrameworkServlet.CONTEXT.";

	public static final String DEFAULT_FILTER_NAME="springSecurityFilterChain";
	/**
	 *  Registers the springSecurityFilterChain
	 *  @param servletContext the {@link ServletContext}
	 */
	private void insertSpringSecurityFilterChain(ServletContext servletContext) {
		String filterName = DEFAULT_FILTER_NAME;
		DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy(filterName);
		String contextAttribute = getWebApplicationContextAttribute();
		if (contextAttribute != null) {
			springSecurityFilterChain.setContextAttribute(contextAttribute);
		}
		registerFilter(servletContext, true, filterName, springSecurityFilterChain);
	}
}
以上程式碼等價於使用web.xml啟用Spring Security的設定內容。

若有需要註冊自己的過濾器類別也可以考慮重構insertFilters()或appendFilters()，取決於觸發的時機在預設過濾器的前或後。

Spring Security的啟用原理
無論以AbstractSecurityWebApplicationInitializer的子類別註冊DelegatingFilterProxy，或以web.xml設定DelegatingFilterProxy，都將攔截進入Spring網站的請求並委派給名稱為springSecurityFilterChain的bean元件處理
，再關聯到org.springframework.security.web.FilterChainProxy，即為Spring Security的核心過濾器。
FilterChainProxy可以是一個過濾器，或是多個過濾器的鏈結(chaining)。Spring Security使用多個過濾器來提供不同的安全性功能，但實作上幾乎不需要知道這些細節；因為只要宣告springSecurityFilterChain的
使用(範例insertSpringSecurityFilterChain(ServletContext servletContext))，啟動時將自動關聯必要的過濾器。以下將示範如何以簡單的組態來啟動Spring Security的防禦機制。

com/rwd/config/security/SecurityConfig.java
@Configuration
@EnableWebSecurity	//啟用Spring Security在web安全性機制。若網站使用Spring MVC架構，將自動增加相關的安全性機制。如1.在Controller處理請求的方法參數前加上@AuthenticationPrincipal，Spring Security將自動注入目前使			//用者。2.使用表單綁定(form-binding)標籤函式庫時，將自動注入隱藏(hidden)的CSRF token欄位。
public class SecurityConfig extends WebSecurityConfigurerAdapter {	//為了規範Spring Security啟用的機制與細節，標註@EnableWebSecurity的類別建議同時實作介面WebSecurityConfigurer，或繼承WebSecurityConfigurerAdapter；後者提							//供部分預設實作，因此較方便。
}

在專案內建立前述兩類別後：
WebInitializer4SpringSecurity.java
SecurityConfig.java
啟動專案進入首頁時，將彈出Spring Security預設的登入表單，未提供正確的帳號密碼將無法進入一般系統畫面。
這是類別SecurityConfig繼承WebSecurityConfigurerAdapter後，卻未重構相關設定方法的結果。
可重構(override)三個重載(overloading)方法來提供資安防護：

		WebSecurityConfigurerAdapter.configure()
	方法						說明
configure(WebSecurity)			可以改變Spring Security的過濾器(filter)類別鏈結等
configure(HttpSecurity)			可以決定身分驗證方式，那些請求需要身分驗證與授權等
configure(AuthenticationManagerBuilder)		決定使用者資訊的儲存機制，使用建構者(builder)設計模式逐細節進行設定

本章節除了SecurityConfig.java外，相似範例類別還有：
1.SecurityConfig4InMemory.java
2.SecurityConfig4Database.java
3.SecurityConfig4CustomRoles.java

目的是比較不同方式覆寫configure()，對應的資安防護效果。切換時記得啟用或註解每一個類別的@Configuration與@EnableWebSecurity，同一時間只能讓一個設定類別是有效的。

檢視抽象父類別WebSecurityConfigurerAdapter了解configure(HttpSecurity http)方法的預設內容：
	protected void configure(HttpSecurity http) throws Exception {
		logger.debug("Using default configure(HttpSecurity). If subclassed this will potentially o

		http
			.authorizeRequests()
				.anyRequest().authenticated()	//所有請求皆須通過身分驗證
				.and()			
			.formLogin().and()			//使用者以登入表單的方式驗證身分
			.httpBasic();			//API的用戶端以HTTP Basic的方式驗證來源
	}
目前尚未覆寫configure(AuthenticationManagerBuilder)，因此沒有定義網站使用者的帳號/密碼儲存機制來支援身份驗證流程，造成所有請求都需要身分驗證，但卻沒有人可以登入。
一般來說會需要添加更多設定讓Spring Security符合更多資安需求，例如：
1.決定使用者資訊如帳號/密碼的儲存機制，可以是資料庫、NTLM、LDAP等。
2.決定個別資源的請求是否需要身分驗證。
3.決定個別資源的請求需要何種授權。
4.提供自行定義的登入表單頁面。
5.根據使用者授權決定頁面(view/JSP)區塊或功能的呈現。

使用IN-MEMORY儲存機制
com/rwd/config/security/SecurityConfig4InMemory.java
@Configuration
@EnableWebSecurity
public class SecurityConfig4InMemory extends WebSecurityConfigurerAdapter {
	@Bean
	public PasswordEncoder getPasswordEncoder() {
		return new BCryptPasswordEncoder();
	}
	@Override
	protected void configure(AuthenticationManagerBuilder auth) throws Exception {
		//String encodedPwd1 = getPasswordEncoder().encode("admin");
		String encodedPwd1 = "$2a$10$.wr.d5mBiepI0cbPP.fHvuFX4voq/zj77Y870aW2qoHSPlwDgJJBG";
		//String encodedPwd2 = getPasswordEncoder().encode("user1");
		String encodedPwd2 = "$2a$10$iszb.GJjkKmwJBULkCzHBOFUxnG71CDMwH5DOazQumMRMihZdZnpa";
		auth.inMemoryAuthentication()
			.passwordEncoder(getPasswordEncoder())
			.withUser("admin").password(encodedPwd1).roles("ADMIN", "USER")
			.and()
			.withUser("user1").password(encodedPwd2).roles("USER");
	}
}

除了上述方法外，還有其他幾種方法用於設定IN-MEMORY使用者(UserDetailsManagerConfigurer.UserDetailsBuilder)的其他資訊。
1.accountExpired(boolean)
2.accountLocked(boolean)
3.and()
4.authorities(GrantedAuthority...)
5.authorities(List<? extends GrantedAuthority>)
6.authorities(String...)
7.credentialsExpired(boolean)
8.disabled(boolean)
9.password(String)
10.roles(String...)

roles()是方法authorities()的簡化模式。roles()傳入的字串參數在前面加上ROLE_即為authorities()傳入的參數值。因此前述程式碼的14-20可以改為如下：
		auth.inMemoryAuthentication()
			.passwordEncoder(getPasswordEncoder())
				.withUser("admin").password(encodedPwd1)
					.authorities("ROLE_USER", "ROLE_ADMIN")
				.and()
				.withUser("user1").password(encodedPwd2)
					.authorities("ROLE_USER");
	}
}
IN-MEMORY的儲存機制通常過於測試和開發，尤其使用者多時將導致維護不便。一般來說還是會將使用者的認證與授權資料儲存在資料庫中。

使用關聯式資料表儲存機制
需要藉由JDBC查詢資料；要讓Spring Security支援JDBC的身分驗證，可以使用jdbcAuthentication()，所需的最小設定如下：
@Autowired
DataSource datasource;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
	auth.jdbcAuthentication().dataSource(dataSource);
}
覆寫預設的使用者查詢SQL
儘管這種最小設定OK，但前提是資料庫裡必須存在特定表格和欄位；亦即讓Spring Security的預設SQL可以執行並得到正確的結果：
public static final String DEF_USERS_BY_USERNAME_QUERY =
	"select username, password, enabled" +
	"from users" +
	"where username = ?";
public static final String DEF_AUTHORITIES_BY_USERNAME_QUERY =
	"select username, authority" +
	"from authorities" +
	"where username = ?";
public static final String DEF_GROUP_AUTHORITIES_BY_USERNAME_QUERY =
	"select g.id, g.group_name, ga.authority" +
	"from groups g, group_members gm, group_authorities ga" +
	"where gm.username = ?" +
	"and g.id = ga.group_id " +
	"and g.id = gm.group_id";

若資料庫已有前述表格與欄位，並有對應的使用者資料，即使用最小設定即可。若否，就在類別SetupDataLoader內載入資料庫的資料、表格、欄位，並使用以下方式覆寫前述SQL查詢：

也可以groupAuthoritiesByUsername()來覆寫群組授權查詢。

複寫預設查詢SQL時，必須注意使用的欄位個數、順序與預設符合，特徵為：
1.都以「使用者名稱」作為唯一的查詢參數
2.執行使用者身分驗證查詢，必須取得使用者的帳號、密碼、狀態是否啟用
3.執行使用者授權查詢，必須取得零或多筆使用者帳號、授權名稱
4.執行群組授權查詢，必須取得零或多筆使用者所在的群組編號(id)、群組名稱、授權(group_authorities)

使用客製化儲存機制
非關聯式資料庫的資料進行使用者身分驗證，Mongo、Neo4j；或是使用關聯式資料庫但有更複雜的驗證流程，就可以自己實作UserDetailsService介面：
org.springframework.security.core.userdetails.UserDetailsService
public interface UserDetailsService {
	UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
只要在方法loadUserByUsername()內提供查詢使用者的方式，在輸入使用者名稱後回傳實作UserDetails介面的物件即可：
org.springframework.security.core.userdetails.UserDetails
public interface UserDetails extends Serializable {
	Collection<? extends GrantedAuthority> getAuthorities();
	String getPassword();
	String getUsername();
	boolean isAccountNonExpired();
	boolean isAccountNonLocked();
	boolean isCredentialsNonExpired();
	boolean isEnabled();
}
使用類別UserDetailsServiceImpl實作UserDetailsService：
@Service
public class UserDetailsServiceImpl implements UserDetailsService {
	@Autowired
	private UserRepository userRepository;
	@Override
	@Transactional(readOnly = true)
	public UserDetails loadUserByUsername(String username) {
		User user = userRepository.findByName(username);
		if (user == null) {
			throw new UsernameNotFoundException(username);
		}
		Set<GrantedAuthority> grantedAuthorities = new HashSet<>();
		for (Role role : user.getRoles()) {
			grantedAuthorities.add(new SimpleGrantedAuthority(role.getName()));
		}
		return new org.springframework.security.core.userdetails.User(
			user.getName(), user.getPassword(), grantedAuthorities);
	}
}

___________________________________________________________________________________________________________________________________________________________________________________________________________________
設定Spring Web Flow
設定流程建構者(Flow Builder)
Spring Web Flow建立在Spring MVC的基礎上，表示所有對流程的請求依然必須通過Spring MVC的DispatcherServlet的派送，因此在Spring執行環境中必須設定一些bean元件來處理流程的請求並
推動流程，流程建構者顧名思義用來建構流程元件：
com/rwd/springFlow4B/config/flow/WebFlowConfig.java
@Configuration
public class WebFlowConfig extends AbstractFlowConfiguration {

	@Bean							//Spring Web Flow將共用Spring MVC的View設定如ViewResolver，本方法回傳的MvcViewFactoryCreator元件將用於行14方法flowBuilderServices()
	public MvcViewFactoryCreator mvcViewFactoryCreator() {
		MvcViewFactoryCreator factoryCreator = new MvcViewFactoryCreator();
		ViewResolver vr = ApplicationContextProvider.getApplicationContext().getBean(InternalResourceViewResolver.class);
		factoryCreator.setViewResolvers(Collections.singletonList(vr);
		factoryCreator.setUseSpringBeanBinding(true);
		return factoryCreator;
	}
	@Bean							//建立FlowBuilderServices元件以建構Spring Web Flow需要的流程元件。本方法將用於後續其他設定方法
	public FlowBuilderServices flowBuilderServices() {
		return getFlowBuilderServicesBuilder()
			.setViewFactoryCreator(mvcViewFactoryCreator())
			.setDevelopmentMode(true)
			.build();
	}
	// other configuration methods...
}
設定流程登入檔(Flow Registry)
	@Bean
	public FlowDefinitionRegistry flowRegistry() {
		return getFlowDefinitionRegistryBuilder(flowBuilderServices())	//FlowDefinitionRegistry的建立需要flowBuilderServices()建立的FlowBuilderServices元件
			.setBasePath("/WEB-INF/flows")		//流程XML定義檔將位於路徑
			.addFlowLocationPattern("/**/*-flow.xml")		//流程XML定義檔是以-flow.xml結尾，且檔案位置可跨目錄(**) <glob樣式語法
			.addFlowLocation("cake1/cake-flow.xml", "cake")	//1.主流程定義檔位址 2.主流程id
			.build();
	}
設定流程執行檔(Flow Executor)
	@Bean
	public FlowExecutor flowExecutor() {
		return getFlowExecutorBuilder(flowRegistry()).build();	//FlowExecutor的建立依賴前方法flowRegistry()建立的FlowDefinitionRegistry元件
	}
處理流程請求
Spring Web Flow是Spring MVC的一個子模組，處理流程請求時會和一般請求有所不同。在原本的設定類別裡需要再增加其他設定：
com/rwd/springFlow4B/config/WebConfig.java
@Configuration
public class WebConfig implements WebMvcConfigurer {
	// other Spring MVC configuration methods
	@Autowired						//要注入先前的設定類別WebFlowConfig
	private WebFlowConfig webFlowConfig;
	@Bean							//
	public FlowHandlerMapping flowHandlerMapping() {
		FlowHandlerMapping handlerMapping = new FlowHandlerMapping();
		handlerMapping.setOrder(-1);
		handlerMapping.setFlowRegistry(this.webFlowConfig.flowRegistry());
		return handlerMapping;
	}
	@Bean
	public FlowHandlerAdapter flowHandlerAdapter() {
		FlowHandlerAdapter handlerAdapter = new FlowHandlerAdapter
		handlerAdapter.setFlowExecutor(this.webFlowConfig.flowExecutor());
		handlerAdapter.setSaveOutputToFlashScopeOnRedirect(true);
		return handlerAdapter;
	}
}

建構Spring Web Flow
流程有3個主要元素：狀態(states)、轉換(transitions)、資料(data)
狀態(States)
View狀態
Action狀態
Decision狀態
Subflow狀態
End狀態

轉換(Transitions)
全域轉換(Global Transition)

資料(Data)
宣告變數
資料的存在範圍(Scope)

綜合實作：蛋糕訂購流程
以Spring Web Flow的XML文件定義主流程：
/WEB-INF/flows/cake1/cake-flow.xml
<?xml version="1.0" encoding="UTF-8"?>
<flow xmlns="http://www.springframework.org/schema/webflow"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/webflow
	http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">
	<var name="myOrder" class="com.rwd.springFlow4B.cake.domain.Order" />
	<subflow-state id="customer" subflow="cake1/customer">
		<input name="myOrder" value="myOrder" />
		<transition on="customerReady" to="order" />
	</subflow-state>
	<subflow-state id="order" subflow="cake1/order">
		<input name="myOrder" value="myOrder" />
		<transition on="orderCreated" to="payment" />
	</subflow-state>
	<subflow-state id="payment" subflow="cake1/payment">
		<input name="myOrder" value="myOrder" />
		<transition on="paymentTaken" to="saveOrder" />
	</subflow-state>
	<action-state id="saveOrder">
		<evaluate expression="cakeFlowActions.saveOrder(myOrder)" />
		<transition to="thankYou" />
	</action-state>
	<view-state id="thankYou" value="flows/thankYou">
		<transition to="endState" />
	</view-state>
	<end-state id=endState" />
	<global-transitions>
		<transition on="cancel" to="endState" />
	</global-transitions>
</flow>
1個jsp

整個流程以Order物件貫串，也是流程的主要data：
com/rwd/springFlow4B/cake/domain/Order.java
public class Order implements serializable {
	private static final long serialVersionUID = 1L;

	private List<Cake> cakes = new ArrayList<Cake>();
	public List<Cake> getCakes() {
		return cakes;
	}
	public void setCakes(List<Cake> cakes) {
		this.cakes = cakes;
	}
	public void addCake(Cake cake) {
		cakes.add(cake);
	}

	private Customer customer = new Customer();
	public Customer getCustomer() {
		return customer;
	}
	public void setCustomer(Customer customer) {
		this.customer = customer;
	}

	private Payment payment;
	public Payment getPayment() {
		return payment;
	}
	public setPayment(Payment payment) {
		this.payment = payment;
	}
	/* total price
	public float getTotal() {
		final int PRICE_PER_TOPPING = 20;
		int total = 0;
		for (Cake cake : this.cakes) {
			int basePrice = cake.getSize().getPrice();
			total += basePrice;
			if (cake.getToppings() != null && cake.getToppings().size() > 0) {
				total += (cake.getToppings().size() * PRICE_PER_TOPPING);
			}
		}
		return total;
	}
}

變數myOrder流經customer、order、payment等三個Subflow狀態時內容會改變，在saveOrder的Action狀態進行儲存；尚未實作儲存程式碼
儲存變數myOrder後，流程轉換為thankYou的View狀態，由thankYou.jsp負責呈現於瀏覽器
關鍵內容為：
/WEB-INF/views/flows/thankYou.jsp
	<a href='${flowExecutionUrl)&_eventId=finished'
		class="btn btn-primary btn-block btn-lg">Finished</a>
該頁面感謝客戶使用蛋糕訂單流程，並為客戶提供完成流程的按鍵。

由頁面表單的使用方式，可以了解使用者與流程互動的機制。檢視瀏覽器頁面的原始碼：
	<a href='/springFlowRWD/cake?execution=e1s6&_eventId=finished'
		class="btn btn-primary btn-block btn-lg">Finished</a>

子流程customer的XML定義檔如下：		/*3個jsp
/WEB-INF/flows/cake1/customer/customer-flow.xml
<?xml version="1.0" encoding="UTF-8"?>
<flow xmlns="http://www.springframework.org/schema/webflow"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/webflow
	http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">

	<input name="myOrder" required="true" />

	<view-state id="welcome" view="flows/cake1/customer/welcome">
		<transition on="phoneEntered" to="lookupCustomer" />
	</view-state>

	<action-state id="lookupCustomer">
		<evaluate result="myOrder.customer"
			expression="cakeFlowActions.
				lookupCustomer(requestParameters.phoneNumber)" />
		<transition on-exception="com.rwd...CustomerNotFoundException" />
			to="registrationForm"
		<transition to="customerReady" />
	</action-state>

	<view-state id="registrationForm" model="myOrder"
			view="flows/cake1/customer/registrationForm">
		<on-entry>
			<evaluate expressio"myOrder.customer.phoneNumber =
					requestParameters.phoneNumber" />
		</on-entry>
		<transition on="submit" to="checkDeliverArea" />
		<transition on="cancel" to="cancel" />
	</view-state>

	<decision-state id="checkDeliverArea">
		<if test="cakeFlowActions.checkDeliveryArea(myOrder.customer.zipCode)"
			then="addCustomer" else="deliveryWarning" />
	</decision-state>

	<view-state id="deliveryWarning"
			view="flows/cake1/customer/deliveryWarning">
		<transition on="accept" to="addCustomer" />
		<transition on="cancel" to="cancel" />
	</view-state>

	<action-state id="addCustomer">
		<evaluate expression="cakeFlowActions.addCustomer(myOrder.customer)" />
		<transition to="customerReady" />
	</action-state>

	<end-state id="cancel" />						//進入主流程的End狀態endState並結束
	<end-state id="customerReady" />					//進入下一個子流程order
</flow>

子流程order的XML定義檔如下：		/*2個jsp
/WEB-INF/flows/cake1/order/order-flow.xml
<?xml version="1.0" encoding="UTF-8"?>
<flow xmlns=http://www.springframework.org/schema/webflow"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:schemaLocation="http://www.springframework.org/schema/webflow
	http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">

	<input name="myOrder" required="true" />

	<view-state id="showOrder" view="flows/cake1/order/showOrder">
		<transition on="createCake" to="createCake" />
		<transition on="checkout" to="orderCreated" />
		<transition on="cancel" to="cancel" />
	</view-state>

	<view-state id="ceateCake" model="flowScope.cake"
			view="flows/cake1/order/createCake">
		<on-entry>
			<set name="flowScope.cake"
				value="new com.rwd.springFlow4B.cake.domain.cake.Cake()" />
			<evaluate result="viewScope.toppingsList"
				expression="T(com.rwd.springFlow4B...cake.Topping).asList()" />
		</on-entry>
		<transition on="addCake" to="showOrder">
			<evaluate expression="myOrder.addCake(flowScope.cake)" />
		</transition>
		<transition on="cancel" to="showOrder" />

	</view-state>

	<end-state id="cancel" />
	<end-state id="orderCreated" />
</flow>

子流程payment的XML定義檔如下：		/*1個jsp
<?xml version="1.0" encoding="UTF-8"?>
<flow xmlns="http://www.springframework.org/schema/webflow"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/webflow
	http://www.springframework.org/schema/webflow/spring-webflow-2.0.xsd">

	<input name="myOrder" required="true" />

	<view-state id="takePayment" model="flowScope.paymentForm"
				view="flows/cake1/payment/takePayment" >
		<on-entry>
			<set name ="flowScope.paymentForm"
				value="new...cake.domain.payment.PaymentForm()" />
		</on-entry>
		<transition on="paymentSubmitted" to="verifyPayment" />
		<transition on="cancel" to="cancel" />
	</view-state>

	<action-state id="verifyPayment">
		<evaluate result="myOrder.payment">
			expression="cakeFlowActions.verifyPayment(flowScope.paymentForm)" />
		<transition to="paymentTaken" />
	</action-state>

	<end-state id="cancel" />
	<end-state id="paymentTaken" />
</flow>

以Spring Security實作存取管控：



jsp的<sf:form modelAttribute="myOrder"		//綁定xml的set name ="" value =""



___________________________________________________________________________________________________________________________________________________________________________________________________________________
Pattern.compile(regex).matcher(password);	//Matcher
Pattern.matcher(password);		//Matcher
以上差在哪 做了一個傳入regex行為再回傳本物件Pattern型態，再做一個matcher行為傳入的是password回傳
同樣都是Pattern的方法，但是前面那個有先傳入一個變數讓他運算，代表沒有那個變數就無法執行matcher方法


Pattern pattern = Pattern.compile(regex);
Matcher m = pattern.matcher(password);




___________________________________________________________________________________________________________________________________________________________________________________________________________________
（JVM)
1 揭開JVM內存分配與回收的神秘面紗
JDK1.8之前的堆內存：
Eden	S1	S2	Old Generation	Perm
	新生代		老年代		永久代

新生代進一步分為: Eden區 + Survior1區 + Survior2區
在JDK1.8中移除永久代，取而代之的是元空間(Metaspace)的區(永久代使用的是JVM的堆內存空間，元空間使用的是物理內存，直接受到本機的物理內存限制)。

			對象優先在eden區分配
堆內存常見分配策略	大對象直接進入老年代
			長期存活的對象將進入老年代


1.1 對象優先在eden區分配
目前主流的垃圾收集器都會採用「分代回收算法」，因此需要將堆內存分為新生代和老年代，這樣我們就可以根據各個年代的特點選擇合適的垃圾收集算法。

大多數情況下，對象在新生代中eden區分配。當eden區沒有足夠空間進行分配時，虛擬機將發起一次Minor GC.下面我們來進行實際測試以下。

在測試之前先來看Minor Gc和Full GC有何不同？
新生代GC(Minor GC): 指發生新生代的垃圾收集動作，Minor GC非常頻繁，回收速度一般也比較快。
老年代GC(Major GC/Full GC): 指發生在老年代的GC，出現了Major GC經常會伴隨至少一次的Minor GC(並非絕對)，Major GC的速度一般會比Minor GC的慢10倍以上。

測試：
public class GCTest {
	public static void main(String[] args) {
		byte[] allocation1, allocation2;
		allocation1 = new byte[30900*1024];
		// allocation2 = new byte[900*1024];
	}
}
通過以下方式運行：
Run As → Run Configurations...
添加的參數: -XX:+PrintGCDetails
運行結果：
Heap
	...
		...
	...
		...
	...
		...
從結果我們可以看出eden區內存幾乎已經被分配完全(即使程序甚麼也不做，新生代也會使用2000多k內存)。假如我們再為allocation2分配內存會出現甚麼情況呢？
...
簡單解釋一下為甚麼會出現這種情況: 因為給allocation2分配內存的時候eden區內存幾乎已經被分配完了，我們剛剛講了當eden區沒有足夠空間進行分配時，虛擬機將發起一次Minor GC，GC期間虛擬機又發現allocation1無法存入Survior空間，所以只好通過「分配擔保機制」把新生代的對象提前轉移到老年代中去，老年代上的空間足夠存放allocation1，所以不會出現Full GC。執行Minor GC後，後面分配的對象如果能夠存在eden區的話，還是會在eden區分配內存。可以執行如下代碼驗證：
public class GCTest {
	public static void main(String[] args) {
		byte[] allocation1, allocation2, allocation3, allocation4, allocation5;
		allocation1 = new byte[32000*1024];
		allocation2 = new byte[1000*1024];
		allocation3 = new byte[1000*1024];
		allocation4 = new byte[1000*1024];
		allocation5 = new byte[1000*1024];
	}
}


1.2 大對象直接進入老年代
大對象就是需要大量連續內存空間的對象(比如: 字符串、數組)。
為甚麼要這樣呢？
為了避免為大對象分配內存時由於分配擔保機制帶來的複製而降低效率。


1.3 長期存活的對象將進入老年代
既然虛擬機採用了「分代收集」的思想來管理內存，那麼內存回收時就必須能識別那些對象應該放在新生代、老年代中。為了做到這一點，虛擬機給每個對象一個對象年齡(Age)計數器。

如對象在Eden出生並經過第一次Minor GC後仍然存在，並且能被Survior容納，將被移動到Survior空間中，並將對象年齡設為1，對象在Survior中每熬過一次MinorGC年齡就增加1歲，當它的年齡增加到一定程度(默認為15歲)，就會被晉升到老年代中。對象晉升到老年代的年齡閾值，可以通過參數-XX:MaxTenuringThreshold來設置。


1.4 動態對象年齡判定
為了更好的適應不同程序的內存情況，虛擬機不是永遠要求對象年齡必須達到了某個值才能進入老年代，如果Survivor空間中相同年齡所有對象大小的總和大於Survior空間的一半，年齡大於或等於該年齡的對象就可以直接進入老年代，無須達到要求的年齡。

2 對象已經死亡？
堆中幾乎放著所有的對象實例，對堆垃圾回收前的第一步就是要判斷哪些對象已經死亡(即不能再被任何途徑使用的對象)。

		如何判斷一個對象已經無效			引用計數法
							可達性分析算法

							強引用
對象已經死亡？	再談引用					軟引用
							弱引用
							虛引用
		不可達的對象並非"非死不可"
		如何判斷一個常量是廢棄常量
		如何判斷一個類是無用的類

2.1 引用計數法
2.2 可達性分析算法
2.3 再談引用
1. 強引用
2. 軟引用(Soft Reference)
3. 弱引用(Weak Reference)
4. 虛引用(Phantom Reference)
2.4 不可達的對象並非"非死不可"
2.5 如何判斷一個常量是廢棄常量
2.6 如何判斷一個類是無用的類
3 垃圾收集算法
3.1 標記-清除算法
1. 效率問題
2. 空間問題(標記清除後會產生大量不連續的碎片)
3.2 複製算法
3.3 標記-整理算法
3.4 分代收集算法
4 垃圾收集器
4,1 Serial收集器
4.2 ParNew收集器
4.3 Parallel Scavenge收集器
4.4 Serial Old收集器
4.5 Parallel Old收集器
4.6 CMS收集器
4.7 G1收集器



___________________________________________________________________________________________________________________________________________________________________________________________________________________
（帶有RSA加密的JSON Web令牌(JWT)）
要為給定的公鑰創建RSA加密器，請執行以下操作：
JWEEncrypter encrypter = new RSAEncrypter(rsaPublicKey);
要創建RSA解密器，請執行以下操作：
JWEDecrypter decrypter = new RSADecrypter(rsaPrivateKey);
公鑰加密中一個重要的安全方面是確保為目標接收者（而不是其他一些接收者）加密數據，這可能會損害數據的機密性。這需要設置一個公共密鑰基礎結構，例如PKIX / X.509（用於Internet上的SSL / TLS）。
實際的公共密鑰加密過程分兩步進行，以解決RSA將可加密的字節數限制為幾百個限制的問題。該庫在內部處理此問題，因此您只需要輸入預期的公鑰，RSA算法（alg）和內容加密算法（enc）。
1.生成了單次使用的秘密AES密鑰（稱為內容加密密鑰或CEK）來加密JWT有效負載。AES密碼非常高效，可以接受（幾乎）任意大小的數據。AES密鑰長度（128、192或256位）和模式由“ enc” JWE標頭參數設置。
2.然後根據設置的“ alg” JWE標頭參數使用RSA加密AES密鑰，並將其作為JWT的一部分發送。
JOSE標準提供了兩種用於JSON Web加密（JWE）的基於RSA的算法，由“ alg”標頭參數標識：

RSA-OAEP和 RSA-OAEP-256- 其中CEK是通過具有最佳非對稱加密填充（OAEP）的RSAES進行加密的。
RSA1_5- 使用RSAES-PKCS1-v1_5對CEK進行加密。由於存在安全漏洞，不建議使用此算法；僅提供它是為了與舊軟件向後兼容。
您可以將它們與以下任何用於內容加密的AES算法配對，這些算法由“ enc”標頭參數標識：

A128CBC-HS256 -AES_128_CBC_HMAC_SHA_256認證的加密
A192CBC-HS384 -AES_192_CBC_HMAC_SHA_384認證的加密
A256CBC-HS512 -AES_256_CBC_HMAC_SHA_512認證的加密
A128GCM-使用128位密鑰的AES GCM
A192GCM-使用192位密鑰的AES GCM
A256GCM-使用256位密鑰的AES GCM

import java.util.*;
import java.security.interfaces.*;
import javax.crypto.*;

import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.*;
import com.nimbusds.jwt.*;


// Compose the JWT claims set
Date now = new Date();

JWTClaimsSet jwtClaims = new JWTClaimsSet.Builder()
    .issuer("https://openid.net")
    .subject("alice")
    .audience(Arrays.asList("https://app-one.com", "https://app-two.com"))
    .expirationTime(new Date(now.getTime() + 1000*60*10)) // expires in 10 minutes
    .notBeforeTime(now)
    .issueTime(now)
    .jwtID(UUID.randomUUID().toString())
    .build();

System.out.println(jwtClaims.toJSONObject());
// Produces
// {
//   "iss" : "https:\/\/openid.net",
//   "sub" : "alice",
//   "aud" : [ "https:\/\/app-one.com" , "https:\/\/app-two.com" ],
//   "exp" : 1364293137871,
//   "nbf" : 1364292537871,
//   "iat" : 1364292537871,
//   "jti" : "165a7bab-de06-4695-a2dd-9d8d6b40e443"
// }

// Request JWT encrypted with RSA-OAEP-256 and 128-bit AES/GCM
JWEHeader header = new JWEHeader(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM);

// Create the encrypted JWT object
EncryptedJWT jwt = new EncryptedJWT(header, jwtClaims);

// Create an encrypter with the specified public RSA key
RSAEncrypter encrypter = new RSAEncrypter(publicKey);

// Do the actual encryption
jwt.encrypt(encrypter);

// Serialise to JWT compact form
String jwtString = jwt.serialize();

System.out.println(jwtString);
// Produces
//
// eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkExMjhHQ00ifQ.K52jFwAQJH-
// DxMhtaq7sg5tMuot_mT5dm1DR_01wj6ZUQQhJFO02vPI44W5nDjC5C_v4p
// W1UiJa3cwb5y2Rd9kSvb0ZxAqGX9c4Z4zouRU57729ML3V05UArUhck9Zv
// ssfkDW1VclingL8LfagRUs2z95UkwhiZyaKpmrgqpKX8azQFGNLBvEjXnx
// -xoDFZIYwHOno290HOpig3aUsDxhsioweiXbeLXxLeRsivaLwUWRUZfHRC
// _HGAo8KSF4gQZmeJtRgai5mz6qgbVkg7jPQyZFtM5_ul0UKHE2y0AtWm8I
// zDE_rbAV14OCRZJ6n38X5urVFFE5sdphdGsNlA.gjI_RIFWZXJwaO9R.oa
// E5a-z0N1MW9FBkhKeKeFa5e7hxVXOuANZsNmBYYT8G_xlXkMD0nz4fIaGt
// uWd3t9Xp-kufvvfD-xOnAs2SBX_Y1kYGPto4mibBjIrXQEjDsKyKwndxzr
// utN9csmFwqWhx1sLHMpJkgsnfLTi9yWBPKH5Krx23IhoDGoSfqOquuhxn0
// y0WkuqH1R3z-fluUs6sxx9qx6NFVS1NRQ-LVn9sWT5yx8m9AQ_ng8MBWz2
// BfBTV0tjliV74ogNDikNXTAkD9rsWFV0IX4IpA.sOLijuVySaKI-FYUaBy
// wpg


// Parse back
jwt = EncryptedJWT.parse(jwtString);

// Create a decrypter with the specified private RSA key
RSADecrypter decrypter = new RSADecrypter(privateKey);

// Decrypt
jwt.decrypt(decrypter);

// Retrieve JWT claims
System.out.println(jwt.getJWTClaimsSet().getIssuer());;
System.out.println(jwt.getJWTClaimsSet().getSubject());
System.out.println(jwt.getJWTClaimsSet().getAudience().size());
System.out.println(jwt.getJWTClaimsSet().getExpirationTime());
System.out.println(jwt.getJWTClaimsSet().getNotBeforeTime());
System.out.println(jwt.getJWTClaimsSet().getIssueTime());
System.out.println(jwt.getJWTClaimsSet().getJWTID());
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（線程安全、非線程安全）
有狀態為非線程安全，使用可變變量，不同方法調用間不保留任何狀態。使用Prototype原型模式：每次對bean的請求都會創建一個新的bean實例。
無狀態為線程安全，使用單例(Singleton)、有成員變量但是不可變、沒有成員變量
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（Future<Interface>）
boolean cancel(boolean)
boolean isCancelled()
boolean isDone()
get()
get(long, TimeUnit)		//一定時間內去等待獲取執行結果，如果超過時間拋出TimeoutException

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class FutureTaskTest {
	public static void main (String[] args) throws InterruptedException, ExecutionException {
	
		long starttime = System.currentTimeMillis();

		FutureTask<Integer> input2_futuretask = new FutureTask<>(new Callable<Integer>() {

			@Override
			public Integer call() throws Exception {
				Thread.sleep(3000);
				return 5;
			}
		});

		new Thread(input2_futuretask).start();

		FutureTask<Integer> input1_futuretask = new FutureTask<>(new Callable<Integer>() {
			@Override
			public Integer call() throws Exception {
				Thread.sleep(2000);
				return 3;
			}
		});
		new Thread(input1_futuretask).start();

		Integer integer2 = input2_futuretask.get();
		Integer integer1 = input1_futuretask.get();
		System.out.println(algorithm(integer1, integer2));
		long endtime = System.currentTimeMillis();
		System.out.println("用時: " + String.valueOf(endtime - starttime));
	}

	public static int algorithm(int input, int input2) {
		return input + input2;
	}
}

8
用時: 3001毫秒
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（server提供資料，開一個API出來：）
//首頁，直接輸出所有留言
app.get('/', function(req, res) {
	//從資料庫拿出所有的留言
	db.getPosts(function(err, posts) {
		if (err) {
			res.send(err);
		} else {
			//直接把所有posts丟出去
			res.send({
				posts: posts
			});
		}
	})
})
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（函數式接口）

default method
1.只能在函數式接口中使用
2.公共的行為抽象為默認方法，所有實現中都會有該默認方法--可以參考 Collection	//接口中已實現，不需要再實現，但是可以依需要實現覆蓋。如 Vector 向量覆蓋了 Collection 中的 removeIf
3.可以在已經發布的接口中添加默認方法，讓接口具有新的行為，能夠繼續演化發展

public interface TestDefaultMethodApi {
	default voud print(String msg) {
		System.out.println(msg);
	}
}

static method
1.實現高內聚

public interface TestStaticMethodApi {
	static void utilMethod(String msg) {
		System.out.println(msg);
	}
}

接口的優勢
接口的設計主要是為了支持運行時動態方法的解析。通常情況下，為了能夠從一個類中調用另外一個類的方法，編譯時這兩個類都需要存在，這樣的要求造成了類系統的不可擴展性。設計接口的目的就是為了增強類的擴展性，具體參考如下：

public interface MyInterface {
	int getInt();
}

public class MyInterfaceImpl implements MyInterface {
	@Override
	public int getInt() {
		return 6;
	}
}

public classMain {
	public static void main(String[] args) {
		MyInterface my = null;
		// 根據工廠或者其他方式獲取MyInterfaceImpl或者MyInterfaceImpl1的實例
		my.getInt();
	}
}

如果一個類實現兩個或兩個以上接口，並且多個接口中包含統一默認(default method)方法，此時，編譯器將報錯。這種情況，我們必須讓子類Override該方法，否則無法編譯通過。

如果一個類只是實現了接口中的部分方法定義，那麽該類必須聲明為抽象類。
如Spring的AbstractBeanFactory間接的實現了BeanFactory以及其他接口中通用功能，其他方法交由後續子類實現。實際開發也經常會針對Service、Dao做一個抽象接口，然後開發一個抽象類，將通用功能實現
例如dao中的增刪改查翻頁等，對於業務特有內容，則交由後續子類實現。


List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);
___________________________________________________________________________________________________________________________________________________________________________________________________________________
