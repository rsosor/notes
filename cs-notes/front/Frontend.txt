（術語、知識）

瀏覽器渲染步驟：

HTML	→Parsing　　DOM　＼
			　　　Merging
			　　 Render Tree　　→　　Layout　　→　　Paint
CSS	→Parsing　　CSSOM ／


從 HTML 檔解析出 DOM Tree
從 CSS     檔解析出 CSSOM Tree
兩者疊加後產生      Render Tree
Reflow：計算出 Render Tree 上各個元素的物理屬性，如位置、大小、及是否看得見（visible）
Repaint：將計算結果轉為實際的像素，畫到畫面上

Reflow
如同前述，這個步驟會由 Render Tree 的根結點出發，逐步計算出每一個元素的位置、大小，以及是否被其他元素遮擋等屬性，需要耗費大量的運算資源；也因為是要計算出這些屬性，只要是有可能牽扯到這些屬性的操作，都會觸發 Reflow，例如：

．設定 CSS 屬性
　大小：width、height
　浮動：float
　定位：position
　...

．使用者進行互動
　調整瀏覽器視窗大小
　輸入框的內容變更

．JavaScript
　DOM 操作
　動態載入 CSS 樣式表
　取得元素的大小數值


較需注意「取得元素的大小數值」這一項，由於 Reflow 的計算相對於其他步驟需要較多運算效能，當有 Reflow 的需求時，瀏覽器不會馬上執行，而是會將它放到內部的等待隊列中，當需要時（每一 frame）才批次執行，並清空隊列。	// 這裡的 frame 也就是 window.requestAnimationFrame() 的那個 幀數

考慮到 Reflow 批次執行的特性，當開發者要取得元素的物理屬性例如 scrollTop 時，可能程式執行的當下有樣式修改仍在等待隊列，尚未 Reflow 到畫面上；為了避免這樣的狀況，每當開發者要獲取元素大小數值時，瀏覽器便會強制觸發一次 Reflow、以確保程式能取到正確的位置。而這也是許多網站的滑鼠滾輪事件監聽沒寫好，就讓整個網站超卡的原因！

Repaint
經過了 Reflow 的計算，Repaint 的任務是要把計算結果轉換成螢幕上的實際像素顯示。相比於 Reflow ，Repaint 就單純多了，任何可見元素的樣式變更，最後都必然需要重新繪製到畫面上，這是難以避免的效能開銷。


如同 Reflow 段落提到的，由於 Reflow 極耗效能，瀏覽器會 自動批次執行。
當 DOM 元素的樣式被修改觸發前述步驟時，瀏覽器會依據修改的屬性而 自動省略 不需要的步驟，重新渲染頁面。
修改 width → Reflow → Repaint
修改 color  → Repaint
理解上述規則之後，讀者您應該就能猜到該如何優化 CSS 效能了吧？↓提供幾種常見的方法：


1. 屬性替換
　將物理屬性的變化，換成相似的其他屬性變化，來節省 Reflow 的效能開銷：

．用 translate 取代 top 等定位屬性
．由於表格的物理屬性會互相影響，容易改一格就整張表 Reflow，可以的話請不要用 table 排版



2. 批次修改
　當需要用 JavaScript 修改樣式時，盡量讓樣式能批次生效：

．替換 class name 或修改 cssText，而不是逐個設定 style 屬性
．透過 el.cloneNode() 複製一份 DOM，在上面修改樣式後，在替換原本的 DOM
．透過 document.createDocumentFragment() 建立 Document Fragments，編輯 DOM 後再加回主 DOM Tree 中



3. 減少影響範圍
　如果 Reflow 是避免不了的，那就只能減少影響範圍了：

．盡量避免 DOM、CSSOM Tree 的層級過深，加快 Reflow 的計算
．程式取得元素物理屬性時，將結果暫存起來，不要重複觸發計算
．改動頻繁的地方 建立單獨的圖層（stacking context）





（沒有框架的日子）

那時最流行的「套件」jQuery ，語法簡潔、直覺的「元素選取器」，語法便捷的「事件監聽註冊」，豐富的開發者生態系產出大量開源套件，以及最重要的，弭平瀏覽器 XHR 差異的 ajax 函式，將複雜的瀏覽器差異藏在套件中，讓開發者只需要專注在想實作的邏輯即可。

透過好用的"元素選取器"及"事件監聽"，開發者們可以依據使用者的行為，靈活操作 DOM 元素的結構及樣式，jQuery 的這些特色直到 2019 的現在，都仍是很實用的功能；但隨專案增大程式複雜度不斷上升，直接操作 DOM 的缺點也就逐漸浮出檯面：

難以維護
HTML、CSS、JavaScript 無法維持原先的各司其職，因為需要透過 JavaScript 處理互動內容，勢必要將結構、樣式寫到 JavaScript 的部份中，也就因此造成「架構耦合度提高」，程式碼管理困難。

效能低落
在 Reflow 及 Repaint 是什麼？ 中有提到 Render Tree 的概念，當 DOM 被改變，勢必要觸發整個 Reflow & Repaint 的流程，頻繁的改動觸發重複渲染，便會讓頁面效能被消耗殆盡。


（框架的功能）

有前述問題自然有強者試圖解決。歷史進程中許多大神拋出了方法論，或實作出解決方案，但中間的歷史礙於篇幅簡略帶過。現今的「框架」其實就是一種提升開發效率、降低維護難度的開發架構。

資料與 UI 分離

原先想顯示一筆資料，可能必須寫死在 HTML 結構中：
<div id="root">
  <div class="card">
    <h3 class="name">Gary</h3>
    <p class="comment">something</p>
  </div>
</div>

若是動態的資料，可能要透過 JavaScript 將資料動態塞入 DOM 元素：
let commentData = [
  { name: 'Gary', comment: 'try harder'},
  { name: 'Alice', comment: 'good'},
  { name: 'Bob', comment: 'excellent'},
  //...
]

commentData.forEach(c => {
  $('#root').append(
    $(document.createElement('div')).append(
      $(document.createElement('h3')).text(c.name),
      $(document.createElement('p')).text(c.comment)
    ).addClass('card')
  )
})

Vue 中可能寫成這樣：
<template>
  <div id="root">
    <div class="card" v-for="item in commentData" :key="name">
      <h3 class="name">{{item.name}}</h3>
      <p class="comment">{{item.comment}}</p>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      commentData: [
        { name: 'Gary', comment: 'try harder'},
        { name: 'Alice', comment: 'good'},
        { name: 'Bob', comment: 'excellent'},
        //...
      ]
    }
  }
}
</script>
乍看兩種好似，但考慮了可讀及可維護。透過 Vue 的寫法，讓頁面結構的部份仍然由 HTML 決定，並由資料來決定畫面該如何呈現。
關鍵由資料決定畫面！就是現代框架重要核心概念；將資料從介面中抽出，每個畫面都是對資料處理過後的呈現。


模組化 UI
網站總是有重複出現的元素，按鈕、輸入表單、表格、對話框等，像 FaceBook 按讚按鈕，可能一頁數十個；現代框架中，把這些重複出現元素稱 組件（Components），每個組件包含了組件自己需要用的結構、樣式、邏輯。
例如前述例子下午 08:44 2021/8/29，我們可以將 .card 這個元素抽成單獨的組件：一來各組件只需處理組件內的事，外部引用的組件來決定怎麼使用、提供什麼資料給組件，藉由簡單的切分權責，加上前述的由資料決定畫面，讓各組件任務單一，並且能被重複使用。

甚至現在有許多完成度很高的前端 UI 組件庫，讓開發者有如玩樂高一樣，能快速地用組件堆出想要的畫面，大幅度降低了組織畫面所需要的時間，讓工程師能更專注在處理商業邏輯上。


（效能）
頻繁操作 DOM 的方式改變畫面，可能會造成全頁面的 Reflow 及 Repaint；不過在使用框架時，開發者不用太擔心這個問題。

原因是各主流框架的實作中，幾乎都包含了「Virtual Dom」的概念，也就是用 JavaScript 物件來表達當前的頁面結構；藉由與 UI 分離的資料及 Virtual Dom 之間的關係，當資料變動時，事先計算好這次畫面需要變動地方，便能抵銷掉無意義的更動，並重複利用已存在的 DOM 元素；當真的要進行 DOM 更新時，也會一次將所有需要更新的局部組件更新，讓效能的耗損盡可能降低。

當然，Virtual Dom 變動的計算也是需要耗費運算資源的，過於簡單的專案或批次的大量修改，很有可能原生寫法還比框架快上不少



網頁設計→UIUX→前端→後端

web layout 網頁切版(不做設計單純做前端介面 UI)	// Flexbox: 其中一種排版方式

D3: 圖表效果？
AJAX: 跟資料庫接 API

1. 開版費(傳統方式，表頭、表尾等)，5000，內頁頁數計算
現在網頁技術所有東西都可以模組化、元件化，例如按鈕、標題、段落樣式

1. 網頁版型頁面數量
2. 動畫效果數量
3. 特定需求(瀏覽器、特定框架)
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（HTML）
DOM 是 HTML、XML 和 SVG 文件的程序介面。它提供了一個文件(樹)的結構化表示方法，並定義讓程序可以訪問並更改文件架構、樣式和內容的方法(像物件一樣被存取)。
W3C 定義了非常多的網頁規則好讓各大瀏覽器可以按照這些規則去設計瀏覽器，其中 DOM 就是其中的一個定義。

HTML DOM(Document Object Model)
	根據W3C DOM規範，DOM是一種與瀏覽器、平台、語言無關的接口，使得你可以訪問頁面中其他的標準組件。DOM解決了Netscape的JavaScript和Microsoft的JavaScript之間的衝突，給與Web設計師和開發者標準方法，讓他們來訪問他們站點中的數據、腳本和表現層對象。
	DOM是以層次結構組織的節點或信息片段的集合。這個層次結構允許開發人員在樹中導航尋找特定信息。分析該結構通常需要加載整個文檔和構造層次結構，才能做任何工作。由於它是基於信息層次的，因而DOM被認為是基於樹或基於對象的。
	HTML DOM定義了訪問和操作HTML文檔的標準方法。
	HTML DOM 把HTML文檔呈現為帶有元素、屬性和文本的樹結構(節點樹)。

		Document
		       |
	              Root element:
		   <html>
   Element:				Element:
    <head>					 <body>

   Element:	Attribute:	   ____	Element:		Element:
    <title>		  "href"		    <a>		   <h1>

     Text:				  Text:		  Text:
  "My title"		               "My link"	              "My header"


Document 就是指這份文件，也就是這份 HTML 檔的開端，所有的一切都會從 Document 開始往下進行。

Element 就是指文件內的各個標籤，因此像是 <div>、<p> 等等各種 HTML Tag 都是被歸類在 Element 裡面。

Text 就是指被各個標籤包起來的文字，舉例來說在 <h1>Hello World</h1> 中， Hello World 被 <h1> 這個 Element 包起來，因此 Hello World 就是此 Element 的 Text

Attribute 就是指各個標籤內的相關屬性。


由於 DOM 為樹狀結構，樹狀結構最重要的觀念就是 Node 彼此之間的關係，這邊可以分成以下兩種關係：

父子關係(Parent and Child)
簡單來說就是上下層節點，上層為 Parent Node ，下層為 Child Node 。

兄弟關係(Siblings)
簡單來說就是同一層節點，彼此間只有 Previous 以及 Next 兩種。


document.getElementById('idName')
找尋 DOM 中符合此 id 名稱的元素，並回傳相對應的 element 。

document.getElementsBytagName('tag')
找尋 DOM 中符合此 tag 名稱的所有元素，並回傳相對應的 element 集合，集合為 HTMLCollection 。

document.getElementsByClassName('className')
找尋 DOM 中符合此 class 名稱的所有元素，並回傳相對應的 element 集合，集合為 HTMLCollection 。

document.querySelector('selector')
利用 selector 來找尋 DOM 中的元素，並回傳相對應的第一個 element 。

document.querySelectorAll('selector')
利用 selector 來找尋 DOM 中的所有元素，並回傳相對應的第一個 element ，集合為 NodeList 。


這裡稍微提一下 HTMLCollection 以及 NodeList ，兩個都是 Collection of DOM Nodes ，那到底差在哪呢？

HTMLCollection
集合內元素為 HTML element ，也因此 Node type 只能接受 Element 。

NodeList
集合內元素為 Node ，也因此全部的 Node 都可以存放在 NodeLists 內。


其實真正常用的 DOM API 也就這幾種而已，尤其 jQuery 盛行，讓 HTML 與 JavaScript 的溝通更加精簡容易，也因此越來越多人捨棄 DOM API 進而投向 jQuery 的懷抱，筆者在未來的文章也會加以闡述這個 JavaScript Library 。
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（CSS）
優先順序 id > class > 標籤。

．標籤(元素)選擇器：
「直接將指定的元素標籤名稱」當做選擇器，例如：樣式會套用到頁面中所有的 <h1>~</h1>，較適合用來定義全體通用的基礎樣式。
h1 { color: #333333; }

．id 選擇器：
利用 id 屬性「為元素命名」並做為選擇器，元素(標籤)名稱通常省略不寫。
※ 注意：id 是用來識別在 HTML 檔案中特定位置的屬性，一個 HTML 檔中只能有一個，若在同一個頁面中撰寫多次相同的 id 名稱，將會造成語法錯誤。
#title { text-align: center; }

．class 選擇器：
利用 class 屬性「為元素命名」並做為選擇器，省略元素(標籤)名稱時，將被視為通用的 class，任何元素標籤都可以使用，可以在 HTML 檔中多處重複使用。
.text-green { color: #32b16c; }
假如不省略元素(標籤)名稱時則只有特定的元素才適用。例如下列這個就只有 h1 標籤套用此 class 才有效。
h1.text-green { color: #32b16c; }

另外多補充一個由 class 延伸的選擇器
．複合選擇器：
當設定多個 class 時，可以用「.class1.class2」的形式將選擇器結合( class 中間不可有空格)，「既有 class1 也有 class2」的選擇器
.cat-type.male { color: #2793a7; }

標籤(元素)、id、class 都是用於 單一元素標籤、單一 class、單一 id 的選擇器，稱之為「簡易選擇器」。
___________________________________________________________________________________________________________________________________________________________________________________________________________________
1. *
* {
 margin: 0;
 padding: 0;
}
對於初學者來說，至更加高級的選擇器前，讓我們先攻克這些顯而易見的。

指向頁面所有的元素。 很多程序猿都會用這個訣竅將 margin 和 padding 歸零。 雖說這對於一個快速的測試是肯定沒問題的，但是建議永遠都不要將其應用於生產環境的代碼中。 它為瀏覽器帶來太多負擔，而且是完全沒必要的。

星號 * 可以同時被用於子對象選擇器中。

#container * {
 border: 1px solid black;
}
這樣可以指向所有的 #container div 的子對象。 同樣的，如果可能的話，盡可能不要使用這個方法。

兼容性
IE6+
Firefox
Chrome
Safari
Opera

2. #X	指向多個 #X,#XX
#container {
   width: 960px;
   margin: auto;
}
允許我們指向 id。 最常用的選擇器使用，不過當使用 id 選擇器時要注意。

問問你自己：我真的一定需要為這個元素添加 id 來指向他麼？

id 選擇器的規則非常的嚴格，而且因為他是唯一的，所以不允許被再次使用。 如果可能的話，首先嘗試使用 tag 名，這是一個 HTML5 版本的新元素，或者甚至試試偽類。

兼容性
IE6+
Firefox
Chrome
Safari
Opera

3. .X
.error {
  color: red;
}
這是一個 class 選擇器。 id 和 class 的不同點就是 class 可以同時標記多個元素。 當你想要你的樣式應用到一組元素的時候你可以使用 class。 或者，你也可使用 id 刻意讓一個單獨的元素使用特別的樣式。

兼容性
IE6+
Firefox
Chrome
Safari
Opera

4. X Y
li a {
  text-decoration: none;
}
下一個最常見的選擇器是 descendant selector（子對象選擇器）。 當需要更明確的選擇某個目標時，就使用這個選擇器。 舉例，假設你不想選擇所有的錨點對象，只是想選擇所有無序列表以下的錨點對象？ 這樣的情況就特別需要使用子對象選擇器了。

專家提示 - 如果你的選擇器看起來像是X Y Z A B.error，那麼你就做錯了。 記得始終問問自己是不是真的特別需要這麼精確的負擔重的選擇器。

兼容性
IE6+
Firefox
Chrome
Safari
Opera

5. X
a { color: red; }
ul { margin-left: 0; }
如果想要選擇當前頁面所有的相同 type（種類）的元素，你會考慮使用 id 或者 class 名麼？ 如果你想保持你代碼的干淨，就用 type（類）選擇器好了。 如果你需要選中所有的無序列表，使用 ul {}。

兼容性
IE6+
Firefox
Chrome
Safari
Opera

6. X:visited and X:link
a:link { color: red; }
a:visted { color: purple; }
我們使用:link偽類來選擇所有的錨點標籤並且你還沒有點擊過。

作為備用，我們同時有:visited偽類，正如你期待的，這個允許我們應用特別的樣式到頁面上已經被點擊過或者訪問過的錨點標籤。

兼容性
IE7+
Firefox
Chrome
Safari
Opera

7. X + Y
ul + p {
   color: red;
}
稱為相鄰兄弟選擇器。 它僅僅會選擇剛好在左邊元素之前的元素。 在這種情況下，僅僅第一個 ul 之後的段落()會被賦予紅色。

兼容性
IE7+
IE7+
Chrome
Safari
Opera

8. X > Y
div#container > ul {
  border: 1px solid black;
}
普通的 X Y 和 X > Y 的不同是後者僅僅選擇它的直接的子對象。 舉個例子，考慮一下以下的情況。

   <div id="container">
      <ul>
         <li> List Item
           <ul>
              <li> Child </li>
           </ul>
         </li>
         <li> List Item </li>
         <li> List Item </li>
         <li> List Item </li>
      </ul>
   </div>
一個 #container > ul 的選擇僅僅會選中那些包含 id 名 container 的 div 下的直接子對象 ul。 它並不會指向，舉個例子，第一個 li 裡面的子對象 ul。

由於這個原因可以得出，使用子組合器有很多的性能上的利益。 事實上，當使用 JavaScript 為基礎的 CSS 選擇器引擎的情況下是非常推薦的。

兼容性
兼容性
Firefox
Chrome
Safari
Opera

9. X ~ Y
ul ~ p {
   color: red;
}
一般兄弟組合器和相鄰兄弟組合器 X + Y 非常相似，但更加不嚴。 相鄰兄弟選擇器（ul + p）只會選剛剛好在前一個選擇器之前的第一個元素，而這個選擇器範圍會更廣一點。 在我們上面的案例中，它會選擇所有的 p 元素，只要他們是在 ul 之後。

兼容性
IE7+
Firefox
Chrome
Safari
Opera

10. X[title]
a[title] {
   color: green;
}
適用於屬性選擇器，在我們上面的例子裡，這僅僅選擇所有包含 title 屬性的的錨點對象。 那些並沒有 title 屬性的將不會接收到該特有的樣式。但是，如果你希望要更加的具體？ 好吧……

兼容性
IE7+
Firefox
Chrome
Safari
Opera

11. X[href="foo"]
a[href="https://net.tutsplus.com"] {
  color: #1f6053; /* nettuts green */
}
上面這個小片段將為所有包含鏈接 https://net.tutsplus.com 的錨點對象添加樣式；他們將接收到我們的標誌性的綠色。其他的對象將保持不被改變的狀態。

注意：我們將值放在了引號裡。 記住如果你使用 JavaScript CSS 選擇器引擎也要做同樣的事情。 如果可能的話，總是使用 CSS3 選擇器而不是非官方的方法。

這樣就可以工作了，不過，還是有一點僵硬， 如果這個鏈接確實是指向 Nettuts+，但是，也許，這個路徑是 nettuts.com 而不是完整的 url 呢？ 在這種情況下，我們可以使用一點點普通表達式的語法在裡面。

兼容性
IE7+
Firefox
Chrome
Safari
Opera

12. X[href*="nettuts"]
a[href*="tuts"] {
  color: #1f6053; /* nettuts green */
}
這就是我們需要的。 星號指定的值必須出現在屬性裡面的某個地方。 這樣，這就包括了 nettuts.com、net.tutsplus.com、甚至是 tutsplus.com。

請記住，這是個非常寬泛的聲明。 如果這個錨點對象鏈接到某個並不是 Envato 的網站但其字符串裡面又包含了 tuts 在 url 又會怎麼樣呢？ 當你需要更精確的時候，使用 ^ 和 $ 來分別指向開始或結束的字符串。

兼容性
IE7+
Firefox
Chrome
Safari
Opera

13. X[href^="http"]
a[href^="http"] {
   background: url(path/to/external/icon.png) no-repeat;
   padding-left: 10px;
}
你有沒有疑問過為什麼有些網站可以在外部鏈接的邊上顯示一個小的圖標？ 相信以前肯定看過這種情況；它們是很貼心的提醒你即將引導你到一個完全不同的外部網站。

這是一個小的腰帶狀包含有克拉符號的標誌。 這是最常見用在普通表達式裡面的一種標誌，一般會出現在字符串的開始。 如果你希望指向所有的包含 href 且開頭是 http 的錨點對象，我們可以使用上面所提到的相似選擇器。

注意，我們並不需要搜索 https://，這個是不必要的，而且這樣的話就無法選中那些 url 是以 https:// 開頭的了。

現在，如果我們希望為所有的，假設，指向照片的錨點來設置樣式。 在這種情況下，我們就需要搜索結束的字符串。

兼容性
IE7+
Firefox
Chrome
Safari
Opera

14. X[href$=".jpg"]
a[href$=".jpg"] {
   color: red;
}
同樣的，我們使用普通的表達式符號 $，來提到尾部的字符串。 在這種情況下，我們需要搜索所有包含鏈接到圖片的錨點——或者至少也是一個以 .jpg 結尾的 url。 記住，這個選擇器肯定不能被用在 gifs 和 pngs 上。

兼容性
IE7+
Firefox
Chrome
Safari
Opera

15. X[data-*="foo"]
a[data-filetype="image"] {
   color: red;
}
參考到第 8 條，我們該如何來選中所有不同種類的圖片呢：png，jpeg，jpg，gif？好吧，我們需要創建多個選擇器，諸如：

a[href$=".jpg"],
a[href$=".jpeg"],
a[href$=".png"],
a[href$=".gif"] {
   color: red;
}
但是，這麼做太蛋疼了，而且還沒效率。 另一種解決辦法會使用自定義屬性。如果我們添加自己的 data-filetype 屬性到每一個鏈接到圖片的錨點會發生什麼呢？

<a href="path/to/image.jpg" data-filetype="image"> Image Link </a>
然後，由於有這個 hook 在，我們可以使用基本的屬性選擇器來僅僅指向我們需要的那些錨點。

a[data-filetype="image"] {
   color: red;
}

兼容性
IE7+
Firefox
Chrome
Safari
Opera

16. X[foo~="bar"]
 a[data-info~="external"] {
   color: red;
}

a[data-info~="image"] {
   border: 1px solid black;
}
這裡有一個特別的選擇器，如果你使用會給你的朋友留下深刻的印象。 並不是所有的人都知道這個小訣竅。 這個標籤的標誌（~）可以讓我們分別指向那些有空格分開的多個屬性值。

接著使用上面的我們在第 15 點提到的自定義屬性，我們創建一個 data-info 的屬性，可以允許使用空格來列出我們需要的不同記錄。 在這種情況下，我們需要留下記錄來對應外部鏈接以及鏈接到圖片——只是舉個例子。

"<a href="path/to/image.jpg" data-info="external image"> Click Me, Fool </a>
當這段基礎代碼到位以後，我們可以指向任何的其中一個值，這裡就需要使用這個 ~ 標記屬性選擇的小技巧。

/* Target data-info attr that contains the value "external" */
a[data-info~="external"] {
   color: red;
}

/* And which contain the value "image" */
a[data-info~="image"] {
  border: 1px solid black;
}

兼容性
IE7+
Firefox
Chrome
Safari
Opera

17. X:checked
input[type=radio]:checked {
   border: 1px solid black;
}
這是一個偽類，它僅僅會指向一個用戶端被選中的元素 - 像是單選框或者多選框。

兼容性
IE9+
Firefox
Chrome
Safari
Opera

18. X:after
這個 before 和 after 的偽類實在是太虎了。 看起來，每天都有人在嘗試尋找新的且有創造性的方法來更有效的使用它們。 它們簡單的在選中的元素周圍生成內容。

很多人都是在嘗試解決 clear-fix 的時候被介紹使用這些類並嘗試用它們來 hack。

.clearfix:after {
    content: "";
    display: block;
    clear: both;
    visibility: hidden;
    font-size: 0;
    height: 0;
    }

.clearfix { 
   *display: inline-block; 
   _height: 1%;
}
這個 hack 使用了 :after 偽類來添加一個空格到元素的後面，然後將它清除。 這是你應該放進你工具盒的一個完美的小訣竅，特別是當你想使用 overflow：hidden 的時候卻又不可能的情況下。

另一種有創意的方法，參考如何創建陰影。

根據 CSS3 選擇器的說明，你其實應該使用兩個冒號 :: 作為偽元素的語法。 然而，為了兼容性，用戶端也會接受單一冒號的使用。 事實上，在這裡，更明智的辦法還是使用單一冒號的版本到你的項目裡。

兼容性
IE8+
Firefox
Chrome
Safari
Opera

19. X:hover
div:hover {
  background: #e3e3e3;
}
這是個官方的術語用在用戶活動的偽類。 這個可能聽著比較奇怪，但其實不然。 你想要為用戶鼠標劃過的元素添加樣式麼？ 這一條就可以幫你完成工作！

記得，舊版的 IE 瀏覽器不支持 :hover 偽類用在任何非錨點對像上。

你會經常使用這個選擇器的，舉個例子，生成一個 border-bottom 到錨點對象，當鼠標劃過的時候顯示。

a:hover {
 border-bottom: 1px solid black;
}
專家提示 - border-bottom: 1px solid black; 看起來要比 text-decoration: underline; 更合適。兼容性

兼容性
IE6+（在 IE6 中，:hover 必須以一個錨對象“”為目標才可以工作）
Firefox
Chrome
Safari
Opera

20. X:not(selector)
div:not(#container) {
   color: blue;
}
negation 偽類特別的有用。 我想選擇所有的 div，除了一個有 id 是 container 的。 上面這個小片段可以完成的很完美。

或者，如果你想選擇所有的單個元素（不建議）除了段落對象，我們可以做如下：

*:not(p) {
  color: green;
}

兼容性
IE9+
Firefox
Chrome
Safari
Opera

21. X::pseudoElement
p::first-line {
   font-weight: bold;
   font-size: 1.2em;
}
我們可以使用偽元素（設計為 ::）來為元素的分段添加樣式，比如第一行、或者第一個文字等。 記得，這些必須作用到一個段落的元素中才能有效果。

一個偽元素是由兩個冒號構成的 ::

指向段落中的第一個文字
p::first-letter {
   float: left;
   font-size: 2em;
   font-weight: bold;
   font-family: cursive;
   padding-right: 2px;
}
這個小片段是一個抽象的概念，可以找到頁面上的所有段落，並且找到僅僅是它們最開始的文字作為元素。

這個最常被使用在創建報紙上每篇文章的第一個字母的樣式上。

指向段落中的第一行
p::first-line {
   font-weight: bold;
   font-size: 1.2em;
}
相似的，::first-line 偽元素會按我們期待的，僅僅為第一行元素添加樣式。

“由於目前已有樣式表的兼容性，用戶端必須也要支持前一個在 CSS1 和 2 裡面被介紹的冒號的註釋方法（換句話說就是 :first-line、:first-letter、:before 和 :after ）。 這些兼容性在我們本次介紹的新的偽元素類中並不被允許。”

兼容性
IE6+
Firefox
Chrome
Safari
Opera

22. X:nth-child(n)
li:nth-child(3) {
   color: red;
}
還記得我們沒辦法從一疊元素中選擇特定的元素的那些日子麼？這個 nth-child 偽類會解決這些問題！

請注意，nth-child 接受整數的參數，這個參數不是以 0 為基數。如果你希望指向第二行物體，使用 li:nth-child(2)。

我們甚至可以使用這個來選擇不同組合的子對象。 舉個例子，我們可以用 li:nth-child(4n) 來選擇所有的第四個列表中的物體。

兼容性
IE9+
Firefox 3.5+
Chrome
Safari

23. X:nth-last-child(n)
li:nth-last-child(2) {
   color: red;
}
如果你有一個在 ul 裡數量龐大的列表，而且僅僅需要選擇倒數第三個物品要怎麼辦？與其使用 li:nth-child(397)，不如使用 nth-last-child 來作為替代的偽類。

這種技術的工作原理幾乎和第十六點以後的方法相似，然而，不同的是它在集合的末尾開始和工作並反向數數字。

兼容性
IE9+
Firefox 3.5+
Chrome
Safari
Opera

24. X:nth-of-type(n)
ul:nth-of-type(3) {
   border: 1px solid black;
}
有時候，與其說選擇 child，不如說你會需要根據 type 的元素來選擇。

想想一下，標記包含了 5 個無序列表。 如果你希望僅僅給第三個 ul，並且你並沒有一個特別的 id 與之掛鉤，你可以使用 nth-of-type(n) 偽類來選擇。 在上面的小片段裡，只有第三個 ul 會在周圍有邊框。

兼容性
IE9+
Firefox 3.5+
Chrome
Safari

25. X:nth-last-of-type(n)
ul:nth-last-of-type(3) {
   border: 1px solid black;
}
是的，為了保持一致，我們同時可以使用 nth-last-of-type 來從尾部開始選擇列表，讓我們反過來數直到找到我們希望指向的目標。

兼容性
IE9+
Firefox 3.5+
Chrome
Safari
Opera

26. X:first-child
ul li:first-child {
   border-top: none;
}
這個結構性的偽類允許我們僅指向父元素的第一個子對象。 你會經常的使用到這個來「去除第一個和最後一個列表物品的邊框」。

舉個例子，如果你有一個很多行的列表，每個元素都包含 border-top 和 border-bottom。 如果是這種情況，第一個和最後一個元素會看起來有點奇怪。

很多設計師都會使用 class 來命名 first 和 last 來修復這個問題。 作為替代的，你可以使用這些偽類去處理。

兼容性
IE7+
Firefox
Chrome
Safari
Opera

27. X:last-child
ul > li:last-child {
   color: green;
}
與 first-child 相反，last-child 會指向父對象下的最後一個子元素。

例子
讓我們來創建一個小的例子來解釋使用這種類的情況。 我們創建了一個有格式的一列元素。

結構
  <ul>
     <li> List Item </li>
     <li> List Item </li>
     <li> List Item </li>
  </ul>
只是一個簡單的列表。

CSS
ul {
 width: 200px;
 background: #292929;
 color: white;
 list-style: none;
 padding-left: 0;
}

li {
 padding: 10px;
 border-bottom: 1px solid black;
 border-top: 1px solid #3c3c3c;
}
這些樣式會設置一個北京顏色，移除瀏覽器默認的 ul 上的 padding，然後為每一個 li 添加 border 來提供一點深度。

要添加深度到你的列表，添加 border-bottom 到每一個 li，這樣會創建一個陰影一樣的感覺，會比 li 的背景略深一點點。 下一步，添加一個 border-top 來添加淡一點的陰影。

現在唯一的問題就是，上面圖片可以看出，邊框會同時添加給無序列表的最頂部和底部的元素 - 這樣看起來會有點奇怪。 讓我們使用 :first-child 和 :last-child 偽類來修復這個。

li:first-child {
    border-top: none;
}

li:last-child {
   border-bottom: none;
}

兼容性
IE9+
Firefox
Chrome
Safari
Opera

是的 - IE8 支持 :first-child，但不支持 :last-child。

28. X:only-child
div p:only-child {
   color: red;
}
說真的，你可能會發現你永遠都不怎麼會用 only-child 這個偽類。 儘管如此，它依然是可用的，有時候你可能也需要它。

它允許你指向那些父對象僅有的一個子對像元素。 舉個例子，根據上面的片段，只有段落 - div 的唯一子對象，會被上色變成紅色。

讓我們假設下面的代碼結構。

<div><p> My paragraph here. </p></div>

<div>
   <p> Two paragraphs total. </p>
   <p> Two paragraphs total. </p>
</div>
在這個情況下，第二個 div 的段落不會被選中，只有第一個 div。 只要你有多於一個子對象，only-child 的偽類就停止作用。

兼容性
IE9+
Firefox
Chrome
Safari
Opera

29. X:only-of-type
li:only-of-type {
   font-weight: bold;
}
這個結構性的偽類可以使用到很明智的地方。 它會指向那些在其父對象容器中沒有兄弟姐妹的元素。 舉例，我們來選中所有的 ul，這些 ul 都只有一個列表元素。

首先，問問你自己要如何完成這個工作？ 你可以使用 ul li，不過，這樣會指向所有的列表元素。 唯一的解決辦法就是使用 only-of-type。

ul > li:only-of-type {
   font-weight: bold;
}

兼容性
IE9+
Firefox 3.5+
Chrome
Safari
Opera

30. X:first-of-type
first-of-type 偽類允許你選擇第一個相同類的兄弟姐妹。

一個測試
為了更好地理解這個，我們需要做一個測試。 複製下面的這段代碼到你的編輯器裡：

<div>
   <p> My paragraph here. </p>
   <ul>
      <li> List Item 1 </li>
      <li> List Item 2 </li>
   </ul>

   <ul>
      <li> List Item 3 </li>
      <li> List Item 4 </li>
   </ul>   
</div>
現在，先試試不往下看，嘗試著搞清楚如何只選中“List item 2”。 當你搞明白了（或者放棄了），接著往下讀。

解決方案1
有幾種不同的方法可以解決這個小測驗。 我們來回顧其中少數的幾個。 首先我們要使用 first-of-type。

ul:first-of-type > li:nth-child(2) {
   font-weight: bold;
}
這個片段本質上來看可以這麼說，“找到頁面上的第一個無序列表，然後找到其最接近的子對象，它們是列表下的元素。 接下來，接著向下過濾到僅選擇第二個列表中的元素。

解決方案2
另外一個選項是使用相鄰兄弟選擇器。

p + ul li:last-child {
   font-weight: bold;
}
在這個情況下，我們可以看出 ul 是在 p 之前的對象，然後我們需要找到它裡面最後一個子對象。

解決方案3
當我們想要使用這個選擇器的時候，我們可能會感覺到非常的不開心或者非常好笑。

ul:first-of-type li:nth-last-child(1) {
   font-weight: bold;   
}
這一次，我們抓取了頁面上的第一個ul，然後找到了第一個其內的元素，不過是反過來數的！ :)

兼容性
IE9+
Firefox 3.5+
Chrome
Safari
Opera

結論
如果想為舊版的瀏覽器修正某些代碼，諸如 IE6，可能需要小心使用這些新的選擇器。 但別讓這件事情阻止你學習這些選擇器的決心。 請確保瀏覽器兼容。 作為替代，你可以使用 Dean Edward 的傑出的 IE9.js script 來獲得更多的舊版瀏覽器的支持。

第二，當你使用 JavaScript 庫工作的時候，諸如最流行的 jQuery，記得始終嘗試使用這些「天然的 CSS 選擇器」而不是庫裡的自定義方法/選擇器，可能的話。 它會讓你的代碼運行的更快，因為選擇器的引擎可以使用瀏覽器天然的解析器，而不是庫裡的解碼器。
___________________________________________________________________________________________________________________________________________________________________________________________________________________

通用選擇器、群組選擇器、子孫選擇器、子選擇器、相鄰選擇器等：

．通用選擇器：
將樣式套用於全部元素標籤中，通常在 reset css 時才會用到此方法。
* { margin: 0px; padding: 0px; }

．群組選擇器：
利用「逗號」串連多個選擇器一併管理的用法，這樣可以將多處不同樣式一次指定，避免重複撰寫相同的 class 內容。
h1, h2, h3 { color: #333333; }
.main-title, .sub-title, .small-title { font-weight: bold; }

．子孫選擇器：
利用元素間的親子關係，依序由「父元素→子元素→孫元素 」的形式特定出範圍的選擇器。
注意：必須依序以「半形空格」分隔並列出元素標籤
#main-list ul li a { color: #ff0000; }
但假如能明確的辨識出目的元素，不會與其他用途的標籤混淆，省略中間的元素直接寫目的元素也是可以的，例如上列可以改為：
#main-list a { color: #ff0000; }

．子選擇器( > )：
與子孫選擇器(任意的後代元素皆選)不同，子選擇器是只選擇子元素，子元素的子元素(孫元素)的樣式並不受影響，例如：
<!DOCTYPE HTML>
<html>
<head>
  <style type="text/css">
    li { color: #333333; }
    .main-menu > li { color: #ff0000; }
  </style>
</head>
<body>
<ul class="main-menu">
  <li>項目1</li>
  <li>項目2</li>
  <li>項目3
      <ul>
          <li>項目3-A</li> 
      </ul>
  </li>
</ul>
</body>
</html>
這樣的寫法，ul 中的子元素 li 全部變成紅色，但是孫元素的 li (項目3-A)則不受影響，因為他不是子元素。
假如改寫成子孫選擇器，所有的 li 元素都會變成紅色的：
<style type="text/css">
  .main-menu li { color: #ff0000; }
</style>

．相鄰選擇器( + )：
可選擇有相同的父元素，緊接在一個元素後的「第一個」相鄰兄弟元素(同一層中)，例如下列範例中，只有 h1 的下一個 p 是紅色的，其他第二個之後的 p 仍然是黑色的。
<!DOCTYPE HTML>
<html>
<head>
<style type="text/css">
    h1 + p { color: #ff0000; }
</style>
</head>
<body>
  <h1>This is a heading.</h1>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
</body>
</html>
但是以上這個範例，假如我們改寫成 p + p 的話結果會是什麼？除了第一個 p 其他 p 都變成紅色。
<!DOCTYPE HTML>
<html>
<head>
<style type="text/css">
    p + p { color: #ff0000; }
</style>
</head>
<body>
  <h1>This is a heading.</h1>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
</body>
</html>
這個技巧常用在「一個區塊中段落與段落之間的間距」(ex.從第二段開始，與上一個段落保持上方外距)，可多設想如何運用這個寫法。

另外介紹一個 css3 新增的選擇器：
．間接選擇器( ~ )：
可選擇有相同的父元素，兄元素「之後所有的」弟元素，例如剛剛那個範例若改成 ~ 選擇器，h1 上面再多加一個 p ，結果是除了 h1 上面的那個 p ，底下的 p 全部變成紅色的了。
<!DOCTYPE HTML>
<html>
<head>
<style type="text/css">
    h1 ~ p { color: #ff0000; }
</style>
</head>
<body>
  <p>This is paragraph.</p>
  <h1>This is a heading.</h1>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
  <p>This is paragraph.</p>
</body>
</html>

還有 屬性選擇器 虛擬類別 虛擬元素(偽元素)等 許多好用的選擇器。
先複習：
> 只選擇子元素不選擇孫元素
+ 只選擇相鄰的第一個兄弟元素
~ 可以選擇兄元素之後所有的弟元素
___________________________________________________________________________________________________________________________________________________________________________________________________________________
HTML 的屬性在 CSS 叫做性質
大部分放在 head 標籤

行內		段落		引用設定
style 屬性		區域性的設定	引入 .css 檔


字型、段落、顏色
font      text     color

標籤(元素)名稱、class 名稱、id 名稱
div {
}

.colorRed {
}

#one {
}

background-color: 
background: 這個性質是特性簡寫，可以集合設定
color: 

margin、padding、border-width

左上座標(0, 0)




字型大小：
如 font-size 屬性
度量單位：
絕對: xx-small、x-small、small、medium、large、x-large、xx-large
相對: larger、smaller
絕對: point(pt)、pixel(px)、cm(公分)、in(英吋)、mm(公厘)
相對: em(預設 16)、rem(根據 html 元件，預設 16)、%

字體粗細：
font-weight 屬性
normal
bold
bolder
lighter
100-900

字型：
font-family 屬性，可同時設定多組(當瀏覽器不支援第一種就顯示第二種)




position: 
	static	預設定位，會照著瀏覽器預設的配置自動排版，無法定義 top、left、bottom 與 right 的數值。
	absolute	絕對定位(脫離常規，影響下一個元件位置)和 Fixed 屬性相似，不一樣在於他的基準點會以屬性是 Relative 的父層為基準，所以如果沒有 Relative 父層的情況下，他會直接找到 body（黃框）並以他為基準點。
	relative	相對定位(常規)，在沒有設定任何屬性的情況下，會和 Static 的呈現方式一樣。和 Static 不同於，可透過 top、left、bottom 與 right 改變他的位置，但無論它在頁面上移動了多少位置，都不影響其他元素的位置。
	fixed	可視區(viewport)絕對定位(脫離常規)，元素會以瀏覽器視窗（可視範圍）來定位，意味即便頁面滾動，他還是會固定在相同位置。特別的的地方是不會像 Relative 一樣會在原圖層留下他的空間，若後面還有 Relative 屬性的元素，則會黏在前面同是 Relative 或是 Static 屬性的元素下方。
	sticky	滾動黏滯定位(結合 relative、fixed，沒有跨越特定範圍時為 relative，超出(scroll-bar)則 fixed)，元素一定要在 top、left、bottom 或 right 中指定一個屬性，黏性定位才會生效！否則行為就和 Relative 屬性一樣。



z-index: 1(就可以在前景的上面)

___________________________________________________________________________________________________________________________________________________________________________________________________________________
（JavaScript）
ExtJS 是基於 JavaScript/Ajax 的前端框架；
Ajax（Asynchroious JavaScript and Xml）是基於 JavaScript 的技术。利用 xml 數據格式通信（txt、json亦可），具有與伺服器端異步通信特點的技術，是集中技術的融合

所有 JavaScript 中的函式都有一個內建的 prototype 屬性，指向一個特殊的 prototype 物件，prototype 物件中也有一個 constructor 屬性，指向原來的函式。
原型(prototype): number, string, boolean, undefined, 而 null 也是一种特殊的原始值。
太常使用所以提供原型物件: Number、String

var、let(較嚴謹)
不帶 var、let 宣告變量表示使用全域(global)

null、undefined、0、NaN


字串 + 數字 為 字串 (小心造成 bug 產品價格出現極端)
1 + 2	// 3
"1" + "2"	// "12"
1 + "2"	// "12"
"1" + 2	// "12"


三種回調函數方式：
callback、promise、async/await


event loop(事件循環)
從 stack 丟到 瀏覽器(Web API) 執行，瀏覽器(Web API) 返回到 queue，queue 再給 stack，讓 single thread 達到 偽異步

stack	→	browser
		↓
	↖	queue



event、event handler

___________________________________________________________________________________________________________________________________________________________________________________________________________________
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Ajax 標籤選單</title>
<script type = "text/javascript">
function getData(pageName) {
	//Ajax: XMLHttpRequest 物件專門用來和伺服器做連線
	var req = new XMLHttpRequest();
	req.open("get","http://localhost8080"+pageName);
	req.onload=function() {	//load事件，偵測連線的狀態結束
		//連線完成，做連線後的處理
		var content=document.getElementById("content");
		content.innerHTML=this.responseText;
	}
	req.send();		//送出連線
</script>
</head>
<body onload="getData('popular.htm');">
	<div>
		<span onclick="getData('popular.htm');">xxx</span>
		<span onclick="getData('latest.htm');">xxx</span>
	</div>
	<hr/>
	<div id = "content"></div>
</body>
</html>
陣列[0][1]
var colors=[];
colors[0] = 'black';
colors.push('Purple');		//增加，不用事先把陣列大小設定，底層執行預設創建與擴充
console.log(colors.length);	//用function當作參數編譯慢

物件xx.yy
var home2 = {
	father: 'bob',
	goDinner: function(num) {
		console.log(num+ 'people');
	}
};
console.log(home2.father);
home2.goDinner(3);

JSON格式
[
	{
		"id": "333",
		"name": [
			{"1": 'ss'},
			{"2": 'xx'}
		]
	}
]

javascript
$(function() {
	var home = {
		"father": 'tom',
		"mother: 'mary',
		'baby': [
			{'son': 'jack'},
			{'son': 'susan'},
			{'son': 'nico'}
		]
	};

	console.log(home.baby.length);
	for (var i in home.baby) {
		$('ul').append('<li>'+home.baby[i].son+'</li>');	//HTML裡的<body>內<ul>我想用javascript呈現出來，使用jQuery指定ul
	}
});

//for in可算出裡面的陣列數量開始跑迴圈，假使用Angular、React他有templete控制，不用for迴圈可以用repeat。
//$('class名稱')
//append()是jquery api，意思則是會在指定元素後面加上內容

//下列程式碼為jQuery撈遠端ajax的語法
//不希望網頁重新整理，想要局部修改內容或在遠端撈資料
$.ajax({
	type:'GET',
	url:'要撈的JSON網址',
	success:function(data) {
		xxx
	}
});

$(function() {
	$.ajax({
		type:'GET',
		url:'http://localhost:8080
		success:function(data) {
		//成功資料傳到data變數

		//判斷撈到的值是甚麼格式
			console.log(typeof(data));
		//將撈來的資料轉為 JSON 格式
			var thisdata = JSON.parse(data);
		//將內容顯示在網頁上
			$('body').html(thisdata[0].org_Text);
		}
	});
});

$(function() {
	$.ajax({
		type:'GET',
		url:'http://localhost:8080',
		success:function(data) {
			for(i=0; data.length>i; i++) {
				var thisData = JSON.parse(data);
				var str;
				var free = thisData[i].Ticketinfo;
				if(free=='免費參觀') {
					str = '<li>'+thisData[i].Name+'</li>';
					$('body').append(str);
				}
			}
		}
	});
});

<script>
	jQuery(document).ready(function($) {
		$('#send').on('click', function(event
			){
			event.preventDefault();
			var str = $('#password').val();
			console.log(str);
			$.post('/postAjax',{password:
				str}).success(function(data){
				console.log(data);
				if(data=='success'){
				alert('密碼輸入成功')
				}else{
					alert('密碼輸入錯誤')
				}
			});
		});
		$('#getData').on('click',function(
			event) {
			event.preventDefault();
			$.get('/getAjax').success(function(
				data) {
				// console.log(data)
				$('#list').children().remove()
				for(i=0; data.length>i; i++) {
					$('#list').append('<li>姓名: '+
						data[i].name+' 電話: '+data[i]
						.tel);
				}
			});
		});

傳統方式沒有用jquery ajax的話，例如POST後回傳的就不是id而是name取得

//傳統輸入
exports.post = function(req, res) {
	console.log(req);
	if(req.body.password == 1234) {
		res.render('pages/success');
	}else{
		res.render('pages/error')
	};
};

exports.postAjax = function(req, res) {
	//ajax
	if(req.body.password == 1234) {
		res.send('success');
	} else{
		res.send('error')
	};
};

//get取得資料
exports.getAjax = function(req, res) {
	res.send([{
		name: '王小名',
		tel:'0922194720'
	}, {
		name:'李小花',
		tel:'0983026183'
	}]);
};
___________________________________________________________________________________________________________________________________________________________________________________________________________________
<!-- HTML input -->

<div>
	<p>
		標題：<input id="post_example_name" name="product[name]"
			placeholde="請輸入標題"
			type="text" value="新標題" />
	</p>
	<p>
		價錢：<input id="post_example_price" min="0"
			name="product[price]"
			placeholder="請輸入價錢"
			type="number" value="100" />
	</p>
	<p>
		敘述：<textarea id="post_example_description"
			name="product[description]"></textarea>
	</p>
</div>
<! -- HTML card-->
<div class="_card">
	<div class="card-container">
		<div class="card-content">
			<h3 id="post_card_name">&nbsp;</h3>
			<h4 id="post_card_price" style="color:red;">&nbsp;</h4>
			<p id="post_card_description">&nbsp;</p>
		</div>
	</div>
</div>
<!-- javaScript -->
<script>

function initDynamicCard() {
	var cardNameElement =document.querySelector("#post_card_name");
	var cardPriceElement = document.querySelector("#post_card_price");
	var cardDescriptionElement = document.querySelector("#post_card_description");
	var exampleNameInput = document.querySelector("#post_example_name");
	var examplePriceInput = document.querySelector("#post_example_price");
	var exampleDescriptionInput = document.querySelector("#post_example_description");

	exampleNameInput.addEventListener('input', posts_36_card_update);
	examplePriceInput.addEventListener('input', posts_36_card_update); 
	exampleDescriptionInput.addEventListener('input', posts_36_card_update); 
 
	function posts_36_card_update(){ 
		var name = exampleNameInput.value; 
		var price = examplePriceInput.value; 
		var description = exampleDescriptionInput.value; 
		cardNameElement.innerHTML = name; 
		cardPriceElement.innerHTML = price; 
		cardDescriptionElement.innerHTML = description; 
	} 

	posts_36_card_update(); 
} 

initDynamicCard();
</script>
<! -- css -->

<style>
._card {
	width: 300px;
	height: 230px;
	position: relative;
	overflow: hidden;
	float: left;
}

._card > .card-container {
	position: absolute;
	background-color: rgba(0, 0, 0, 0.3);
	color: white;
	text-align: left;
	margin: auto;
	bottom: 0;
	height: 100%;
	width: 100%;
}

._card > .card-container > .card-content {
	padding: 16px;
}

._card > .card-container > .card-content > .price {
	color: red;
}
</style>
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Use JavaScript's jQuery Ajax

Get的使用，將對象數組渲染成頁面的DOM結構
測試接口能不能正常訪問到數據

	let newsData = {};
	$.get("http://127.0.0.1:3008/api/getnewslist", function(data,status) {
		console.log(data);
	});

編寫簡單的DOM結構和CSS樣式，並且寫出一個item元素方便調試樣式
使用jQuery獲取數據，並給newsData變數
編寫渲染方法，jQuery的$.each()對拿到的數據進行循環遍歷，使用prepend()進行向頁面添加元素的操作
prepend()的參數直接添加剛剛寫好的item元素的DOM結構，並將其中需要變化的幾個元素使用變數代替，直接使用遍歷出每個對象的屬性進行替換
執行加載方法load()，清空.content裡的DOM元素
html
//...

main.js
$(function() {
	let newsData = {};
	// 接口
	$.get("http://127.0.0.1:3008/api/getnewslist", function(data, status) {
		// console.log(data);
		newsData = data.message;
		load();
	});

	const load = () => {
		$.each(newsData, function(i, n ) {
			$(".content").prepend("<div class = 'item'><p class="title">"+ n.title
			+"</p><p class="cont"><span class="addtime">發布時間:"+n.addtime+"</span><span class = "click">點擊量:"+n.click
			+"</span></p></div>")
		})
	}
})
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Socket.io: node.js解決方案，讓APP建立即時通訊的JavaScript函式庫	封裝了Polling及WebSocket，使用的通訊協定基礎: WebSocket。透過在Server與Client之間建立持續的連線，可以即時的傳送資料給對方。
	是一個event-based全雙工的通訊函式庫，事件驅動這個部分是最容易出包的地方，當我們在和react專案整合在一起的時候，就需要去注意事件是不是有和畫面的渲染綁在一起，意思就是說不可以每渲染一次，我就重新建		立連結、重新監聽事件、重新發出訊息，這樣一來記憶體很快就會用完，處理器也根本來不及處理。
___________________________________________________________________________________________________________________________________________________________________________________________________________________
非同步撈取資料，使用onload去取得(GET？)	// XMLHttpRequest裡有open()、send()、onload()、responseText()
const xhr = new XMLHttpRequest();
const url = 'https://data.kcg.gov.tw/dataset/a98753a3-3446-4c9a-abfc-58dc49f2158c/resource/48d4dfc4-a4b2-44a5-bdec-70f9558cd25d/download/yopendata1070622opendatajson-1070622.json'
xhr.open('get', url, true)
xhr.send(null)

xhr.onload = function() {			// onload → 確定有資料回傳回來時執行後面 function()
	console.log(xhr.responseTest)
}

操作資料。JSON 一樣使用上面　高雄充電站 OPEN DATA
// 假如我們HTML上有<div class ="text></div>

let text = document.querySelector('.text');		// 操作HTML的重要步驟，document.querySelector('.text')
const xhr = new XMLHttpRequest();
const url = 'https://data.kcg.gov.tw/dataset/a98754a3-3446-4c9a-abfc-58dc49f2158c/resource/48d4dfc4-a4b2-44a5-bdec-70f9558cd25d/download/yopendata1070622opendatajson-1070622.json'
xhr.open('get', url, true)
xhr.send(null)

xhr.onload = function() {
	let str = JSON.parse(xhr.responseText)		// JSON.parse()用來將response的JSON字串(xhr.responseText)轉換成物件。
	text.textContent = str[0].Address;		// 操作HTML的<div class = "text">標籤內容，使用text.textContent = str[0].Address，把資料印到HTML上。
}

重新整理此流程：
1. 設立物件text型態作用是HTML的使用權
2. 建立一個XMLHttpRequest並open()、send()、onload()

搞不好撈的網址有錯誤(status404等)，所以我們沿用上面改寫
xhr.onload = function() {
	if(xhr.status == 200) {
		let str = JSON.parse(xhr.responseText)
		text.textContent = str[0].Address;
	}else {
		console.log('資料錯誤')
	}
}
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Angular
HttpClient is Angular's mechanism for communicating with a remote server over HTTP.
HttpClient撈取遠端資料
專案中可以把get後端API的function放在service，這樣每隻程式都可以從這邊拿資料。

programs.service.ts
import { HttpClient } from '@angular/common/http';
public getData()
	: Observable<any> {
	const URL = 'http://data.ntpc.gov.tw/api/v1/rest/datastore/382000000A-000352-001';
	return this.http.get<any>(URL);
	}
這邊用的是政府資料平台裡面的開放資料，我們可以先用postman來觀察資料的型態，可以觀察到這包資料在result=>records後裡面是用陣列存取的多筆YouBike系統位置
再來就可以到我們的component中去呼叫
tri001.component.ts
import { Component, OnInit} from '@angular/core';
import { ProgramsService} from '../programs.service';
import { HttpErrorResponse} from '@angular/common/http';

@Component( {
	selector: 'app-tri001',
	templateUrl: './tri001.component.html'
})
export class Tri001Component implements OnInit {
	public item: Array<any> = new Array<any>();	// 因為會有多筆，先建一個any型別的陣列資料來接回傳值
	constructor(private programService: ProgramsService) {}
	ngOnInit() {
		this.getData();	// 程式一啟動時即撈取資料
	}
	getData() {
		this.programService.getYouBikeData().subscribe(
			(response: any) => {
				this.item = response;
				console.log(this.item);	// log接到的資料
			},
			(error: HttpErrorResponse) => this.programService.HandleError(error)
		);
	}
}
getData()執行完(subscribe)，會有兩種結果
1. 就是得到資料=>將response給我們定義的item參數
2. 得不到資料或產生莫名錯誤=>利用HttpErrorResponse，將資料傳到共用HandleError()裡讓錯誤呈現在網頁上

programs.sevice.ts
// htttp呼叫錯誤處理
public HandleError(e: any): void {
	// console.log(e);
	alert(e.error.error);
}
撰寫好以後來看看會log的資料

這邊會有No 'Access-Control-Allow-Origin' header is present on the requested resource.的CROS問題
https://blog.gtwang.org/web-development/chrome-configuration-for-access-control-allow-origin/
先參考這篇文來解決

之後alert可以用Angular Material的Dialog改寫
接到資料以後，我們應該不會只想單純的在log中顯示吧
接下來要在網頁畫面上呈現
根據前面觀察到的回傳JSON型態
tri001.component.ts
getData() {
	this.programService.getYouBikeData().subscribe((response: any) => {
		this.item = response.result.records;	// 將多筆YouBike系統位置直接給我們item
}
接下來我們在html中使用Angular中的ngFor，即可將多筆資料顯示在前端。舉例列出車站的名稱：
tri001.component.html
<div *ngFor = "let i of item">
{{i.sna}}
</div>
___________________________________________________________________________________________________________________________________________________________________________________________________________________
初始化 Canvas 以及相關變數：
// Init canvas
const canvas = document.getElementById("my-canvas")
const ctx = canvas.getContext("2d")

const canvas_size = 500
convas.width = canvas_size
convas.height = canvas_size

let time = 0

function draw() {
	time++

	// Clear the canvas(每次更新影格)
	ctx.clearRect(0, 0, canvas_size, canvas_size)

	// ...
}

// update the canvas every 1000 / 30 per second
setInterval(draw, 1000 / 30)

// Mousemove Event
const mouse = {x: 0, y: 0}
canvas.addEventListener("mousemove", function(e) {
	mouse.x = e.offsetX
	mouse.y = e.offsetY
})

繪製電車：
// Train
let carX = time % 550 * 2 - 50
ctx.lineWidth = 1
ctx.fillStyle = "skyblue"
ctx.beginPath()
	ctx.fillRect(carX, 265, 50, 30)
	ctx.strokeRect(carX, 265, 50, 30)
	ctx.arc(carX + 10, 295, 5, 0, Math.PI)
	ctx.arc(carX + 40, 295, 5, 0, Math.PI)
ctx.fillStyle = "black";
ctx.fill();
ctx.stroke();

繪製旗幟：
// Flag
ctx.beginPath()
	ctx.moveTo(225, 200)
	// change the position of flag when mouse moving
	ctx.lineTo(225, 50 + mouse.y / 5)
	ctx.lineTo(250, 60 + mouse.y / 5 - time % 5)
	ctx.lineTo(225, 70 + mouse.y / 5)
ctx.closePath()
// change the color of flag when mouse moving
ctx.fillStyle = `hsl(${mouse.x % 360}, 50%, 50%`
ctx.fill()
ctx.stroke()
___________________________________________________________________________________________________________________________________________________________________________________________________________________
node --experimental-modules my app.mjs

使用 NVM 安裝 NPM
使用 NVM 管理不同版本的 node 與 npm
NPM = Node Package Manager

install
安裝 node.js 自帶 npm
nvm use 8.9.4
node -v
npm -v
npm run build	// 前端打包
想下載 json-server
$ npm install -g json-server	// -g 每個專案都能用的

每一個專案前端都能用 json server 去開想要的 json 檔，當 db 當 api 功能測試
"" 不能用 ''
{}物件
[] 陣列
Example
Create a db.json file
{
	"posts": [
		{ "id": 1, "title": "json-server", "author": "typicode" }
	],
	"comments": [
		{ "id": 1, "body": "some comment", "postId": 1 }
	],
	"profile": { "name": "typicode" }
}
Start JSON Server
$ json-server --watch db.json	// json-server --watch ./data/data.json	./ 是現在的位置

Now if you go to http://localhost:3000/posts/1, you'll get
{ "id": 1, "title": "json-server", "author": "typicode" }
Also when doing requests, it's good to know that:
If you make POST, PUT, PATCH or DELETE requests, changes will be automatically and safety saved to db.json using lowdb.
___________________________________________________________________________________________________________________________________________________________________________________________________________________
使用 require("fs") 載入 fs 模塊，模塊中所有方法都有同步和異步兩種。
異步：有一個回調函數
var fs = require("fs");		// 載入 fs 模塊

fs.unlink('/tmp/shiyanlou', function(err) {
	if(err) {
		throw err;
	}
	console.log("成功刪除了 /tmp/shiyanlou");
});

同步：
var fs = require("fs");

fs.unlinkSync("/tmp/shiyanlou");
console.log("成功刪除了 /tmp/shiyanlou");

var fs = require("fs");

readFile 讀取文件
fs.readFile(filename, [option], callback)
參數說明:
filename String 文件名
option Object
encoding String |null default=null
flag String default='r'
callback Function

readFile的回調函數接收兩個參數，err 是讀取文件出錯時觸發的錯誤對象，data 是從文件讀取的數據。
fs.readFile('./test.txt', function(err, data) {
	if (err) {
		throw err;
	}
	console.log(data);
});

這是原始二進制數據在緩衝區中的內容
要顯示文件內容可以使用toString()或者設置輸出編碼
toString()寫法:
fs.readFile("./test.txt", function(err, data) {
	if (err) {
		throw err;
	}
	console.log(data.toString());
});

設置 UTF-8 編碼寫法:
fs.readFile("./test.txt", "utf-8", function(err, data) {
	if (err) {
		throw err;
	}
	console.log("utf-8:", data.toString());
	// 直接用 console.log(data);也可
});

readFile同步的寫法就是沒有回調函數 (callback)： fs.readFileSync(filename, [options])
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Socket.IO 是一個面向即時 web 應用的 JavaScript 庫
使伺服器和客戶端之間即時雙向通信。有兩個部分：在瀏覽器執行的客戶端庫、面向 Node.js 的伺服器端庫。兩者有著幾乎一樣的 API。像 Node.js 一樣，它也是事件驅動。
socket.io 通訊協定基礎 websocket
server on		client emit

Socket.io 是個 WebSocket 庫，包括客戶端的 js 和伺服器端的 nodejs，目標是構建在不同瀏覽器和移動設備上的實時應用。會自動根據瀏覽器從 WebSocket、AJAX 長輪詢、IFrame 流等等各種方式中選擇最佳方式實現網路實時應用。

（程式實作 – 即時聊天室）
在這個範例中我們將會建立一個即時聊天室，透過 socket.io 來實現 Server 與多個 Client 之間的溝通，並在用戶登入的時候讀取所有對話記錄、送出訊息的時候發送到所有的用戶介面。

（初始化 server 端專案）
在 terminal 先新建並進入資料夾 mkdir socket-server && cd socket-server
接著安裝 socket.io 與 express（網頁伺服器框架） npm i socket.io express -s

（設定 socket 與 http(s) 連線）
建立 index.js ，index.js 是後端的主程式，負責處理用戶端傳來的事件並將結果廣播給所有用戶。我們首先設定 socket 與 api 的監聽端口。


*因為此範例都在本機電腦開發，並且直接連線到 localhost，故沒有設定 ssl 加密與 https。

var fs = require('fs')
// var https = require('https')
// 如果不用 https 的話，要改成引用 http 函式庫
var http = require('http')
var socketio = require('socket.io')

//https 的一些設定，如果不需要使用 ssl 加密連線的話，把內容註解掉就好
var options = {
    // key: fs.readFileSync('這個網域的 ssl key 位置'),
    // cert: fs.readFileSync('這個網域的 ssl fullchain 位置')
}

//http & socket port
var server = http.createServer(options);
server.listen(4040)
var io = socketio(server);
console.log("Server socket 4040 , api 4000")

//api port
var app = require('express')();			// like java's formate: new express()
var port = 4000;
app.listen(port, function () {
    console.log('API listening on *:' + port);
});

//用 api 方式建立連線
app.get('/api/messages', function (req, res) {
    let messages = 'hellow world'
    res.send(messages);
})

//用 socket 方式建立連線
io.on('connection', function (socket) {
    console.log('user connected')
})

執行 npm index.js ，如果出現以下訊息的話，代表我們的 http server 初步建立完成
Server socket 4040 , api 4000
API listening on *:4000

為了測試 api 連線是不是也是正常，我們直接使用瀏覽器連線到 server 監聽的 api 網址，成功看到透過 api GET 取得的回覆顯示在螢幕上，再打開 devtools 的 Network 也確認無誤，接下來可以進入 socket 的部分！

我們一樣先測試 socket 的連線能不能成功，但是要怎麼讓瀏覽器端可以連線到 socket 呢？
只要在 html 的 head 引用 socket.io 的裝置端套件就可以了 <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"></script>。我們直接在 <script> 裡面建立與伺服器的連線：var socket = io("<http://localhost:4040>")，將瀏覽器打開之後如果看到 server 有打印 user connected 的話就是連線成功囉。(到 network 儀表版也可以看到我們的請求成功)

（基本的訊息傳送）
不論在 server 或是 client，socket 都是透過 on 來監聽事件、用 emit 來發送事件，大致的關係會是這樣：

Server 端						建立連線/事件傳送方向		Client 端

io.on(‘connection’, function (socket) {…})			建立連線			socket = io(“socket ip:port”)

io.emit(“要對所有 Client 廣播的事件名稱”, data)
							———>			socket.on(“來自client 的事件名稱”, callback)
socket.emit(“要對當前連線的 Client 發送的事件名稱”, data)				

socket.on(“來自client 的事件名稱”, callback)			<———			socket.emit(“要對 server 發送的事件名稱”,data)


先由 client emit 一個最簡單的訊息看看，送出一個包含 name 與 message 的物件：
// index.html
// 建立與 server 的連線
var socket = io("<http://localhost:4040>")

// 發送一個 "sendMessage" 事件
socket.emit("sendMessage", {
            name: "majer",
            message: "hello everyone"
        })
// 監聽來自 server 的 "allMessage" 事件
socket.on("allMessage", function(message){
    console.log(message)
})

當然也別忘了在 server 加上”sendMessage” 事件的監聽器：
// index.js
io.on('connection', function (socket) {
    console.log('user connected')
    // 建立一個 "sendMessage" 的監聽
    socket.on("sendMessage", function (message) {
        console.log(message)
  // 當收到事件的時候，也發送一個 "allMessage" 事件給所有的連線用戶
  io.emit("allMessage", message)
    })
})
看一下 server 顯示的結果，果然把我們剛剛 emit 的資料印出來了
Server socket 4040 , api 4000
API listening on *:4000
user connected
{ name: 'majer', message: 'hello everyone' }

而瀏覽器也可以看到從 server 發送過來的 “allMessage” 事件：
15:42:12.319 received allMessage event
15:42:12.319 {name: "majer", message: "hello everyone"}

萬丈高樓平地起，我們緊接著就可以在這個基礎之上建立聊天室的介面囉。
（聊天室的功能）
我們列出聊天室會有的基本功能：
			進入聊天室時印出聊天室目前的對話記錄
			可以輸入用戶名稱與訊息，並且點擊後發送
			可以接收別人發送的新訊息
Server 端 🖥

我們先在 server 端把所有的對話內容與用戶儲存在 messages 陣列內，每當有新的用戶建立連線，就把之前的對話透過 allMessage 傳送給用戶。除此之外，我們也監聽用戶發送的 "sendMessage" 事件，除了發送新訊息給所有用戶之外，也把新收到的訊息塞到 messages 裡面，讓新用戶進來的時候可以看到。

// index.js
var messages = [
    { name: "Majer", message: "Welcome!"  }
]

io.on('connection', function (socket) {
    console.log('user connected')
    // 發送之前的全部訊息
    io.emit("allMessage", messages)
    // 當此用戶發送訊息的時候，先把新訊息放到 messages 陣列裡面
    // 再 emit 給所有用戶
    socket.on("sendMessage", function (message) {
        console.log(message)
        messages.push(message)
        io.emit("newMessage", message)
    })
})

User 端 👨🏼‍💻

在進入頁面的時候，我們使用 on("allMessage") 把之前的對話記錄都儲存到 messages 裡面，再透過 v-for 處理 messages 陣列，把對話的內容與用戶名稱印在畫面上。此外，加上新訊息的監聽 on("newMessage")，如果有新的訊息，也更新到 messages 的最後面。

發送訊息的部分，我們使用 Vue 把用戶的名稱與訊息綁定在 temp 上，每次發送的時候就直接送出 temp 物件，再把 temp.message 設定成空字串 '' 清空。

<body>
    <div id="app">
        <ul>
            <li v-for="m in messages">
                <h4>{{m.message}}<span>-- {{m.name}}</span></h4>
            </li>
        </ul>
        <!-- 將 name 與 message 綁定到 data 的 temp 物件內 -->
        <input v-model="temp.message" placeholder="訊息" @keydown.enter="sendMessage" />
        <input v-model="temp.name" placeholder="你是誰？" />
        <button @click="sendMessage">送出</button>
    </div>
</body>

<script>
    var vm = new Vue({
        el: "#app",
        data: {
            messages: [],
            temp: {},
            socket: null,
        },
        mounted() {
            this.socket = socket = io("<http://localhost:4040>")

            // 進入聊天室時，會收到之前的全部訊息，並更新到 messages
            this.socket.on("allMessage", obj => {
                console.log('received all messages')
                this.messages = obj
            })

            // 設定接收到新訊息的監聽器
            this.socket.on("newMessage", obj => {
                console.log('received new message')
                this.messages.push(obj)
            })
        },
        methods: {
            sendMessage() {
                console.log('sending new message')
                this.socket.emit("sendMessage", this.temp)
                this.temp.message = ""
            }
        }
    })
</script>

如此一來，我們就完成了最基礎的聊天室介面與功能了！


其他延伸
我們也可以加入其他的功能：
			顯示其他人在輸入中
			顯示用戶上線／下線
			設定用戶不重複的名字
			寄送私人訊息
			傳送圖片、gif

最後附上有加上輸入中版本的完整程式碼：
server：
var fs = require("fs")
// var https = require("https")
// 如果不需要用https的話，要改成引用http喔
var http = require("http")
var socketio = require("socket.io")

// https的一些設定，如果不需要使用ssl加密連線的話，把內容註解掉就好
var options = {
	// key: fs.readFileSync("這個網域的ssl key位置"),
	// cert: fs.readFileSync("這個網域的ssl fullchain位置")
}

// http & socket port
var server = http.createServer(options);
server.listen(4040)
var io = socketio(server);
console.log("Server socket 4040, api 4000")

// api port
var app = require("express")();
var port = 4040;
app.listen(port, function() {
	console.log("API listening on *:" + port);
});

// 用 api 方式取得
app.get("/api/messages", function(req, res) {
	let messages = "hello world"
	res.send(messages);
})

var messages = [
	{ name: "Majer", message: "Welcome!" }
]

var typing = false
var timer = null
// 用socket 方式取得
io.on("connection", function(socket) {
	console.log("user connected")
	socket.emit("allMessage", message)

	socket.on("sendMessage", function(message) {
		console.log(message)
		messages.push(message)
		io.emit("newMessage", message)
	})

	socket.on("sendTyping", function() {
		console.log("typing")
		typing = true
		io.emit("someoneIsTyping", typing)
		clearTimeout(timer)
		timer = setTimeout(() => {
			typing = false
			io.emit("someoneIsTyping", typing)
		}, 3000)
	})
})

client：
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.11/vue.min.js"></script>
</head>

<body>
    <div id="app">
        <ul>
            <li v-for="m in messages">
                <h4>{{m.message}}<span>-- {{m.name}}</span></h4>
            </li>
        </ul>

        <div>{{ typing?'輸入中...':'' }}</div>
        <br>
        <!-- 將 name 與 message 綁定到 data 的 temp 物件內 -->
        <input v-model="temp.message" placeholder="訊息" @keydown.enter="sendMessage" @keypress="sendTyping" />
        <input v-model="temp.name" placeholder="你是誰？" />
        <button @click="sendMessage">送出</button>
    </div>
</body>

<script>
    var vm = new Vue({
        el: "#app",
        data: {
            messages: [],
            temp: {},
            socket: null,
            typing: false
        },
        mounted() {
            this.socket = socket = io("http://localhost:4040")

            // 進入聊天室時，會收到之前的全部訊息，並更新到 messages
            this.socket.on("allMessage", obj => {
                console.log('received all messages')
                console.log(obj)
                this.messages = obj
            })

            // 設定接收到新訊息的監聽器
            this.socket.on("newMessage", obj => {
                console.log('received new message')
                this.messages.push(obj)
            })

            this.socket.on("someoneIsTyping", value => {
                this.typing = value
            })
        },
        methods: {
            sendMessage() {
                console.log('sending new message')
                this.socket.emit("sendMessage", this.temp)
                this.temp.message = ""
            },
            sendTyping() {
                this.socket.emit("sendTyping")
            }
        }
    })
</script>

</html>
