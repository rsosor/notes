（術語、知識）

瀏覽器渲染步驟：

HTML	→Parsing　　DOM　＼
			　　　Merging
			　　 Render Tree　　→　　Layout　　→　　Paint
CSS	→Parsing　　CSSOM ／


從 HTML 檔解析出 DOM Tree
從 CSS     檔解析出 CSSOM Tree
兩者疊加後產生      Render Tree
Reflow：計算出 Render Tree 上各個元素的物理屬性，如位置、大小、及是否看得見（visible）
Repaint：將計算結果轉為實際的像素，畫到畫面上

Reflow
如同前述，這個步驟會由 Render Tree 的根結點出發，逐步計算出每一個元素的位置、大小，以及是否被其他元素遮擋等屬性，需要耗費大量的運算資源；也因為是要計算出這些屬性，只要是有可能牽扯到這些屬性的操作，都會觸發 Reflow，例如：

．設定 CSS 屬性
　大小：width、height
　浮動：float
　定位：position
　...

．使用者進行互動
　調整瀏覽器視窗大小
　輸入框的內容變更

．JavaScript
　DOM 操作
　動態載入 CSS 樣式表
　取得元素的大小數值


較需注意「取得元素的大小數值」這一項，由於 Reflow 的計算相對於其他步驟需要較多運算效能，當有 Reflow 的需求時，瀏覽器不會馬上執行，而是會將它放到內部的等待隊列中，當需要時（每一 frame）才批次執行，並清空隊列。	// 這裡的 frame 也就是 window.requestAnimationFrame() 的那個 幀數

考慮到 Reflow 批次執行的特性，當開發者要取得元素的物理屬性例如 scrollTop 時，可能程式執行的當下有樣式修改仍在等待隊列，尚未 Reflow 到畫面上；為了避免這樣的狀況，每當開發者要獲取元素大小數值時，瀏覽器便會強制觸發一次 Reflow、以確保程式能取到正確的位置。而這也是許多網站的滑鼠滾輪事件監聽沒寫好，就讓整個網站超卡的原因！

Repaint
經過了 Reflow 的計算，Repaint 的任務是要把計算結果轉換成螢幕上的實際像素顯示。相比於 Reflow ，Repaint 就單純多了，任何可見元素的樣式變更，最後都必然需要重新繪製到畫面上，這是難以避免的效能開銷。


如同 Reflow 段落提到的，由於 Reflow 極耗效能，瀏覽器會 自動批次執行。
當 DOM 元素的樣式被修改觸發前述步驟時，瀏覽器會依據修改的屬性而 自動省略 不需要的步驟，重新渲染頁面。
修改 width → Reflow → Repaint
修改 color  → Repaint
理解上述規則之後，讀者您應該就能猜到該如何優化 CSS 效能了吧？↓提供幾種常見的方法：


1. 屬性替換
　將物理屬性的變化，換成相似的其他屬性變化，來節省 Reflow 的效能開銷：

．用 translate 取代 top 等定位屬性
．由於表格的物理屬性會互相影響，容易改一格就整張表 Reflow，可以的話請不要用 table 排版



2. 批次修改
　當需要用 JavaScript 修改樣式時，盡量讓樣式能批次生效：

．替換 class name 或修改 cssText，而不是逐個設定 style 屬性
．透過 el.cloneNode() 複製一份 DOM，在上面修改樣式後，在替換原本的 DOM
．透過 document.createDocumentFragment() 建立 Document Fragments，編輯 DOM 後再加回主 DOM Tree 中



3. 減少影響範圍
　如果 Reflow 是避免不了的，那就只能減少影響範圍了：

．盡量避免 DOM、CSSOM Tree 的層級過深，加快 Reflow 的計算
．程式取得元素物理屬性時，將結果暫存起來，不要重複觸發計算
．改動頻繁的地方 建立單獨的圖層（stacking context）





（沒有框架的日子）

那時最流行的「套件」jQuery ，語法簡潔、直覺的「元素選取器」，語法便捷的「事件監聽註冊」，豐富的開發者生態系產出大量開源套件，以及最重要的，弭平瀏覽器 XHR 差異的 ajax 函式，將複雜的瀏覽器差異藏在套件中，讓開發者只需要專注在想實作的邏輯即可。

透過好用的"元素選取器"及"事件監聽"，開發者們可以依據使用者的行為，靈活操作 DOM 元素的結構及樣式，jQuery 的這些特色直到 2019 的現在，都仍是很實用的功能；但隨專案增大程式複雜度不斷上升，直接操作 DOM 的缺點也就逐漸浮出檯面：

難以維護
HTML、CSS、JavaScript 無法維持原先的各司其職，因為需要透過 JavaScript 處理互動內容，勢必要將結構、樣式寫到 JavaScript 的部份中，也就因此造成「架構耦合度提高」，程式碼管理困難。

效能低落
在 Reflow 及 Repaint 是什麼？ 中有提到 Render Tree 的概念，當 DOM 被改變，勢必要觸發整個 Reflow & Repaint 的流程，頻繁的改動觸發重複渲染，便會讓頁面效能被消耗殆盡。


（框架的功能）

有前述問題自然有強者試圖解決。歷史進程中許多大神拋出了方法論，或實作出解決方案，但中間的歷史礙於篇幅簡略帶過。現今的「框架」其實就是一種提升開發效率、降低維護難度的開發架構。

資料與 UI 分離

原先想顯示一筆資料，可能必須寫死在 HTML 結構中：
<div id="root">
  <div class="card">
    <h3 class="name">Gary</h3>
    <p class="comment">something</p>
  </div>
</div>

若是動態的資料，可能要透過 JavaScript 將資料動態塞入 DOM 元素：
let commentData = [
  { name: 'Gary', comment: 'try harder'},
  { name: 'Alice', comment: 'good'},
  { name: 'Bob', comment: 'excellent'},
  //...
]

commentData.forEach(c => {
  $('#root').append(
    $(document.createElement('div')).append(
      $(document.createElement('h3')).text(c.name),
      $(document.createElement('p')).text(c.comment)
    ).addClass('card')
  )
})

Vue 中可能寫成這樣：
<template>
  <div id="root">
    <div class="card" v-for="item in commentData" :key="name">
      <h3 class="name">{{item.name}}</h3>
      <p class="comment">{{item.comment}}</p>
    </div>
  </div>
</template>

<script>
export default {
  data() {
    return {
      commentData: [
        { name: 'Gary', comment: 'try harder'},
        { name: 'Alice', comment: 'good'},
        { name: 'Bob', comment: 'excellent'},
        //...
      ]
    }
  }
}
</script>
乍看兩種好似，但考慮了可讀及可維護。透過 Vue 的寫法，讓頁面結構的部份仍然由 HTML 決定，並由資料來決定畫面該如何呈現。
關鍵由資料決定畫面！就是現代框架重要核心概念；將資料從介面中抽出，每個畫面都是對資料處理過後的呈現。


模組化 UI
網站總是有重複出現的元素，按鈕、輸入表單、表格、對話框等，像 FaceBook 按讚按鈕，可能一頁數十個；現代框架中，把這些重複出現元素稱 組件（Components），每個組件包含了組件自己需要用的結構、樣式、邏輯。
例如前述例子下午 08:44 2021/8/29，我們可以將 .card 這個元素抽成單獨的組件：一來各組件只需處理組件內的事，外部引用的組件來決定怎麼使用、提供什麼資料給組件，藉由簡單的切分權責，加上前述的由資料決定畫面，讓各組件任務單一，並且能被重複使用。

甚至現在有許多完成度很高的前端 UI 組件庫，讓開發者有如玩樂高一樣，能快速地用組件堆出想要的畫面，大幅度降低了組織畫面所需要的時間，讓工程師能更專注在處理商業邏輯上。


（效能）
頻繁操作 DOM 的方式改變畫面，可能會造成全頁面的 Reflow 及 Repaint；不過在使用框架時，開發者不用太擔心這個問題。

原因是各主流框架的實作中，幾乎都包含了「Virtual Dom」的概念，也就是用 JavaScript 物件來表達當前的頁面結構；藉由與 UI 分離的資料及 Virtual Dom 之間的關係，當資料變動時，事先計算好這次畫面需要變動地方，便能抵銷掉無意義的更動，並重複利用已存在的 DOM 元素；當真的要進行 DOM 更新時，也會一次將所有需要更新的局部組件更新，讓效能的耗損盡可能降低。

當然，Virtual Dom 變動的計算也是需要耗費運算資源的，過於簡單的專案或批次的大量修改，很有可能原生寫法還比框架快上不少



網頁設計→UIUX→前端→後端

web layout 網頁切版(不做設計單純做前端介面 UI)	// Flexbox: 其中一種排版方式

D3: 圖表效果？
AJAX: 跟資料庫接 API

1. 開版費(傳統方式，表頭、表尾等)，5000，內頁頁數計算
現在網頁技術所有東西都可以模組化、元件化，例如按鈕、標題、段落樣式

1. 網頁版型頁面數量
2. 動畫效果數量
3. 特定需求(瀏覽器、特定框架)
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（HTML）
DOM 是 HTML、XML 和 SVG 文件的程序介面。它提供了一個文件(樹)的結構化表示方法，並定義讓程序可以訪問並更改文件架構、樣式和內容的方法(像物件一樣被存取)。
W3C 定義了非常多的網頁規則好讓各大瀏覽器可以按照這些規則去設計瀏覽器，其中 DOM 就是其中的一個定義。

HTML DOM(Document Object Model)
	根據W3C DOM規範，DOM是一種與瀏覽器、平台、語言無關的接口，使得你可以訪問頁面中其他的標準組件。DOM解決了Netscape的JavaScript和Microsoft的JavaScript之間的衝突，給與Web設計師和開發者標準方法，讓他們來訪問他們站點中的數據、腳本和表現層對象。
	DOM是以層次結構組織的節點或信息片段的集合。這個層次結構允許開發人員在樹中導航尋找特定信息。分析該結構通常需要加載整個文檔和構造層次結構，才能做任何工作。由於它是基於信息層次的，因而DOM被認為是基於樹或基於對象的。
	HTML DOM定義了訪問和操作HTML文檔的標準方法。
	HTML DOM 把HTML文檔呈現為帶有元素、屬性和文本的樹結構(節點樹)。

		Document
		       |
	              Root element:
		   <html>
   Element:				Element:
    <head>					 <body>

   Element:	Attribute:	   ____	Element:		Element:
    <title>		  "href"		    <a>		   <h1>

     Text:				  Text:		  Text:
  "My title"		               "My link"	              "My header"


Document 就是指這份文件，也就是這份 HTML 檔的開端，所有的一切都會從 Document 開始往下進行。

Element 就是指文件內的各個標籤，因此像是 <div>、<p> 等等各種 HTML Tag 都是被歸類在 Element 裡面。

Text 就是指被各個標籤包起來的文字，舉例來說在 <h1>Hello World</h1> 中， Hello World 被 <h1> 這個 Element 包起來，因此 Hello World 就是此 Element 的 Text

Attribute 就是指各個標籤內的相關屬性。


由於 DOM 為樹狀結構，樹狀結構最重要的觀念就是 Node 彼此之間的關係，這邊可以分成以下兩種關係：

父子關係(Parent and Child)
簡單來說就是上下層節點，上層為 Parent Node ，下層為 Child Node 。

兄弟關係(Siblings)
簡單來說就是同一層節點，彼此間只有 Previous 以及 Next 兩種。


document.getElementById('idName')
找尋 DOM 中符合此 id 名稱的元素，並回傳相對應的 element 。

document.getElementsBytagName('tag')
找尋 DOM 中符合此 tag 名稱的所有元素，並回傳相對應的 element 集合，集合為 HTMLCollection 。

document.getElementsByClassName('className')
找尋 DOM 中符合此 class 名稱的所有元素，並回傳相對應的 element 集合，集合為 HTMLCollection 。

document.querySelector('selector')
利用 selector 來找尋 DOM 中的元素，並回傳相對應的第一個 element 。

document.querySelectorAll('selector')
利用 selector 來找尋 DOM 中的所有元素，並回傳相對應的第一個 element ，集合為 NodeList 。


這裡稍微提一下 HTMLCollection 以及 NodeList ，兩個都是 Collection of DOM Nodes ，那到底差在哪呢？

HTMLCollection
集合內元素為 HTML element ，也因此 Node type 只能接受 Element 。

NodeList
集合內元素為 Node ，也因此全部的 Node 都可以存放在 NodeLists 內。


其實真正常用的 DOM API 也就這幾種而已，尤其 jQuery 盛行，讓 HTML 與 JavaScript 的溝通更加精簡容易，也因此越來越多人捨棄 DOM API 進而投向 jQuery 的懷抱，筆者在未來的文章也會加以闡述這個 JavaScript Library 。
___________________________________________________________________________________________________________________________________________________________________________________________________________________
（CSS）
HTML 的屬性在 CSS 叫做性質
大部分放在 head 標籤


行內		段落		引用設定
style 屬性		區域性的設定	引入 .css 檔


字型、段落、顏色
font      text     color

元件名稱、class 名稱、id 名稱
div {
}

.colorRed {
}

#one {
}

background-color: 
background: 這個性質是特性簡寫，可以集合設定
color: 

margin、padding、border-width

左上座標(0, 0)




字型大小：
如 font-size 屬性
度量單位：
絕對: xx-small、x-small、small、medium、large、x-large、xx-large
相對: larger、smaller
絕對: point(pt)、pixel(px)、cm(公分)、in(英吋)、mm(公厘)
相對: em(預設 16)、rem(根據 html 元件，預設 16)、%

字體粗細：
font-weight 屬性
normal
bold
bolder
lighter
100-900

字型：
font-family 屬性，可同時設定多組(當瀏覽器不支援第一種就顯示第二種)




position: 
	static	預設定位，會照著瀏覽器預設的配置自動排版，無法定義 top、left、bottom 與 right 的數值。
	absolute	絕對定位(脫離常規，影響下一個元件位置)和 Fixed 屬性相似，不一樣在於他的基準點會以屬性是 Relative 的父層為基準，所以如果沒有 Relative 父層的情況下，他會直接找到 body（黃框）並以他為基準點。
	relative	相對定位(常規)，在沒有設定任何屬性的情況下，會和 Static 的呈現方式一樣。和 Static 不同於，可透過 top、left、bottom 與 right 改變他的位置，但無論它在頁面上移動了多少位置，都不影響其他元素的位置。
	fixed	可視區(viewport)絕對定位(脫離常規)，元素會以瀏覽器視窗（可視範圍）來定位，意味即便頁面滾動，他還是會固定在相同位置。特別的的地方是不會像 Relative 一樣會在原圖層留下他的空間，若後面還有 Relative 屬性的元素，則會黏在前面同是 Relative 或是 Static 屬性的元素下方。
	sticky	滾動黏滯定位(結合 relative、fixed，沒有跨越特定範圍時為 relative，超出(scroll-bar)則 fixed)，元素一定要在 top、left、bottom 或 right 中指定一個屬性，黏性定位才會生效！否則行為就和 Relative 屬性一樣。



z-index: 1(就可以在前景的上面)

___________________________________________________________________________________________________________________________________________________________________________________________________________________
（JavaScript）
ExtJS 是基於 JavaScript/Ajax 的前端框架；
Ajax（Asynchroious JavaScript and Xml）是基於 JavaScript 的技术。利用 xml 數據格式通信（txt、json亦可），具有與伺服器端異步通信特點的技術，是集中技術的融合

所有 JavaScript 中的函式都有一個內建的 prototype 屬性，指向一個特殊的 prototype 物件，prototype 物件中也有一個 constructor 屬性，指向原來的函式。
原型(prototype): number, string, boolean, undefined, 而 null 也是一种特殊的原始值。
太常使用所以提供原型物件: Number、String

var、let(較嚴謹)
不帶 var、let 宣告變量表示使用全域(global)

null、undefined、0、NaN


字串 + 數字 為 字串 (小心造成 bug 產品價格出現極端)
1 + 2	// 3
"1" + "2"	// "12"
1 + "2"	// "12"
"1" + 2	// "12"


三種回調函數方式：
callback、promise、async/await


event loop(事件循環)
從 stack 丟到 瀏覽器(Web API) 執行，瀏覽器(Web API) 返回到 queue，queue 再給 stack，讓 single thread 達到 偽異步

stack	→	browser
		↓
	↖	queue



event、event handler

___________________________________________________________________________________________________________________________________________________________________________________________________________________
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Ajax 標籤選單</title>
<script type = "text/javascript">
function getData(pageName) {
	//Ajax: XMLHttpRequest 物件專門用來和伺服器做連線
	var req = new XMLHttpRequest();
	req.open("get","http://localhost8080"+pageName);
	req.onload=function() {	//load事件，偵測連線的狀態結束
		//連線完成，做連線後的處理
		var content=document.getElementById("content");
		content.innerHTML=this.responseText;
	}
	req.send();		//送出連線
</script>
</head>
<body onload="getData('popular.htm');">
	<div>
		<span onclick="getData('popular.htm');">xxx</span>
		<span onclick="getData('latest.htm');">xxx</span>
	</div>
	<hr/>
	<div id = "content"></div>
</body>
</html>
陣列[0][1]
var colors=[];
colors[0] = 'black';
colors.push('Purple');		//增加，不用事先把陣列大小設定，底層執行預設創建與擴充
console.log(colors.length);	//用function當作參數編譯慢

物件xx.yy
var home2 = {
	father: 'bob',
	goDinner: function(num) {
		console.log(num+ 'people');
	}
};
console.log(home2.father);
home2.goDinner(3);

JSON格式
[
	{
		"id": "333",
		"name": [
			{"1": 'ss'},
			{"2": 'xx'}
		]
	}
]

javascript
$(function() {
	var home = {
		"father": 'tom',
		"mother: 'mary',
		'baby': [
			{'son': 'jack'},
			{'son': 'susan'},
			{'son': 'nico'}
		]
	};

	console.log(home.baby.length);
	for (var i in home.baby) {
		$('ul').append('<li>'+home.baby[i].son+'</li>');	//HTML裡的<body>內<ul>我想用javascript呈現出來，使用jQuery指定ul
	}
});

//for in可算出裡面的陣列數量開始跑迴圈，假使用Angular、React他有templete控制，不用for迴圈可以用repeat。
//$('class名稱')
//append()是jquery api，意思則是會在指定元素後面加上內容

//下列程式碼為jQuery撈遠端ajax的語法
//不希望網頁重新整理，想要局部修改內容或在遠端撈資料
$.ajax({
	type:'GET',
	url:'要撈的JSON網址',
	success:function(data) {
		xxx
	}
});

$(function() {
	$.ajax({
		type:'GET',
		url:'http://localhost:8080
		success:function(data) {
		//成功資料傳到data變數

		//判斷撈到的值是甚麼格式
			console.log(typeof(data));
		//將撈來的資料轉為 JSON 格式
			var thisdata = JSON.parse(data);
		//將內容顯示在網頁上
			$('body').html(thisdata[0].org_Text);
		}
	});
});

$(function() {
	$.ajax({
		type:'GET',
		url:'http://localhost:8080',
		success:function(data) {
			for(i=0; data.length>i; i++) {
				var thisData = JSON.parse(data);
				var str;
				var free = thisData[i].Ticketinfo;
				if(free=='免費參觀') {
					str = '<li>'+thisData[i].Name+'</li>';
					$('body').append(str);
				}
			}
		}
	});
});

<script>
	jQuery(document).ready(function($) {
		$('#send').on('click', function(event
			){
			event.preventDefault();
			var str = $('#password').val();
			console.log(str);
			$.post('/postAjax',{password:
				str}).success(function(data){
				console.log(data);
				if(data=='success'){
				alert('密碼輸入成功')
				}else{
					alert('密碼輸入錯誤')
				}
			});
		});
		$('#getData').on('click',function(
			event) {
			event.preventDefault();
			$.get('/getAjax').success(function(
				data) {
				// console.log(data)
				$('#list').children().remove()
				for(i=0; data.length>i; i++) {
					$('#list').append('<li>姓名: '+
						data[i].name+' 電話: '+data[i]
						.tel);
				}
			});
		});

傳統方式沒有用jquery ajax的話，例如POST後回傳的就不是id而是name取得

//傳統輸入
exports.post = function(req, res) {
	console.log(req);
	if(req.body.password == 1234) {
		res.render('pages/success');
	}else{
		res.render('pages/error')
	};
};

exports.postAjax = function(req, res) {
	//ajax
	if(req.body.password == 1234) {
		res.send('success');
	} else{
		res.send('error')
	};
};

//get取得資料
exports.getAjax = function(req, res) {
	res.send([{
		name: '王小名',
		tel:'0922194720'
	}, {
		name:'李小花',
		tel:'0983026183'
	}]);
};
___________________________________________________________________________________________________________________________________________________________________________________________________________________
<!-- HTML input -->

<div>
	<p>
		標題：<input id="post_example_name" name="product[name]"
			placeholde="請輸入標題"
			type="text" value="新標題" />
	</p>
	<p>
		價錢：<input id="post_example_price" min="0"
			name="product[price]"
			placeholder="請輸入價錢"
			type="number" value="100" />
	</p>
	<p>
		敘述：<textarea id="post_example_description"
			name="product[description]"></textarea>
	</p>
</div>
<! -- HTML card-->
<div class="_card">
	<div class="card-container">
		<div class="card-content">
			<h3 id="post_card_name">&nbsp;</h3>
			<h4 id="post_card_price" style="color:red;">&nbsp;</h4>
			<p id="post_card_description">&nbsp;</p>
		</div>
	</div>
</div>
<!-- javaScript -->
<script>

function initDynamicCard() {
	var cardNameElement =document.querySelector("#post_card_name");
	var cardPriceElement = document.querySelector("#post_card_price");
	var cardDescriptionElement = document.querySelector("#post_card_description");
	var exampleNameInput = document.querySelector("#post_example_name");
	var examplePriceInput = document.querySelector("#post_example_price");
	var exampleDescriptionInput = document.querySelector("#post_example_description");

	exampleNameInput.addEventListener('input', posts_36_card_update);
	examplePriceInput.addEventListener('input', posts_36_card_update); 
	exampleDescriptionInput.addEventListener('input', posts_36_card_update); 
 
	function posts_36_card_update(){ 
		var name = exampleNameInput.value; 
		var price = examplePriceInput.value; 
		var description = exampleDescriptionInput.value; 
		cardNameElement.innerHTML = name; 
		cardPriceElement.innerHTML = price; 
		cardDescriptionElement.innerHTML = description; 
	} 

	posts_36_card_update(); 
} 

initDynamicCard();
</script>
<! -- css -->

<style>
._card {
	width: 300px;
	height: 230px;
	position: relative;
	overflow: hidden;
	float: left;
}

._card > .card-container {
	position: absolute;
	background-color: rgba(0, 0, 0, 0.3);
	color: white;
	text-align: left;
	margin: auto;
	bottom: 0;
	height: 100%;
	width: 100%;
}

._card > .card-container > .card-content {
	padding: 16px;
}

._card > .card-container > .card-content > .price {
	color: red;
}
</style>
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Use JavaScript's jQuery Ajax

Get的使用，將對象數組渲染成頁面的DOM結構
測試接口能不能正常訪問到數據

	let newsData = {};
	$.get("http://127.0.0.1:3008/api/getnewslist", function(data,status) {
		console.log(data);
	});

編寫簡單的DOM結構和CSS樣式，並且寫出一個item元素方便調試樣式
使用jQuery獲取數據，並給newsData變數
編寫渲染方法，jQuery的$.each()對拿到的數據進行循環遍歷，使用prepend()進行向頁面添加元素的操作
prepend()的參數直接添加剛剛寫好的item元素的DOM結構，並將其中需要變化的幾個元素使用變數代替，直接使用遍歷出每個對象的屬性進行替換
執行加載方法load()，清空.content裡的DOM元素
html
//...

main.js
$(function() {
	let newsData = {};
	// 接口
	$.get("http://127.0.0.1:3008/api/getnewslist", function(data, status) {
		// console.log(data);
		newsData = data.message;
		load();
	});

	const load = () => {
		$.each(newsData, function(i, n ) {
			$(".content").prepend("<div class = 'item'><p class="title">"+ n.title
			+"</p><p class="cont"><span class="addtime">發布時間:"+n.addtime+"</span><span class = "click">點擊量:"+n.click
			+"</span></p></div>")
		})
	}
})
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Socket.io: node.js解決方案，讓APP建立即時通訊的JavaScript函式庫	封裝了Polling及WebSocket，使用的通訊協定基礎: WebSocket。透過在Server與Client之間建立持續的連線，可以即時的傳送資料給對方。
	是一個event-based全雙工的通訊函式庫，事件驅動這個部分是最容易出包的地方，當我們在和react專案整合在一起的時候，就需要去注意事件是不是有和畫面的渲染綁在一起，意思就是說不可以每渲染一次，我就重新建		立連結、重新監聽事件、重新發出訊息，這樣一來記憶體很快就會用完，處理器也根本來不及處理。
___________________________________________________________________________________________________________________________________________________________________________________________________________________
非同步撈取資料，使用onload去取得(GET？)	// XMLHttpRequest裡有open()、send()、onload()、responseText()
const xhr = new XMLHttpRequest();
const url = 'https://data.kcg.gov.tw/dataset/a98753a3-3446-4c9a-abfc-58dc49f2158c/resource/48d4dfc4-a4b2-44a5-bdec-70f9558cd25d/download/yopendata1070622opendatajson-1070622.json'
xhr.open('get', url, true)
xhr.send(null)

xhr.onload = function() {			// onload → 確定有資料回傳回來時執行後面 function()
	console.log(xhr.responseTest)
}

操作資料。JSON 一樣使用上面　高雄充電站 OPEN DATA
// 假如我們HTML上有<div class ="text></div>

let text = document.querySelector('.text');		// 操作HTML的重要步驟，document.querySelector('.text')
const xhr = new XMLHttpRequest();
const url = 'https://data.kcg.gov.tw/dataset/a98754a3-3446-4c9a-abfc-58dc49f2158c/resource/48d4dfc4-a4b2-44a5-bdec-70f9558cd25d/download/yopendata1070622opendatajson-1070622.json'
xhr.open('get', url, true)
xhr.send(null)

xhr.onload = function() {
	let str = JSON.parse(xhr.responseText)		// JSON.parse()用來將response的JSON字串(xhr.responseText)轉換成物件。
	text.textContent = str[0].Address;		// 操作HTML的<div class = "text">標籤內容，使用text.textContent = str[0].Address，把資料印到HTML上。
}

重新整理此流程：
1. 設立物件text型態作用是HTML的使用權
2. 建立一個XMLHttpRequest並open()、send()、onload()

搞不好撈的網址有錯誤(status404等)，所以我們沿用上面改寫
xhr.onload = function() {
	if(xhr.status == 200) {
		let str = JSON.parse(xhr.responseText)
		text.textContent = str[0].Address;
	}else {
		console.log('資料錯誤')
	}
}
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Angular
HttpClient is Angular's mechanism for communicating with a remote server over HTTP.
HttpClient撈取遠端資料
專案中可以把get後端API的function放在service，這樣每隻程式都可以從這邊拿資料。

programs.service.ts
import { HttpClient } from '@angular/common/http';
public getData()
	: Observable<any> {
	const URL = 'http://data.ntpc.gov.tw/api/v1/rest/datastore/382000000A-000352-001';
	return this.http.get<any>(URL);
	}
這邊用的是政府資料平台裡面的開放資料，我們可以先用postman來觀察資料的型態，可以觀察到這包資料在result=>records後裡面是用陣列存取的多筆YouBike系統位置
再來就可以到我們的component中去呼叫
tri001.component.ts
import { Component, OnInit} from '@angular/core';
import { ProgramsService} from '../programs.service';
import { HttpErrorResponse} from '@angular/common/http';

@Component( {
	selector: 'app-tri001',
	templateUrl: './tri001.component.html'
})
export class Tri001Component implements OnInit {
	public item: Array<any> = new Array<any>();	// 因為會有多筆，先建一個any型別的陣列資料來接回傳值
	constructor(private programService: ProgramsService) {}
	ngOnInit() {
		this.getData();	// 程式一啟動時即撈取資料
	}
	getData() {
		this.programService.getYouBikeData().subscribe(
			(response: any) => {
				this.item = response;
				console.log(this.item);	// log接到的資料
			},
			(error: HttpErrorResponse) => this.programService.HandleError(error)
		);
	}
}
getData()執行完(subscribe)，會有兩種結果
1. 就是得到資料=>將response給我們定義的item參數
2. 得不到資料或產生莫名錯誤=>利用HttpErrorResponse，將資料傳到共用HandleError()裡讓錯誤呈現在網頁上

programs.sevice.ts
// htttp呼叫錯誤處理
public HandleError(e: any): void {
	// console.log(e);
	alert(e.error.error);
}
撰寫好以後來看看會log的資料

這邊會有No 'Access-Control-Allow-Origin' header is present on the requested resource.的CROS問題
https://blog.gtwang.org/web-development/chrome-configuration-for-access-control-allow-origin/
先參考這篇文來解決

之後alert可以用Angular Material的Dialog改寫
接到資料以後，我們應該不會只想單純的在log中顯示吧
接下來要在網頁畫面上呈現
根據前面觀察到的回傳JSON型態
tri001.component.ts
getData() {
	this.programService.getYouBikeData().subscribe((response: any) => {
		this.item = response.result.records;	// 將多筆YouBike系統位置直接給我們item
}
接下來我們在html中使用Angular中的ngFor，即可將多筆資料顯示在前端。舉例列出車站的名稱：
tri001.component.html
<div *ngFor = "let i of item">
{{i.sna}}
</div>
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Socket.IO 是一個面向即時 web 應用的 JavaScript 庫
它使得伺服器和客戶端之間即時雙向的通信成為可能。他有兩個部分：在瀏覽器中執行的客戶端庫，和一個面向Node.js的伺服器端庫。兩者有著幾乎一樣的API。像Node.js一樣，它也是事件驅動的
socket.io 通訊協定基礎 websocket
server on		client emit

Socket.io是一个WebSocket库，包括了客户端的js和服务器端的nodejs，它的目标是构建可以在不同浏览器和移动设备上使用的实时应用。 它会自动根据浏览器从WebSocket、 AJAX 长轮询、Iframe流等等各种方式中选择最佳的方式来实现网络实时应用
___________________________________________________________________________________________________________________________________________________________________________________________________________________
初始化Canvas以及相關變數：
// Init canvas
const canvas = document.getElementById("my-canvas")
const ctx = canvas.getContext("2d")

const canvas_size = 500
convas.width = canvas_size
convas.height = canvas_size

let time = 0

function draw() {
	time++

	// Clear the canvas(每次更新影格)
	ctx.clearRect(0, 0, canvas_size, canvas_size)

	// ...
}

// update the canvas every 1000 / 30 per second
setInterval(draw, 1000 / 30)

// Mousemove Event
const mouse = {x: 0, y: 0}
canvas.addEventListener("mousemove", function(e) {
	mouse.x = e.offsetX
	mouse.y = e.offsetY
})

繪製電車：
// Train
let carX = time % 550 * 2 - 50
ctx.lineWidth = 1
ctx.fillStyle = "skyblue"
ctx.beginPath()
	ctx.fillRect(carX, 265, 50, 30)
	ctx.strokeRect(carX, 265, 50, 30)
	ctx.arc(carX + 10, 295, 5, 0, Math.PI)
	ctx.arc(carX + 40, 295, 5, 0, Math.PI)
ctx.fillStyle = "black";
ctx.fill();
ctx.stroke();

繪製旗幟：
// Flag
ctx.beginPath()
	ctx.moveTo(225, 200)
	// change the position of flag when mouse moving
	ctx.lineTo(225, 50 + mouse.y / 5)
	ctx.lineTo(250, 60 + mouse.y / 5 - time % 5)
	ctx.lineTo(225, 70 + mouse.y / 5)
ctx.closePath()
// change the color of flag when mouse moving
ctx.fillStyle = `hsl(${mouse.x % 360}, 50%, 50%`
ctx.fill()
ctx.stroke()
˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙˙
node --experimental-modules my app.mjs

使用NVM安裝NPM
使用NVM管理不同版本的node與npm
NPM=Node Package Manager

install
安裝node.js自帶npm
nvm use 8.9.4
node -v
npm -v
想下載json-server
$ npm install -g json-server	// -g每個專案都能用的

每一個專案前端都能用json server去開想要的json檔，當db當api功能測試
""不能用''
{}物件
[] 陣列
Example
Create a db.json file
{
	"posts": [
		{ "id": 1, "title": "json-server", "author": "typicode" }
	],
	"comments": [
		{ "id": 1, "body": "some comment", "postId": 1 }
	],
	"profile": { "name": "typicode" }
}
Start JSON Server
$ json-server --watch db.json	// json-server --watch ./data/data.json	./是現在的位置

Now if you go to http://localhost:3000/posts/1, you'll get
{ "id": 1, "title": "json-server", "author": "typicode" }
Also when doing requests, it's good to know that:
If you make POST, PUT, PATCH or DELETE requests, changes will be automatically and safety saved to db.json using lowdb.
___________________________________________________________________________________________________________________________________________________________________________________________________________________
使用require("fs")載入fs模塊，模塊中所有方法都有同步和異步兩種。
異步：有一個回調函數
var fs = require("fs");		// 載入fs模塊

fs.unlink('/tmp/shiyanlou', function(err) {
	if(err) {
		throw err;
	}
	console.log("成功刪除了 /tmp/shiyanlou");
});

同步：
var fs = require("fs");

fs.unlinkSync("/tmp/shiyanlou");
console.log("成功刪除了 /tmp/shiyanlou");

var fs = require("fs");

readFile讀取文件
fs.readFile(filename, [option], callback)
參數說明:
filename String 文件名
option Object
encoding String |null default=null
flag String default='r'
callback Function

readFile的回調函數接收兩個參數，err是讀取文件出錯時觸發的錯誤對象，data是從文件讀取的數據。
fs.readFile('./test.txt', function(err, data) {
	if (err) {
		throw err;
	}
	console.log(data);
});

這是原始二進制數據在緩衝區中的內容
要顯示文件內容可以使用toString()或者設置輸出編碼
toString()寫法:
fs.readFile("./test.txt", function(err, data) {
	if (err) {
		throw err;
	}
	console.log(data.toString());
});

設置UTF-8編碼寫法:
fs.readFile("./test.txt", "utf-8", function(err, data) {
	if (err) {
		throw err;
	}
	console.log("utf-8:", data.toString());
	// 直接用console.log(data);也可
});

readFile同步的寫法就是沒有回調函數(callback)： fs.readFileSync(filename, [options])
___________________________________________________________________________________________________________________________________________________________________________________________________________________
Socket.IO 是一個面向即時 web 應用的 JavaScript 庫
它使得伺服器和客戶端之間即時雙向的通信成為可能。他有兩個部分：在瀏覽器中執行的客戶端庫，和一個面向Node.js的伺服器端庫。兩者有著幾乎一樣的API。像Node.js一樣，它也是事件驅動的
socket.io 通訊協定基礎 websocket
server on		client emit

Socket.io是一个WebSocket库，包括了客户端的js和服务器端的nodejs，它的目标是构建可以在不同浏览器和移动设备上使用的实时应用。 它会自动根据浏览器从WebSocket、 AJAX 长轮询、Iframe流等等各种方式中选择最佳的方式来实现网络实时应用

（程式實作 – 即時聊天室）
在這個範例中我們將會建立一個即時聊天室，透過 socket.io 來實現 Server 與多個 Client 之間的溝通，並在用戶登入的時候讀取所有對話記錄、送出訊息的時候發送到所有的用戶介面。

（初始化 server 端專案）
在 terminal 先新建並進入資料夾 mkdir socket-server && cd socket-server
接著安裝 socket.io 與 express（網頁伺服器框架） npm i socket.io express -s

（設定 socket 與 http(s) 連線）
建立 index.js ，index.js 是後端的主程式，負責處理用戶端傳來的事件並將結果廣播給所有用戶。我們首先設定 socket 與 api 的監聽端口。


*因為此範例都在本機電腦開發，並且直接連線到 localhost，故沒有設定 ssl 加密與 https。

var fs = require('fs')
// var https = require('https')
// 如果不用 https 的話，要改成引用 http 函式庫
var http = require('http')
var socketio = require('socket.io')

//https 的一些設定，如果不需要使用 ssl 加密連線的話，把內容註解掉就好
var options = {
    // key: fs.readFileSync('這個網域的 ssl key 位置'),
    // cert: fs.readFileSync('這個網域的 ssl fullchain 位置')
}

//http & socket port
var server = http.createServer(options);
server.listen(4040)
var io = socketio(server);
console.log("Server socket 4040 , api 4000")

//api port
var app = require('express')();			// like java's formate: new express()
var port = 4000;
app.listen(port, function () {
    console.log('API listening on *:' + port);
});

//用 api 方式建立連線
app.get('/api/messages', function (req, res) {
    let messages = 'hellow world'
    res.send(messages);
})

//用 socket 方式建立連線
io.on('connection', function (socket) {
    console.log('user connected')
})

執行 npm index.js ，如果出現以下訊息的話，代表我們的 http server 初步建立完成
Server socket 4040 , api 4000
API listening on *:4000

為了測試 api 連線是不是也是正常，我們直接使用瀏覽器連線到 server 監聽的 api 網址，成功看到透過 api GET 取得的回覆顯示在螢幕上，再打開 devtools 的 Network 也確認無誤，接下來可以進入 socket 的部分！

我們一樣先測試 socket 的連線能不能成功，但是要怎麼讓瀏覽器端可以連線到 socket 呢？
只要在 html 的 head 引用 socket.io 的裝置端套件就可以了 <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"></script>。我們直接在 <script> 裡面建立與伺服器的連線：var socket = io("<http://localhost:4040>")，將瀏覽器打開之後如果看到 server 有打印 user connected 的話就是連線成功囉。(到 network 儀表版也可以看到我們的請求成功)

（基本的訊息傳送）
不論在 server 或是 client，socket 都是透過 on 來監聽事件、用 emit 來發送事件，大致的關係會是這樣：

Server 端						建立連線/事件傳送方向		Client 端

io.on(‘connection’, function (socket) {…})			建立連線			socket = io(“socket ip:port”)

io.emit(“要對所有 Client 廣播的事件名稱”, data)
							———>			socket.on(“來自client 的事件名稱”, callback)
socket.emit(“要對當前連線的 Client 發送的事件名稱”, data)				

socket.on(“來自client 的事件名稱”, callback)			<———			socket.emit(“要對 server 發送的事件名稱”,data)


先由 client emit 一個最簡單的訊息看看，送出一個包含 name 與 message 的物件：
// index.html
// 建立與 server 的連線
var socket = io("<http://localhost:4040>")

// 發送一個 "sendMessage" 事件
socket.emit("sendMessage", {
            name: "majer",
            message: "hello everyone"
        })
// 監聽來自 server 的 "allMessage" 事件
socket.on("allMessage", function(message){
    console.log(message)
})

當然也別忘了在 server 加上”sendMessage” 事件的監聽器：
// index.js
io.on('connection', function (socket) {
    console.log('user connected')
    // 建立一個 "sendMessage" 的監聽
    socket.on("sendMessage", function (message) {
        console.log(message)
  // 當收到事件的時候，也發送一個 "allMessage" 事件給所有的連線用戶
  io.emit("allMessage", message)
    })
})
看一下 server 顯示的結果，果然把我們剛剛 emit 的資料印出來了
Server socket 4040 , api 4000
API listening on *:4000
user connected
{ name: 'majer', message: 'hello everyone' }

而瀏覽器也可以看到從 server 發送過來的 “allMessage” 事件：
15:42:12.319 received allMessage event
15:42:12.319 {name: "majer", message: "hello everyone"}

萬丈高樓平地起，我們緊接著就可以在這個基礎之上建立聊天室的介面囉。
（聊天室的功能）
我們列出聊天室會有的基本功能：
			進入聊天室時印出聊天室目前的對話記錄
			可以輸入用戶名稱與訊息，並且點擊後發送
			可以接收別人發送的新訊息
Server 端 🖥

我們先在 server 端把所有的對話內容與用戶儲存在 messages 陣列內，每當有新的用戶建立連線，就把之前的對話透過 allMessage 傳送給用戶。除此之外，我們也監聽用戶發送的 "sendMessage" 事件，除了發送新訊息給所有用戶之外，也把新收到的訊息塞到 messages 裡面，讓新用戶進來的時候可以看到。

// index.js
var messages = [
    { name: "Majer", message: "Welcome!"  }
]

io.on('connection', function (socket) {
    console.log('user connected')
    // 發送之前的全部訊息
    io.emit("allMessage", messages)
    // 當此用戶發送訊息的時候，先把新訊息放到 messages 陣列裡面
    // 再 emit 給所有用戶
    socket.on("sendMessage", function (message) {
        console.log(message)
        messages.push(message)
        io.emit("newMessage", message)
    })
})

User 端 👨🏼‍💻

在進入頁面的時候，我們使用 on("allMessage") 把之前的對話記錄都儲存到 messages 裡面，再透過 v-for 處理 messages 陣列，把對話的內容與用戶名稱印在畫面上。此外，加上新訊息的監聽 on("newMessage")，如果有新的訊息，也更新到 messages 的最後面。

發送訊息的部分，我們使用 Vue 把用戶的名稱與訊息綁定在 temp 上，每次發送的時候就直接送出 temp 物件，再把 temp.message 設定成空字串 '' 清空。

<body>
    <div id="app">
        <ul>
            <li v-for="m in messages">
                <h4>{{m.message}}<span>-- {{m.name}}</span></h4>
            </li>
        </ul>
        <!-- 將 name 與 message 綁定到 data 的 temp 物件內 -->
        <input v-model="temp.message" placeholder="訊息" @keydown.enter="sendMessage" />
        <input v-model="temp.name" placeholder="你是誰？" />
        <button @click="sendMessage">送出</button>
    </div>
</body>

<script>
    var vm = new Vue({
        el: "#app",
        data: {
            messages: [],
            temp: {},
            socket: null,
        },
        mounted() {
            this.socket = socket = io("<http://localhost:4040>")

            // 進入聊天室時，會收到之前的全部訊息，並更新到 messages
            this.socket.on("allMessage", obj => {
                console.log('received all messages')
                this.messages = obj
            })

            // 設定接收到新訊息的監聽器
            this.socket.on("newMessage", obj => {
                console.log('received new message')
                this.messages.push(obj)
            })
        },
        methods: {
            sendMessage() {
                console.log('sending new message')
                this.socket.emit("sendMessage", this.temp)
                this.temp.message = ""
            }
        }
    })
</script>

如此一來，我們就完成了最基礎的聊天室介面與功能了！


其他延伸
我們也可以加入其他的功能：
			顯示其他人在輸入中
			顯示用戶上線／下線
			設定用戶不重複的名字
			寄送私人訊息
			傳送圖片、gif

最後附上有加上輸入中版本的完整程式碼：
server：
var fs = require("fs")
// var https = require("https")
// 如果不需要用https的話，要改成引用http喔
var http = require("http")
var socketio = require("socket.io")

// https的一些設定，如果不需要使用ssl加密連線的話，把內容註解掉就好
var options = {
	// key: fs.readFileSync("這個網域的ssl key位置"),
	// cert: fs.readFileSync("這個網域的ssl fullchain位置")
}

// http & socket port
var server = http.createServer(options);
server.listen(4040)
var io = socketio(server);
console.log("Server socket 4040, api 4000")

// api port
var app = require("express")();
var port = 4040;
app.listen(port, function() {
	console.log("API listening on *:" + port);
});

// 用 api 方式取得
app.get("/api/messages", function(req, res) {
	let messages = "hello world"
	res.send(messages);
})

var messages = [
	{ name: "Majer", message: "Welcome!" }
]

var typing = false
var timer = null
// 用socket 方式取得
io.on("connection", function(socket) {
	console.log("user connected")
	socket.emit("allMessage", message)

	socket.on("sendMessage", function(message) {
		console.log(message)
		messages.push(message)
		io.emit("newMessage", message)
	})

	socket.on("sendTyping", function() {
		console.log("typing")
		typing = true
		io.emit("someoneIsTyping", typing)
		clearTimeout(timer)
		timer = setTimeout(() => {
			typing = false
			io.emit("someoneIsTyping", typing)
		}, 3000)
	})
})

client：
<!-- index.html -->
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.6.11/vue.min.js"></script>
</head>

<body>
    <div id="app">
        <ul>
            <li v-for="m in messages">
                <h4>{{m.message}}<span>-- {{m.name}}</span></h4>
            </li>
        </ul>

        <div>{{ typing?'輸入中...':'' }}</div>
        <br>
        <!-- 將 name 與 message 綁定到 data 的 temp 物件內 -->
        <input v-model="temp.message" placeholder="訊息" @keydown.enter="sendMessage" @keypress="sendTyping" />
        <input v-model="temp.name" placeholder="你是誰？" />
        <button @click="sendMessage">送出</button>
    </div>
</body>

<script>
    var vm = new Vue({
        el: "#app",
        data: {
            messages: [],
            temp: {},
            socket: null,
            typing: false
        },
        mounted() {
            this.socket = socket = io("http://localhost:4040")

            // 進入聊天室時，會收到之前的全部訊息，並更新到 messages
            this.socket.on("allMessage", obj => {
                console.log('received all messages')
                console.log(obj)
                this.messages = obj
            })

            // 設定接收到新訊息的監聽器
            this.socket.on("newMessage", obj => {
                console.log('received new message')
                this.messages.push(obj)
            })

            this.socket.on("someoneIsTyping", value => {
                this.typing = value
            })
        },
        methods: {
            sendMessage() {
                console.log('sending new message')
                this.socket.emit("sendMessage", this.temp)
                this.temp.message = ""
            },
            sendTyping() {
                this.socket.emit("sendTyping")
            }
        }
    })
</script>

</html>
